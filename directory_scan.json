{
  "metadata": {
    "created_at": "2025-04-03T16:32:12.236916",
    "root_directory": "C:\\Users\\Bruno Martins\\Desktop\\Projetos Pessoais\\Node.js\\Em Produção\\whatsapp-devocional-IA",
    "excluded_paths": [
      "node_modules",
      ".venv",
      ".wwebjs_auth",
      ".wwebjs_cache",
      "Base_de_conhecimento",
      "whatsapp-session",
      "Conversas",
      "Contatos",
      ".env",
      "exclusion.txt",
      "package-lock.json",
      "app.py"
    ],
    "excluded_patterns": [
      "*.log",
      "*.tmp",
      "temp/*",
      "__pycache__/**"
    ]
  },
  "files": [
    {
      "path": "directory_scan.json",
      "name": "directory_scan.json",
      "extension": ".json",
      "size": 97624,
      "last_modified": "2025-04-03T16:28:53.159074",
      "content": "{\n  \"files\": [\n    {\n      \"path\": \"package.json\",\n      \"name\": \"package.json\",\n      \"extension\": \".json\",\n      \"size\": 906,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"{\\n  \\\"name\\\": \\\"whatsapp-devocional-ia\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"Bot de WhatsApp que envia mensagens devocionais diárias geradas por IA e responde a perguntas\\\",\\n  \\\"main\\\": \\\"src/index.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"NODE_OPTIONS=\\\\\\\"--max-old-space-size=512\\\\\\\" node src/index.js\\\",\\n    \\\"test:devocional\\\": \\\"node scripts/testar_devocional.js\\\",\\n    \\\"test:conversas\\\": \\\"node scripts/testar_conversas.js\\\",\\n    \\\"setup:contatos\\\": \\\"node scripts/criar_exemplo_contato.js\\\"\\n  },\\n  \\\"dependencies\\\": {\\n    \\\"@google/generative-ai\\\": \\\"^0.1.1\\\",\\n    \\\"@whiskeysockets/baileys\\\": \\\"^6.6.0\\\",\\n    \\\"cheerio\\\": \\\"^1.0.0-rc.12\\\",\\n    \\\"csv-parser\\\": \\\"^3.0.0\\\",\\n    \\\"dotenv\\\": \\\"^16.0.3\\\",\\n    \\\"fs-extra\\\": \\\"^11.1.0\\\",\\n    \\\"jimp\\\": \\\"^0.16.13\\\",\\n    \\\"moment\\\": \\\"^2.29.4\\\",\\n    \\\"node-schedule\\\": \\\"^2.1.1\\\",\\n    \\\"pdf-parse\\\": \\\"^1.1.1\\\",\\n    \\\"qrcode-terminal\\\": \\\"^0.12.0\\\",\\n    \\\"sharp\\\": \\\"^0.33.2\\\",\\n    \\\"xlsx\\\": \\\"^0.18.5\\\"\\n  }\\n}\"\n    },\n    {\n      \"path\": \"README.md\",\n      \"name\": \"README.md\",\n      \"extension\": \".md\",\n      \"size\": 7771,\n      \"last_modified\": \"2025-04-03T13:54:43.498753\",\n      \"content\": \"## Funcionalidade de Diálogo Interativo\\n\\nEsta versão do sistema inclui suporte para diálogo individualizado com os usuários:\\n\\n### Como funciona:\\n\\n1. **Envio do Devocional**: O sistema envia automaticamente o devocional diário para todos os contatos cadastrados no horário programado.\\n\\n2. **Recebimento de Mensagens**: Quando um usuário responde ou faz uma pergunta sobre o devocional, o sistema:\\n   - Analisa se a mensagem requer uma resposta elaborada\\n   - Usa a IA para gerar uma resposta personalizada considerando:\\n     - O devocional enviado recentemente\\n     - O histórico de conversa com aquele usuário específico\\n     - A base de conhecimento religiosa\\n\\n3. **Contexto Individualizado**: O sistema mantém históricos de conversa separados para cada usuário, permitindo:\\n   - Respostas personalizadas\\n   - Referências a mensagens anteriores da mesma conversa\\n   - Continuidade no diálogo\\n\\n### Configurações:\\n\\nNo arquivo `.env` você pode ajustar:\\n\\n- `RESPONDER_AUTOMATICAMENTE=true` - Ativar/desativar resposta automática\\n- `MAX_HISTORICO_CONVERSAS=10` - Número de mensagens armazenadas por conversa\\n\\n### Limitações:\\n\\n- O sistema foi projetado para responder a perguntas relacionadas ao devocional\\n- Mensagens curtas ou simples recebem respostas padrão mais breves\\n- A IA foi instruída a manter um tom amigável, acolhedor e espiritual# WhatsApp Devocional Diário com IA\\n\\nUm bot de WhatsApp automatizado que envia mensagens devocionais diárias geradas por IA para uma lista de contatos pré-definida.\\n\\n## Testes e Exemplos\\n\\nO sistema inclui scripts de teste para verificar componentes individuais:\\n\\n### Testar geração de devocionais:\\n\\n```bash\\nnode scripts/testar_devocional.js\\n```\\n\\nEste script gera um devocional usando a API do Google Gemini e sua base de conhecimento, sem enviar mensagens para os contatos. O resultado é exibido no console e salvo no arquivo `scripts/devocional_gerado.txt`.\\n\\n### Criar arquivo de contatos de exemplo:\\n\\n```bash\\nnode scripts/criar_exemplo_contatos.js\\n```\\n\\nEste script cria um arquivo Excel com contatos de exemplo na pasta `Contatos/` que você pode usar como referência para o formato correto.\\n\\n### Testar sistema de conversas com IA:\\n\\n```bash\\nnode scripts/testar_conversas.js\\n```\\n\\nEste script simula uma conversa interativa entre um usuário e o bot, permitindo testar como o sistema responde a perguntas sobre o devocional enviado. Você pode digitar mensagens como se fosse um usuário e ver as respostas geradas pela IA. Características\\n\\n- 🤖 Integração com o Google Gemini para geração de conteúdo devocional\\n- 📱 Envio automático de mensagens via WhatsApp\\n- 💬 **Diálogo individualizado com usuários através de IA generativa**\\n- 📊 Suporte para leitura de contatos de arquivos Excel e CSV\\n- 📚 Base de conhecimento personalizável com suporte para diversos formatos de arquivo\\n- 📅 Agendamento diário automático\\n- 📝 Registro de histórico para evitar repetição de versículos\\n- 🧩 Arquitetura modular para fácil manutenção e extensão\\n\\n## Requisitos\\n\\n- Node.js (v14 ou superior)\\n- Acesso à API do Google Gemini (chave de API)\\n- Um dispositivo ou servidor para executar o bot\\n\\n## Estrutura do Projeto\\n\\n```\\n📁 WhatsApp-Devocional-IA/\\n├── 📁 Base_de_conhecimento/     # Coloque aqui seus documentos de referência\\n├── 📁 Contatos/                 # Coloque aqui suas planilhas de contatos\\n├── 📁 Conversas/                # Armazena históricos de conversas individuais\\n├── 📁 Histórico/                # Histórico de mensagens enviadas\\n│   └── 📄 historico.json        # Registro automático dos envios\\n├── 📁 src/                      # Código fonte do sistema\\n│   ├── 📄 index.js              # Ponto de entrada da aplicação\\n│   ├── 📄 whatsapp.js           # Módulo de conexão com WhatsApp\\n│   ├── 📄 geradorDevocional.js  # Módulo gerador de devocionais com IA\\n│   ├── 📄 leitorDocumentos.js   # Módulo para processamento dos documentos base\\n│   ├── 📄 leitorContatos.js     # Módulo para leitura da lista de contatos\\n│   ├── 📄 historicoMensagens.js # Módulo para gerenciamento do histórico\\n│   ├── 📄 conversasHandler.js   # Módulo para diálogo individualizado com IA\\n│   └── 📄 utils.js              # Funções utilitárias\\n├── 📁 scripts/                  # Scripts de teste e utilitários\\n├── 📄 package.json              # Dependências do projeto\\n├── 📄 .env                      # Configurações do projeto\\n└── 📄 README.md                 # Esta documentação\\n```\\n\\n## Configuração\\n\\n1. Clone este repositório\\n2. Execute `npm install` para instalar as dependências\\n3. Copie o arquivo `.env.example` para `.env` e configure:\\n   - Chave de API do Google Gemini\\n   - Horário de envio das mensagens\\n   - Outras configurações conforme necessário\\n4. Adicione seus documentos de referência à pasta `Base_de_conhecimento`\\n5. Adicione sua lista de contatos à pasta `Contatos` (em formato Excel ou CSV)\\n\\n### Formato da Planilha de Contatos\\n\\nA planilha deve conter pelo menos as seguintes colunas:\\n- `Nome`: Nome do contato\\n- `Telefone`: Número de telefone com código do país (ex: 5511987654321)\\n- `Ativo`: Opcional, para indicar se o contato deve receber mensagens (Sim/Não)\\n\\n## Uso\\n\\nPara iniciar o bot:\\n\\n```bash\\nnpm start\\n```\\n\\nNa primeira execução, será exibido um QR Code que deve ser escaneado com o WhatsApp do seu celular para autenticar a sessão.\\n\\n##\\n\\n## Base de Conhecimento\\n\\nA pasta `Base_de_conhecimento` aceita os seguintes formatos de arquivo:\\n- PDF (.pdf)\\n- Texto simples (.txt)\\n- JSON (.json)\\n- Excel (.xlsx)\\n- CSV (.csv)\\n\\nEstes documentos serão utilizados como referência para a IA gerar os devocionais diários.\\n\\n## Personalização\\n\\nPara personalizar o formato dos devocionais, edite o arquivo `src/geradorDevocional.js`.\\n\\n## Manutenção\\n\\nO sistema mantém um histórico de mensagens enviadas para evitar repetição de versículos. Este histórico é armazenado em `Histórico/historico.json`.\\n\\n## Solução de Problemas\\n\\n### Cliente do WhatsApp não conecta\\n- Verifique se não há outra sessão do WhatsApp Web ativa\\n- Apague a pasta `whatsapp-session` e reinicie o sistema\\n- Certifique-se de escanear o QR code quando solicitado\\n\\n### Erros na geração do devocional\\n- Verifique se a chave de API do Google Gemini está correta no arquivo `.env`\\n- Certifique-se de usar o nome correto do modelo na API (gemini-1.5-pro ou gemini-pro)\\n- Verifique se há documentos válidos na pasta `Base_de_conhecimento`\\n- Execute o script de teste `scripts/testar_devocional.js` para verificar se a geração funciona\\n\\n### Problemas com contatos\\n- Verifique se o arquivo de contatos está no formato correto (Excel ou CSV)\\n- Certifique-se de que os contatos tenham pelo menos uma coluna chamada \\\"Nome\\\" e outra \\\"Telefone\\\"\\n- Confirme que os números de telefone estão completos com código do país (ex: 5511987654321)\\n- Use o arquivo de exemplo `contatos_exemplo.xlsx` como referência\\n- Para diagnóstico, verifique os logs detalhados que mostram como os contatos estão sendo processados\\n\\n### Erros no histórico de mensagens\\n- Se ocorrerem erros relacionados ao histórico, verifique se o arquivo `historico.json` existe e tem o formato correto\\n- Em caso de problemas persistentes, exclua o arquivo `Histórico/historico.json` e deixe o sistema recriá-lo automaticamente\\n\\n## Licença\\n\\nEste projeto está licenciado sob a Licença MIT - veja o arquivo LICENSE para detalhes.\"\n    },\n    {\n      \"path\": \"scripts\\\\criar_exemplo_contato.js\",\n      \"name\": \"criar_exemplo_contato.js\",\n      \"extension\": \".js\",\n      \"size\": 1594,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// Script para criar um arquivo de exemplo de contatos\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\n\\n// Diretório e arquivo\\nconst CONTATOS_DIR = '../Contatos';\\nconst ARQUIVO_EXEMPLO = path.join(CONTATOS_DIR, 'contatos_exemplo.xlsx');\\n\\n// Garantir que o diretório exista\\nif (!fs.existsSync(CONTATOS_DIR)) {\\n  fs.mkdirSync(CONTATOS_DIR, { recursive: true });\\n  console.log(`Diretório criado: ${CONTATOS_DIR}`);\\n}\\n\\n// Dados de exemplo\\nconst contatos = [\\n  { \\n    Nome: 'João Silva', \\n    Telefone: '5511987654321', \\n    Ativo: 'Sim',\\n    Observacoes: 'Contato principal'\\n  },\\n  { \\n    Nome: 'Maria Oliveira', \\n    Telefone: '5521998765432', \\n    Ativo: 'Sim',\\n    Observacoes: 'Contato secundário'\\n  },\\n  { \\n    Nome: 'Pedro Santos', \\n    Telefone: '5531987654321', \\n    Ativo: 'Não',\\n    Observacoes: 'Desativado temporariamente'\\n  },\\n  { \\n    Nome: 'Ana Costa', \\n    Telefone: '5541999887766', \\n    Ativo: 'Sim',\\n    Observacoes: 'Novo contato'\\n  },\\n  { \\n    Nome: 'Carlos Pereira', \\n    Telefone: '5551988776655', \\n    Ativo: 'Sim',\\n    Observacoes: ''\\n  }\\n];\\n\\n// Criar workbook e adicionar dados\\nconst workbook = xlsx.utils.book_new();\\nconst worksheet = xlsx.utils.json_to_sheet(contatos);\\n\\n// Adicionar a planilha ao workbook\\nxlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\\n\\n// Salvar o arquivo\\nxlsx.writeFile(workbook, ARQUIVO_EXEMPLO);\\n\\nconsole.log(`Arquivo de exemplo criado: ${ARQUIVO_EXEMPLO}`);\\nconsole.log('Modelo de contatos:');\\nconsole.table(contatos);\"\n    },\n    {\n      \"path\": \"scripts\\\\testar_devocional.js\",\n      \"name\": \"testar_devocional.js\",\n      \"extension\": \".js\",\n      \"size\": 3225,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// Script para testar o sistema de conversas individualizadas com IA\\n\\nrequire('dotenv').config({ path: '../.env' });\\nconst moment = require('moment');\\nmoment.locale('pt-br');\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst readline = require('readline');\\n\\n// Configurar o ambiente para execução independente\\nprocess.env.BASE_CONHECIMENTO_DIR = path.resolve(__dirname, '../Base_de_conhecimento');\\nprocess.env.CONVERSAS_DIR = path.resolve(__dirname, '../Conversas');\\n\\n// Importar módulos\\nconst conversasHandler = require('../src/conversasHandler');\\nconst { formatarData, logger } = require('../src/utils');\\n\\n// Configurar interface de linha de comando\\nconst rl = readline.createInterface({\\n  input: process.stdin,\\n  output: process.stdout\\n});\\n\\n// Telefone de teste\\nconst TELEFONE_TESTE = '5511999999999';\\n\\n// Devocional de exemplo para contextualizar a conversa\\nconst devocionalExemplo = `${formatarData(new Date())}\\n\\nVersículo: \\\"Não andeis ansiosos por coisa alguma; antes em tudo sejam os vossos pedidos conhecidos diante de Deus pela oração e súplica com ações de graças. E a paz de Deus, que excede todo entendimento, guardará os vossos corações e as vossas mentes em Cristo Jesus.\\\" (Filipenses 4:6-7)\\n\\nReflexão: A ansiedade tem sido um desafio comum em nossos dias. Este versículo nos lembra que podemos trazer todas as nossas preocupações a Deus através da oração. Quando escolhemos confiar nEle ao invés de nos sobrecarregarmos com preocupações, experimentamos uma paz que vai além da compreensão humana. É uma promessa poderosa para nossos momentos de inquietação.\\n\\nPrática: Hoje, quando sentir ansiedade surgindo, faça uma pausa para respirar e apresente a situação a Deus em oração, agradecendo antecipadamente por Sua intervenção.`;\\n\\n// Função para inicializar a conversa\\nasync function iniciarConversa() {\\n  console.log('=== TESTE DO SISTEMA DE CONVERSAS ===\\\\n');\\n  console.log('Simulando uma conversa individualizada com o bot\\\\n');\\n  \\n  // Registrar o devocional de exemplo\\n  await conversasHandler.registrarDevocionalEnviado(TELEFONE_TESTE, devocionalExemplo);\\n  \\n  console.log('Devocional enviado hoje:');\\n  console.log(devocionalExemplo);\\n  console.log('\\\\n-------------------------------------------\\\\n');\\n  console.log('Digite suas mensagens como se fosse um usuário respondendo ao devocional.');\\n  console.log('Digite \\\"sair\\\" para encerrar o teste.\\\\n');\\n  \\n  perguntarUsuario();\\n}\\n\\n// Função para processar a entrada do usuário\\nfunction perguntarUsuario() {\\n  rl.question('Você: ', async (mensagem) => {\\n    if (mensagem.toLowerCase() === 'sair') {\\n      console.log('\\\\nEncerrando teste...');\\n      rl.close();\\n      return;\\n    }\\n    \\n    console.log('\\\\nProcessando mensagem...');\\n    \\n    try {\\n      // Gerar resposta do bot\\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(TELEFONE_TESTE, mensagem);\\n      \\n      console.log(`\\\\nBot: ${resposta}\\\\n`);\\n    } catch (erro) {\\n      console.error('Erro ao gerar resposta:', erro.message);\\n    }\\n    \\n    // Continuar a conversa\\n    perguntarUsuario();\\n  });\\n}\\n\\n// Iniciar o teste\\niniciarConversa();\"\n    },\n    {\n      \"path\": \"src\\\\adicionarContato.js\",\n      \"name\": \"adicionarContato.js\",\n      \"extension\": \".js\",\n      \"size\": 8492,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// Módulo para adicionar novos contatos à planilha\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\nconst csvParser = require('csv-parser');\\nconst { logger } = require('./utils');\\n\\n// Diretório de contatos\\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\\n\\n// Obter a lista de arquivos de contatos disponíveis\\nfunction obterArquivosContatos() {\\n  try {\\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\\n    return arquivos.filter(arquivo => {\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      return extensao === '.xlsx' || extensao === '.csv';\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao ler diretório de contatos: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Adicionar novo contato à planilha\\nasync function adicionarNovoContatoNaPlanilha(telefone, nomeContato = \\\"Novo Contato\\\") {\\n  try {\\n    const arquivos = obterArquivosContatos();\\n    \\n    if (arquivos.length === 0) {\\n      logger.warn('Nenhum arquivo de contatos encontrado. Criando novo arquivo.');\\n      return criarNovoArquivoContatos(telefone, nomeContato);\\n    }\\n    \\n    // Usar o primeiro arquivo encontrado (normalmente contatos_exemplo.xlsx)\\n    const arquivoContatos = path.join(CONTATOS_DIR, arquivos[0]);\\n    const extensao = path.extname(arquivoContatos).toLowerCase();\\n    \\n    // Verificar se é Excel ou CSV\\n    if (extensao === '.xlsx') {\\n      return adicionarContatoExcel(arquivoContatos, telefone, nomeContato);\\n    } else if (extensao === '.csv') {\\n      return adicionarContatoCsv(arquivoContatos, telefone, nomeContato);\\n    } else {\\n      logger.error(`Formato de arquivo não suportado: ${extensao}`);\\n      return false;\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao adicionar novo contato ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Adicionar contato a um arquivo Excel\\nasync function adicionarContatoExcel(caminhoArquivo, telefone, nomeContato) {\\n  try {\\n    logger.info(`Adicionando contato ${telefone} ao arquivo Excel: ${caminhoArquivo}`);\\n    \\n    // Formatar o telefone conforme o padrão\\n    const telefoneFormatado = formatarTelefone(telefone);\\n    \\n    // Ler o arquivo Excel existente\\n    const workbook = xlsx.readFile(caminhoArquivo, {\\n      cellDates: true,\\n      cellNF: true,\\n      cellText: true\\n    });\\n    \\n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\\n      logger.error('Arquivo Excel sem planilhas');\\n      return false;\\n    }\\n    \\n    // Usar a primeira planilha\\n    const sheetName = workbook.SheetNames[0];\\n    const worksheet = workbook.Sheets[sheetName];\\n    \\n    // Converter para JSON para manipulação\\n    const dados = xlsx.utils.sheet_to_json(worksheet, {\\n      defval: '',\\n      raw: false\\n    });\\n    \\n    // Verificar se o contato já existe\\n    const contatoExistente = dados.find(contato => {\\n      // Normalizar números de telefone para comparação\\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\\\D/g, '');\\n      const telefoneNovo = telefoneFormatado.replace(/\\\\D/g, '');\\n      \\n      return telefoneExistente === telefoneNovo || \\n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \\n             `55${telefoneExistente}` === telefoneNovo;\\n    });\\n    \\n    if (contatoExistente) {\\n      logger.info(`Contato ${telefone} já existe na planilha.`);\\n      return false;\\n    }\\n    \\n    // Adicionar o novo contato\\n    const novoContato = {\\n      Nome: nomeContato,\\n      Telefone: telefoneFormatado,\\n      Ativo: 'Sim',\\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\\n    };\\n    \\n    dados.push(novoContato);\\n    \\n    // Converter de volta para planilha\\n    const novaWorksheet = xlsx.utils.json_to_sheet(dados);\\n    workbook.Sheets[sheetName] = novaWorksheet;\\n    \\n    // Salvar o arquivo atualizado\\n    xlsx.writeFile(workbook, caminhoArquivo);\\n    \\n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado à planilha com sucesso.`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao adicionar contato no Excel: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Adicionar contato a um arquivo CSV\\nasync function adicionarContatoCsv(caminhoArquivo, telefone, nomeContato) {\\n  try {\\n    logger.info(`Adicionando contato ${telefone} ao arquivo CSV: ${caminhoArquivo}`);\\n    \\n    // Formatar o telefone conforme o padrão\\n    const telefoneFormatado = formatarTelefone(telefone);\\n    \\n    // Ler o arquivo CSV existente\\n    const contatos = await new Promise((resolve, reject) => {\\n      const linhas = [];\\n      \\n      fs.createReadStream(caminhoArquivo)\\n        .pipe(csvParser())\\n        .on('data', (row) => {\\n          linhas.push(row);\\n        })\\n        .on('end', () => {\\n          resolve(linhas);\\n        })\\n        .on('error', (erro) => {\\n          reject(erro);\\n        });\\n    });\\n    \\n    // Verificar se o contato já existe\\n    const contatoExistente = contatos.find(contato => {\\n      // Normalizar números de telefone para comparação\\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\\\D/g, '');\\n      const telefoneNovo = telefoneFormatado.replace(/\\\\D/g, '');\\n      \\n      return telefoneExistente === telefoneNovo || \\n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \\n             `55${telefoneExistente}` === telefoneNovo;\\n    });\\n    \\n    if (contatoExistente) {\\n      logger.info(`Contato ${telefone} já existe no arquivo CSV.`);\\n      return false;\\n    }\\n    \\n    // Adicionar o novo contato\\n    const novoContato = {\\n      Nome: nomeContato,\\n      Telefone: telefoneFormatado,\\n      Ativo: 'Sim',\\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\\n    };\\n    \\n    contatos.push(novoContato);\\n    \\n    // Obter os cabeçalhos\\n    const cabecalhos = Object.keys(contatos[0]);\\n    \\n    // Criar o conteúdo CSV\\n    const csvContent = [\\n      cabecalhos.join(','),\\n      ...contatos.map(contato => \\n        cabecalhos.map(cabecalho => \\n          `\\\"${String(contato[cabecalho] || '').replace(/\\\"/g, '\\\"\\\"')}\\\"`\\n        ).join(',')\\n      )\\n    ].join('\\\\n');\\n    \\n    // Salvar o arquivo atualizado\\n    fs.writeFileSync(caminhoArquivo, csvContent, 'utf8');\\n    \\n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado ao CSV com sucesso.`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao adicionar contato no CSV: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Criar novo arquivo de contatos se não existir nenhum\\nfunction criarNovoArquivoContatos(telefone, nomeContato) {\\n  try {\\n    logger.info('Criando novo arquivo de contatos...');\\n    \\n    // Garantir que o diretório existe\\n    if (!fs.existsSync(CONTATOS_DIR)) {\\n      fs.mkdirSync(CONTATOS_DIR, { recursive: true });\\n    }\\n    \\n    // Formatar o telefone conforme o padrão\\n    const telefoneFormatado = formatarTelefone(telefone);\\n    \\n    // Criar dados iniciais\\n    const contatos = [\\n      {\\n        Nome: nomeContato,\\n        Telefone: telefoneFormatado,\\n        Ativo: 'Sim',\\n        Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\\n      }\\n    ];\\n    \\n    // Criar arquivo Excel\\n    const caminhoArquivo = path.join(CONTATOS_DIR, 'contatos.xlsx');\\n    const workbook = xlsx.utils.book_new();\\n    const worksheet = xlsx.utils.json_to_sheet(contatos);\\n    \\n    xlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\\n    xlsx.writeFile(workbook, caminhoArquivo);\\n    \\n    logger.info(`Novo arquivo de contatos criado com o contato ${telefoneFormatado}`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao criar novo arquivo de contatos: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Função auxiliar para formatar número de telefone\\nfunction formatarTelefone(telefone) {\\n  // Remover caracteres não numéricos\\n  let telefoneFormatado = String(telefone).replace(/\\\\D/g, '');\\n  \\n  // Adicionar código do país (55) se não estiver presente e for um número brasileiro\\n  if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\\n    telefoneFormatado = `55${telefoneFormatado}`;\\n  }\\n  \\n  return telefoneFormatado;\\n}\\n\\nmodule.exports = {\\n  adicionarNovoContatoNaPlanilha\\n};\"\n    },\n    {\n      \"path\": \"src\\\\conversasHandler.js\",\n      \"name\": \"conversasHandler.js\",\n      \"extension\": \".js\",\n      \"size\": 11390,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// Módulo para gerenciar conversas individuais com os usuários\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\\nconst leitorDocumentos = require('./leitorDocumentos');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst { logger, removerAcentos, limparString } = require('./utils');\\n\\n// Configurações\\nconst CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\\nconst MAX_HISTORICO_CONVERSAS = parseInt(process.env.MAX_HISTORICO_CONVERSAS || '10', 10);\\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\\n\\n// Inicializar cliente Gemini\\nlet genAI;\\nlet geminiModel;\\n\\n// Função para inicializar a API do Gemini\\nfunction inicializarGeminiAPI() {\\n  try {\\n    if (!GEMINI_API_KEY) {\\n      logger.error('Chave da API do Gemini não configurada no arquivo .env');\\n      return false;\\n    }\\n    \\n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\\n    \\n    // Tentar usar o modelo mais avançado primeiro\\n    try {\\n      geminiModel = genAI.getGenerativeModel({ model: \\\"gemini-1.5-pro\\\" });\\n      logger.info('API do Google Gemini (gemini-1.5-pro) inicializada com sucesso');\\n    } catch (erro) {\\n      logger.warn(`Erro ao inicializar modelo gemini-1.5-pro: ${erro.message}`);\\n      // Fallback para outro modelo\\n      geminiModel = genAI.getGenerativeModel({ model: \\\"gemini-pro\\\" });\\n      logger.info('API do Google Gemini (gemini-pro) inicializada com sucesso');\\n    }\\n    \\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Inicializar a API\\ninicializarGeminiAPI();\\n\\n// Garantir que o diretório de conversas exista\\nfunction garantirDiretorioConversas() {\\n  if (!fs.existsSync(CONVERSAS_DIR)) {\\n    fs.mkdirSync(CONVERSAS_DIR, { recursive: true });\\n    logger.info(`Diretório de conversas criado: ${CONVERSAS_DIR}`);\\n  }\\n}\\n\\n// Obter o caminho do arquivo de histórico para um telefone específico\\nfunction obterCaminhoHistoricoConversa(telefone) {\\n  garantirDiretorioConversas();\\n  const nomeArquivo = `${telefone}.json`;\\n  return path.join(CONVERSAS_DIR, nomeArquivo);\\n}\\n\\n// Carregar histórico de conversa de um usuário\\nfunction carregarHistoricoConversa(telefone) {\\n  try {\\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\\n    \\n    if (fs.existsSync(caminhoArquivo)) {\\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n      return JSON.parse(conteudo);\\n    }\\n    \\n    // Retornar histórico vazio se não existir\\n    return {\\n      telefone: telefone,\\n      ultimaAtualizacao: new Date().toISOString(),\\n      ultimoDevocional: null,\\n      conversas: []\\n    };\\n  } catch (erro) {\\n    logger.error(`Erro ao carregar histórico de conversa para ${telefone}: ${erro.message}`);\\n    return {\\n      telefone: telefone,\\n      ultimaAtualizacao: new Date().toISOString(),\\n      ultimoDevocional: null,\\n      conversas: []\\n    };\\n  }\\n}\\n\\n// Salvar histórico de conversa de um usuário\\nfunction salvarHistoricoConversa(historico) {\\n  try {\\n    garantirDiretorioConversas();\\n    \\n    // Atualizar a data da última atualização\\n    historico.ultimaAtualizacao = new Date().toISOString();\\n    \\n    // Limitar o número de mensagens no histórico\\n    if (historico.conversas.length > MAX_HISTORICO_CONVERSAS) {\\n      historico.conversas = historico.conversas.slice(-MAX_HISTORICO_CONVERSAS);\\n    }\\n    \\n    const caminhoArquivo = obterCaminhoHistoricoConversa(historico.telefone);\\n    fs.writeFileSync(caminhoArquivo, JSON.stringify(historico, null, 2));\\n    \\n    logger.info(`Histórico de conversa salvo para ${historico.telefone}`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao salvar histórico de conversa para ${historico.telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Registrar um devocional enviado para um usuário\\nfunction registrarDevocionalEnviado(telefone, devocional) {\\n  try {\\n    const historico = carregarHistoricoConversa(telefone);\\n    \\n    // Registrar o devocional atual\\n    historico.ultimoDevocional = {\\n      data: new Date().toISOString(),\\n      conteudo: devocional\\n    };\\n    \\n    return salvarHistoricoConversa(historico);\\n  } catch (erro) {\\n    logger.error(`Erro ao registrar devocional para ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Registrar uma mensagem na conversa\\nfunction registrarMensagem(telefone, remetente, mensagem) {\\n  try {\\n    const historico = carregarHistoricoConversa(telefone);\\n    \\n    // Adicionar a mensagem ao histórico\\n    historico.conversas.push({\\n      timestamp: new Date().toISOString(),\\n      remetente: remetente, // 'usuario' ou 'bot'\\n      mensagem: mensagem\\n    });\\n    \\n    return salvarHistoricoConversa(historico);\\n  } catch (erro) {\\n    logger.error(`Erro ao registrar mensagem para ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Verificar se uma mensagem parece ser uma pergunta\\nfunction ePergunta(mensagem) {\\n  // Remover acentos e converter para minúsculas\\n  const textoNormalizado = removerAcentos(mensagem.toLowerCase());\\n  \\n  // Verificar se termina com ponto de interrogação\\n  if (textoNormalizado.includes('?')) {\\n    return true;\\n  }\\n  \\n  // Verificar palavras-chave de perguntas\\n  const palavrasChavePergunta = [\\n    'quem', 'como', 'por que', 'porque', 'quando', 'onde', 'qual', 'quais',\\n    'o que', 'oq', 'pq', 'me explica', 'pode explicar', 'explique', 'significa',\\n    'entendi', 'não entendi', 'nao entendi', 'duvida', 'dúvida'\\n  ];\\n  \\n  return palavrasChavePergunta.some(palavra => textoNormalizado.includes(palavra));\\n}\\n\\n// Verificar se é a primeira interação de um usuário\\nasync function isPrimeiraInteracao(telefone) {\\n  try {\\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\\n    \\n    // Verificar se o arquivo de histórico existe\\n    const existeHistorico = fs.existsSync(caminhoArquivo);\\n    \\n    // Se o arquivo não existir, é a primeira interação\\n    if (!existeHistorico) {\\n      logger.info(`Arquivo de histórico não encontrado para ${telefone}, é a primeira interação`);\\n      return true;\\n    }\\n    \\n    // Se o arquivo existir, verificar se tem conteúdo válido\\n    try {\\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n      const historico = JSON.parse(conteudo);\\n      \\n      // Verificar se o histórico tem conversas\\n      if (!historico.conversas || historico.conversas.length === 0) {\\n        logger.info(`Histórico vazio para ${telefone}, considerando como primeira interação`);\\n        return true;\\n      }\\n      \\n      // Se chegou aqui, não é a primeira interação\\n      logger.info(`Usuário ${telefone} já tem histórico com ${historico.conversas.length} mensagens`);\\n      return false;\\n    } catch (erroLeitura) {\\n      logger.error(`Erro ao ler histórico para ${telefone}: ${erroLeitura.message}`);\\n      // Em caso de erro de leitura, considerar como primeira interação para garantir\\n      return true;\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar primeira interação para ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Preparar o prompt para a resposta da IA\\nasync function prepararPromptResposta(telefone, mensagemUsuario) {\\n  const historico = carregarHistoricoConversa(telefone);\\n  const ultimoDevocional = historico.ultimoDevocional ? historico.ultimoDevocional.conteudo : '';\\n  \\n  // Obter últimas conversas para contexto (limitado às 5 últimas)\\n  const conversasRecentes = historico.conversas.slice(-5);\\n  const conversasFormatadas = conversasRecentes.map(c => \\n    `${c.remetente === 'usuario' ? 'Pessoa' : 'Bot'}: ${c.mensagem}`\\n  ).join('\\\\n');\\n  \\n  // Obter conteúdo da base de conhecimento\\n  const baseConhecimento = await leitorDocumentos.obterConteudoBase();\\n  \\n  const prompt = `\\n  Você é um assistente espiritual que está respondendo perguntas sobre um devocional diário que você enviou para uma pessoa via WhatsApp.\\n  \\n  Seu último devocional enviado foi:\\n  ${ultimoDevocional}\\n  \\n  O contexto da conversa recente é:\\n  ${conversasFormatadas}\\n  \\n  A pessoa acabou de enviar esta mensagem para você:\\n  \\\"${mensagemUsuario}\\\"\\n  \\n  Baseie-se no devocional enviado e na seguinte base de conhecimento religiosa para responder:\\n  ${baseConhecimento.substring(0, 10000)}\\n  \\n  Responda à pergunta ou comentário da pessoa de forma amigável, acolhedora e espiritual. \\n  Mantenha a resposta concisa (até 5 frases), mas esclarecedora e relevante para a mensagem da pessoa.\\n  Se for uma pergunta sobre o devocional, dê uma resposta específica baseada no versículo e na reflexão.\\n  Se não for uma pergunta relacionada ao devocional, responda de forma generalista e gentil, evitando debates teológicos complexos.\\n  \\n  Não mencione que você é uma IA ou um bot. Responda como um aconselhador espiritual amigável.\\n  `;\\n  \\n  return prompt.trim();\\n}\\n\\n// Gerar resposta para uma mensagem do usuário\\nasync function gerarRespostaParaMensagem(telefone, mensagemUsuario) {\\n  try {\\n    // Verificar se a API Gemini está inicializada\\n    if (!geminiModel) {\\n      const inicializou = inicializarGeminiAPI();\\n      if (!inicializou) {\\n        return \\\"Não foi possível responder no momento. Por favor, tente novamente mais tarde.\\\";\\n      }\\n    }\\n    \\n    // Registrar a mensagem do usuário\\n    registrarMensagem(telefone, 'usuario', mensagemUsuario);\\n    \\n    // Verificar se a mensagem é uma pergunta ou comentário que precisa de resposta\\n    if (!ePergunta(mensagemUsuario) && mensagemUsuario.length < 10) {\\n      const respostasSimples = [\\n        \\\"Amém! Tenha um dia abençoado.\\\",\\n        \\\"Que Deus te abençoe hoje e sempre.\\\",\\n        \\\"Obrigado por compartilhar. Fique na paz de Cristo.\\\",\\n        \\\"Louvado seja Deus! Tenha um excelente dia.\\\",\\n        \\\"Que a graça de Deus esteja com você hoje.\\\"\\n      ];\\n      \\n      const resposta = respostasSimples[Math.floor(Math.random() * respostasSimples.length)];\\n      registrarMensagem(telefone, 'bot', resposta);\\n      return resposta;\\n    }\\n    \\n    // Preparar o prompt\\n    const prompt = await prepararPromptResposta(telefone, mensagemUsuario);\\n    \\n    // Gerar resposta com a IA\\n    const result = await geminiModel.generateContent({\\n      contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n      generationConfig: {\\n        temperature: 0.7,\\n        topK: 40,\\n        topP: 0.95,\\n        maxOutputTokens: 1024,\\n      },\\n    });\\n    \\n    const resposta = result.response.text().trim();\\n    \\n    // Registrar a resposta do bot\\n    registrarMensagem(telefone, 'bot', resposta);\\n    \\n    return resposta;\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar resposta para ${telefone}: ${erro.message}`);\\n    \\n    // Resposta de fallback em caso de erro\\n    const respostaFallback = \\\"Agradeço sua mensagem. Estou refletindo sobre isso e logo poderei responder com mais clareza. Que Deus abençoe seu dia.\\\";\\n    registrarMensagem(telefone, 'bot', respostaFallback);\\n    \\n    return respostaFallback;\\n  }\\n}\\n\\nmodule.exports = {\\n  registrarDevocionalEnviado,\\n  gerarRespostaParaMensagem,\\n  ePergunta,\\n  isPrimeiraInteracao\\n};\"\n    },\n    {\n      \"path\": \"src\\\\geradorDevocional.js\",\n      \"name\": \"geradorDevocional.js\",\n      \"extension\": \".js\",\n      \"size\": 10685,\n      \"last_modified\": \"2025-04-03T15:18:23.726040\",\n      \"content\": \"// Módulo gerador de devocionais com IA (Google Gemini)\\n\\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\\nconst leitorDocumentos = require('./leitorDocumentos');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst { logger } = require('./utils');\\n\\n// Configuração da API do Gemini\\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\\n\\n// Inicializar o cliente Gemini\\nlet genAI;\\nlet geminiModel;\\n\\n// Função para inicializar a API do Gemini\\nfunction inicializarGeminiAPI() {\\n  try {\\n    if (!GEMINI_API_KEY) {\\n      logger.error('Chave da API do Gemini não configurada no arquivo .env');\\n      return false;\\n    }\\n    \\n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\\n    \\n    // Corrigindo para usar o nome do modelo correto\\n    // Verificar qual modelo está disponível (gemini-pro ou gemini-1.5-pro)\\n    geminiModel = genAI.getGenerativeModel({ model: \\\"gemini-2.0-flash\\\" });\\n    \\n    logger.info('API do Google Gemini inicializada com sucesso');\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Tentar inicializar a API\\ninicializarGeminiAPI();\\n\\n// Gerar um prompt para o Gemini\\nasync function gerarPrompt(dataAtual) {\\n  try {\\n    // Obter conteúdo da base de conhecimento\\n    const baseConhecimento = await leitorDocumentos.obterConteudoBase();\\n    \\n    // Obter versículos recentes (para evitar repetições)\\n    const versiculosRecentes = historicoMensagens.obterVersiculosRecentes(10); // Aumentei para 10 dias\\n    const versiculosRecentesTexto = versiculosRecentes\\n      .map(v => {\\n        if (!v || !v.referencia || !v.texto) return '';\\n        return `${v.referencia}: \\\"${v.texto}\\\"`;\\n      })\\n      .filter(v => v) // Remove entradas vazias\\n      .join('\\\\n');\\n    \\n    // Adicionar log para debug\\n    logger.info(`Versículos a serem evitados: ${versiculosRecentesTexto || \\\"Nenhum\\\"}`);\\n    \\n    // Construir o prompt\\n    const prompt = `\\n      Você é um bot de WhatsApp com inteligência artificial projetado para enviar um devocional diário todas as manhãs.\\n      \\n      Seu objetivo é criar uma mensagem devocional que contenha:\\n      1. A data atual (${dataAtual})\\n      2. Um versículo bíblico relevante\\n      3. Um texto explicativo sobre o versículo (3-5 frases)\\n      4. Uma sugestão prática para o dia (1-2 frases)\\n      \\n      MUITO IMPORTANTE: Você deve gerar um devocional com um versículo diferente a cada dia. Nunca repita versículos que já foram usados recentemente.\\n      \\n      Baseie-se no seguinte conteúdo para selecionar o versículo e elaborar a reflexão:\\n      \\n      ${baseConhecimento.substring(0, 15000)} \\n      \\n      Evite usar ABSOLUTAMENTE os seguintes versículos que foram utilizados recentemente:\\n      ${versiculosRecentesTexto || \\\"Nenhum versículo recente a evitar.\\\"}\\n      \\n      O tom deve ser amigável, acolhedor e espiritual.\\n      \\n      Exemplo do formato esperado:\\n      \\n      \\\"📅 ${dataAtual}\\n      \\n      📖 *Versículo:* \\\\\\\"Tudo o que fizerem, façam de todo o coração, como para o Senhor.\\\\\\\" (Colossenses 3:23)\\n      \\n      💭 *Reflexão:* Este versículo nos lembra que nossas ações diárias, por menores que sejam, ganham significado quando as dedicamos a Deus. Trabalhar, ajudar alguém ou até descansar pode ser uma forma de honrá-Lo se fizermos com amor e propósito. Que tal começar o dia com essa intenção no coração?\\n      \\n      🧗🏼 *Prática:* Hoje, escolha uma tarefa simples e a realize com dedicação, pensando em como ela pode refletir seu cuidado com os outros e com Deus.\\\\\\\"\\n      \\n      Gere o devocional seguindo exatamente esse formato. induza o usuário a continuar a conversa.\\n    `;\\n    \\n    return prompt.trim();\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar prompt: ${erro.message}`);\\n    throw erro;\\n  }\\n}\\n\\n// Modifique a função gerarDevocional para incluir a validação\\nasync function gerarDevocional(dataAtual) {\\n  try {\\n    // Verificar se a API foi inicializada corretamente\\n    if (!geminiModel) {\\n      logger.warn('API do Gemini não inicializada. Tentando inicializar novamente...');\\n      \\n      // Tentar inicializar novamente\\n      const inicializou = inicializarGeminiAPI();\\n      \\n      if (!inicializou || !geminiModel) {\\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\\n      }\\n    }\\n    \\n    // Contador de tentativas para evitar loop infinito\\n    let tentativas = 0;\\n    const maxTentativas = 3;\\n    let devocionalValido = false;\\n    let devocional = '';\\n    \\n    while (!devocionalValido && tentativas < maxTentativas) {\\n      tentativas++;\\n      logger.info(`Gerando devocional - tentativa ${tentativas}/${maxTentativas}`);\\n      \\n      // Gerar o prompt com os versículos a serem evitados\\n      const prompt = await gerarPrompt(dataAtual);\\n      \\n      try {\\n        const result = await geminiModel.generateContent({\\n          contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n          generationConfig: {\\n            temperature: 0.7 + (tentativas * 0.1), // Aumentar a temperatura a cada tentativa\\n            topK: 40,\\n            topP: 0.95,\\n            maxOutputTokens: 1024,\\n          },\\n        });\\n        \\n        const response = result.response;\\n        devocional = response.text().trim();\\n        \\n        // Verificar se o devocional foi gerado corretamente\\n        if (!devocional || devocional.length < 50) {\\n          logger.warn('Devocional gerado muito curto ou vazio. Tentando novamente.');\\n          continue;\\n        }\\n        \\n        // Validar se o versículo não foi usado recentemente\\n        devocionalValido = await validarDevocionalGerado(devocional);\\n        \\n        if (devocionalValido) {\\n          logger.info('Devocional válido gerado com sucesso');\\n          return devocional;\\n        } else {\\n          logger.warn('Devocional gerado usa versículo repetido. Tentando novamente.');\\n        }\\n      } catch (erroGemini) {\\n        logger.warn(`Erro com o modelo na tentativa ${tentativas}: ${erroGemini.message}`);\\n        \\n        if (tentativas >= maxTentativas) {\\n          logger.error('Número máximo de tentativas atingido. Usando fallback.');\\n          return gerarDevocionalFallback(dataAtual);\\n        }\\n      }\\n    }\\n    \\n    // Se chegou aqui sem um devocional válido, usar fallback\\n    if (!devocionalValido) {\\n      logger.warn('Não foi possível gerar um devocional com versículo único. Usando fallback.');\\n      return gerarDevocionalFallback(dataAtual);\\n    }\\n    \\n    return devocional;\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\\n    return gerarDevocionalFallback(dataAtual);\\n  }\\n}\\n\\n// Gerar o devocional utilizando o Gemini\\nasync function gerarDevocional(dataAtual) {\\n  try {\\n    // Verificar se a API foi inicializada corretamente\\n    if (!geminiModel) {\\n      logger.warn('API do Gemini não inicializada. Tentando inicializar novamente...');\\n      \\n      // Tentar inicializar novamente\\n      const inicializou = inicializarGeminiAPI();\\n      \\n      if (!inicializou || !geminiModel) {\\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\\n      }\\n    }\\n    \\n    logger.info('Gerando prompt para o Gemini...');\\n    const prompt = await gerarPrompt(dataAtual);\\n    \\n    logger.info('Solicitando geração de devocional ao Gemini...');\\n    \\n    try {\\n      const result = await geminiModel.generateContent({\\n        contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n        generationConfig: {\\n          temperature: 0.7,\\n          topK: 40,\\n          topP: 0.95,\\n          maxOutputTokens: 1024,\\n        },\\n      });\\n      \\n      const response = result.response;\\n      const devocional = response.text().trim();\\n      \\n      // Verificar se o devocional foi gerado corretamente\\n      if (!devocional || devocional.length < 50) {\\n        logger.warn('Devocional gerado muito curto ou vazio. Usando fallback.');\\n        return gerarDevocionalFallback(dataAtual);\\n      }\\n      \\n      logger.info('Devocional gerado com sucesso');\\n      return devocional;\\n    } catch (erroGemini) {\\n      // Tentar usar outro modelo se o modelo atual falhar\\n      logger.warn(`Erro com o modelo atual. Detalhe: ${erroGemini.message}`);\\n      \\n      try {\\n        // Tentar com modelo alternativo\\n        logger.info('Tentando modelo alternativo gemini-pro...');\\n        const modeloAlternativo = genAI.getGenerativeModel({ model: \\\"gemini-pro\\\" });\\n        \\n        const resultadoAlternativo = await modeloAlternativo.generateContent({\\n          contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n          generationConfig: {\\n            temperature: 0.7,\\n            topK: 40,\\n            topP: 0.95,\\n            maxOutputTokens: 1024,\\n          },\\n        });\\n        \\n        const respostaAlternativa = resultadoAlternativo.response;\\n        const devocionalAlternativo = respostaAlternativa.text().trim();\\n        \\n        logger.info('Devocional gerado com sucesso usando modelo alternativo');\\n        return devocionalAlternativo;\\n      } catch (erroModeloAlternativo) {\\n        logger.error(`Erro também no modelo alternativo: ${erroModeloAlternativo.message}`);\\n        throw new Error(`Falha em todos os modelos Gemini disponíveis`);\\n      }\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\\n    \\n    // Retornar um devocional de fallback em caso de erro\\n    return gerarDevocionalFallback(dataAtual);\\n  }\\n}\\n\\n// Gerar um devocional de fallback em caso de erro na API\\nfunction gerarDevocionalFallback(dataAtual) {\\n  logger.info('Gerando devocional de fallback...');\\n  \\n  return `${dataAtual}\\n\\n*✝️ Versículo:* \\\"Não temas, porque eu sou contigo; não te assombres, porque eu sou teu Deus; eu te fortaleço, e te ajudo, e te sustento com a destra da minha justiça.\\\" (Isaías 41:10)\\n\\n*💭 Reflexão:* Mesmo quando enfrentamos dificuldades ou desafios inesperados, Deus está ao nosso lado, pronto para nos dar força e sustento. Este versículo nos lembra que não precisamos temer, pois temos a presença constante do Senhor em nossas vidas, guiando nossos passos e iluminando nosso caminho.\\n\\n*🧗🏻 Prática:* Hoje, ao enfrentar qualquer situação desafiadora, faça uma pausa, respire e relembre esta promessa de sustento divino antes de prosseguir.`;\\n}\\n\\nmodule.exports = {\\n  gerarDevocional\\n};\"\n    },\n    {\n      \"path\": \"src\\\\historicoMensagens.js\",\n      \"name\": \"historicoMensagens.js\",\n      \"extension\": \".js\",\n      \"size\": 11682,\n      \"last_modified\": \"2025-04-03T14:06:05.760106\",\n      \"content\": \"// Módulo para gerenciamento do histórico de mensagens enviadas\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst { logger } = require('./utils');\\n\\n// Configurações do histórico\\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Histórico';\\nconst HISTORICO_FILE = process.env.HISTORICO_FILE || './Histórico/historico.json';\\nconst MAX_HISTORICO_DIAS = parseInt(process.env.MAX_HISTORICO_DIAS || '90', 10);\\n\\n// Garantir que o diretório do histórico exista\\nfunction garantirDiretorioHistorico() {\\n  if (!fs.existsSync(HISTORICO_DIR)) {\\n    fs.mkdirSync(HISTORICO_DIR, { recursive: true });\\n    logger.info(`Diretório de histórico criado: ${HISTORICO_DIR}`);\\n  }\\n  \\n  if (!fs.existsSync(HISTORICO_FILE)) {\\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify({\\n      ultimaAtualizacao: new Date().toISOString(),\\n      mensagens: []\\n    }, null, 2));\\n    logger.info(`Arquivo de histórico criado: ${HISTORICO_FILE}`);\\n  }\\n}\\n\\n// Carregar o histórico de mensagens\\nfunction carregarHistorico() {\\n  try {\\n    garantirDiretorioHistorico();\\n    \\n    // Verificar se o arquivo existe e tem conteúdo válido\\n    if (fs.existsSync(HISTORICO_FILE)) {\\n      const conteudo = fs.readFileSync(HISTORICO_FILE, 'utf8');\\n      if (conteudo && conteudo.trim()) {\\n        const historico = JSON.parse(conteudo);\\n        // Garantir que o objeto tem a estrutura esperada\\n        if (!historico.mensagens) {\\n          historico.mensagens = [];\\n        }\\n        return historico;\\n      }\\n    }\\n    \\n    // Se o arquivo não existir, estiver vazio ou não tiver a estrutura esperada\\n    const historicoVazio = {\\n      ultimaAtualizacao: new Date().toISOString(),\\n      mensagens: []\\n    };\\n    \\n    // Salvar o histórico vazio para garantir consistência\\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\\n    \\n    return historicoVazio;\\n  } catch (erro) {\\n    logger.error(`Erro ao carregar histórico: ${erro.message}`);\\n    // Retornar um histórico vazio em caso de erro\\n    const historicoVazio = {\\n      ultimaAtualizacao: new Date().toISOString(),\\n      mensagens: []\\n    };\\n    \\n    // Tentar salvar o histórico vazio\\n    try {\\n      fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\\n    } catch (erroSalvar) {\\n      logger.error(`Erro ao salvar histórico vazio: ${erroSalvar.message}`);\\n    }\\n    \\n    return historicoVazio;\\n  }\\n}\\n\\n// Salvar o histórico de mensagens\\nfunction salvarHistorico(historico) {\\n  try {\\n    garantirDiretorioHistorico();\\n    \\n    // Atualizar a data da última atualização\\n    historico.ultimaAtualizacao = new Date().toISOString();\\n    \\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historico, null, 2));\\n    logger.info('Histórico salvo com sucesso');\\n  } catch (erro) {\\n    logger.error(`Erro ao salvar histórico: ${erro.message}`);\\n  }\\n}\\n\\n// Limpar mensagens antigas do histórico\\nfunction limparHistoricoAntigo(historico) {\\n  try {\\n    const dataLimite = new Date();\\n    dataLimite.setDate(dataLimite.getDate() - MAX_HISTORICO_DIAS);\\n    \\n    const mensagensRecentes = historico.mensagens.filter(msg => {\\n      const dataMensagem = new Date(msg.data);\\n      return dataMensagem >= dataLimite;\\n    });\\n    \\n    const mensagensRemovidas = historico.mensagens.length - mensagensRecentes.length;\\n    \\n    if (mensagensRemovidas > 0) {\\n      logger.info(`Removidas ${mensagensRemovidas} mensagens antigas do histórico`);\\n      historico.mensagens = mensagensRecentes;\\n      salvarHistorico(historico);\\n    }\\n    \\n    return historico;\\n  } catch (erro) {\\n    logger.error(`Erro ao limpar histórico antigo: ${erro.message}`);\\n    return historico;\\n  }\\n}\\n\\n// Extrair versículos de uma mensagem devocional\\nfunction extrairVersiculo(devocional) {\\n  try {\\n    // Procurar o padrão de versículo na mensagem\\n    const regexVersiculo = /Versículo:\\\\s*[\\\"'](.+?)[\\\"']\\\\s*\\\\((.+?)\\\\)/i;\\n    const match = devocional.match(regexVersiculo);\\n    \\n    if (match && match.length >= 3) {\\n      return {\\n        texto: match[1].trim(),\\n        referencia: match[2].trim()\\n      };\\n    }\\n    \\n    return null;\\n  } catch (erro) {\\n    logger.error(`Erro ao extrair versículo: ${erro.message}`);\\n    return null;\\n  }\\n}\\n\\n// Registrar um envio no histórico\\nfunction registrarEnvio(dados) {\\n  try {\\n    const historico = carregarHistorico();\\n    const versiculo = extrairVersiculo(dados.devocional);\\n    \\n    historico.mensagens.push({\\n      data: dados.data,\\n      devocional: dados.devocional,\\n      versiculo: versiculo,\\n      totalContatos: dados.totalContatos,\\n      enviosComSucesso: dados.enviosComSucesso,\\n      timestamp: new Date().toISOString()\\n    });\\n    \\n    // Limpar mensagens antigas antes de salvar\\n    limparHistoricoAntigo(historico);\\n    \\n    logger.info('Envio registrado no histórico com sucesso');\\n  } catch (erro) {\\n    logger.error(`Erro ao registrar envio no histórico: ${erro.message}`);\\n  }\\n}\\n\\n// Obter versículos usados recentemente (para evitar repetições)\\nfunction obterVersiculosRecentes(dias = 7) {\\n  try {\\n    const historico = carregarHistorico();\\n    const dataLimite = new Date();\\n    dataLimite.setDate(dataLimite.getDate() - dias);\\n\\n    // Adicionar log para debug\\n    logger.info(`Verificando versículos usados nos últimos ${dias} dias`);\\n    \\n    const versiculosRecentes = historico.mensagens\\n      .filter(msg => {\\n        if (!msg.data || !msg.versiculo) return false;\\n        const dataMensagem = new Date(msg.data);\\n        return isRecente = dataMensagem >= dataLimite;\\n\\n        // Log para cada entrada\\n        if (isRecente && msg.versiculo) {\\n          logger.info(`Versículo recente encontrado: ${msg.versiculo.referencia} usado em ${dataMensagem.toISOString()}`);\\n        }\\n        return isRecente && msg.versiculo\\n      })\\n      .map(msg => msg.versiculo);\\n    \\n    logger.info(`Total de ${versiculosRecentes.length} versículos recentes encontrados`);\\n    return versiculosRecentes;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter versículos recentes: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Verificar se um versículo foi usado recentemente\\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 7) { // Aumentei para 7 dias\\n  try {\\n    const versiculosRecentes = obterVersiculosRecentes(dias);\\n    \\n    // Normalizar a referência para comparação (remover espaços e converter para minúsculas)\\n    const referenciaFormatada = referencia.replace(/\\\\s+/g, '').toLowerCase();\\n    \\n    const encontrado = versiculosRecentes.some(versiculo => {\\n      if (!versiculo || !versiculo.referencia) return false;\\n      \\n      const versiculoFormatado = versiculo.referencia.replace(/\\\\s+/g, '').toLowerCase();\\n      const isMatch = versiculoFormatado === referenciaFormatada;\\n      \\n      if (isMatch) {\\n        logger.info(`Versículo ${referencia} já foi usado recentemente`);\\n      }\\n      \\n      return isMatch;\\n    });\\n    \\n    return encontrado;\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar versículo: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Obter o último devocional enviado\\nasync function obterUltimoDevocionalEnviado() {\\n  try {\\n    // Tentar obter do histórico geral primeiro\\n    const historico = carregarHistorico();\\n    \\n    if (historico && historico.mensagens && historico.mensagens.length > 0) {\\n      // Ordenar mensagens por data (mais recente primeiro)\\n      const mensagensOrdenadas = [...historico.mensagens].sort((a, b) => \\n        new Date(b.data) - new Date(a.data)\\n      );\\n      \\n      // Verificar se o último devocional foi enviado hoje\\n      const hoje = new Date();\\n      const dataHoje = `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, '0')}-${String(hoje.getDate()).padStart(2, '0')}`;\\n      \\n      // Encontrar o último devocional\\n      for (const msg of mensagensOrdenadas) {\\n        if (msg.devocional) {\\n          // Extrair a data do timestamp\\n          const dataMensagem = new Date(msg.timestamp || msg.data);\\n          const dataMensagemStr = `${dataMensagem.getFullYear()}-${String(dataMensagem.getMonth() + 1).padStart(2, '0')}-${String(dataMensagem.getDate()).padStart(2, '0')}`;\\n          \\n          // Se o devocional for de hoje, retorná-lo\\n          if (dataMensagemStr === dataHoje) {\\n            logger.info(`Devocional de hoje encontrado no histórico geral (${dataMensagemStr})`);\\n            return msg.devocional;\\n          }\\n        }\\n      }\\n      \\n      // Se não encontrar um devocional de hoje, retorna o mais recente\\n      const ultimoDevocional = mensagensOrdenadas.find(msg => msg.devocional);\\n      if (ultimoDevocional) {\\n        logger.info('Retornando devocional mais recente disponível do histórico geral');\\n        return ultimoDevocional.devocional;\\n      }\\n    }\\n    \\n    // Se não encontrou no histórico geral, buscar nas conversas individuais\\n    logger.info('Buscando devocional nas conversas individuais...');\\n    \\n    const CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\\n    if (!fs.existsSync(CONVERSAS_DIR)) {\\n      logger.warn(`Diretório de conversas não encontrado: ${CONVERSAS_DIR}`);\\n      return null;\\n    }\\n    \\n    // Ler arquivos de conversa\\n    const arquivos = fs.readdirSync(CONVERSAS_DIR);\\n    const arquivosJson = arquivos.filter(arquivo => arquivo.endsWith('.json'));\\n    \\n    let devocionalMaisRecente = null;\\n    let dataMaisRecente = new Date(0); // Data antiga\\n    \\n    // Buscar em todas as conversas\\n    for (const arquivo of arquivosJson) {\\n      try {\\n        const conteudo = fs.readFileSync(path.join(CONVERSAS_DIR, arquivo), 'utf8');\\n        const conversa = JSON.parse(conteudo);\\n        \\n        if (conversa.ultimoDevocional) {\\n          const dataDevocional = new Date(conversa.ultimoDevocional.data);\\n          \\n          // Verificar se é mais recente que o último encontrado\\n          if (dataDevocional > dataMaisRecente) {\\n            devocionalMaisRecente = conversa.ultimoDevocional.conteudo;\\n            dataMaisRecente = dataDevocional;\\n          }\\n        }\\n      } catch (erroLeitura) {\\n        logger.error(`Erro ao ler arquivo de conversa ${arquivo}: ${erroLeitura.message}`);\\n      }\\n    }\\n    \\n    if (devocionalMaisRecente) {\\n      logger.info(`Devocional encontrado nas conversas individuais (data: ${dataMaisRecente.toISOString()})`);\\n      return devocionalMaisRecente;\\n    }\\n    \\n    logger.warn('Nenhum devocional encontrado no histórico ou nas conversas');\\n    return null;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter último devocional: ${erro.message}`);\\n    return null;\\n  }\\n}\\n\\n// Verificar se um versículo foi usado recentemente\\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 30) {\\n  try {\\n    const versiculosRecentes = obterVersiculosRecentes(dias);\\n    \\n    // Normalizar a referência para comparação (remover espaços e converter para minúsculas)\\n    const referenciaFormatada = referencia.replace(/\\\\s+/g, '').toLowerCase();\\n    \\n    return versiculosRecentes.some(versiculo => {\\n      const versiculoFormatado = versiculo.referencia.replace(/\\\\s+/g, '').toLowerCase();\\n      return versiculoFormatado === referenciaFormatada;\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar versículo: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\nmodule.exports = {\\n  registrarEnvio,\\n  obterVersiculosRecentes,\\n  versiculoFoiUsadoRecentemente,\\n  obterUltimoDevocionalEnviado\\n};\"\n    },\n    {\n      \"path\": \"src\\\\index.js\",\n      \"name\": \"index.js\",\n      \"extension\": \".js\",\n      \"size\": 5072,\n      \"last_modified\": \"2025-04-03T14:19:11.019018\",\n      \"content\": \"// WhatsApp Devocional Diário com IA\\n// Ponto de entrada da aplicação\\n\\nrequire('dotenv').config();\\nconst fs = require('fs-extra');\\nconst schedule = require('node-schedule');\\nconst moment = require('moment');\\nmoment.locale('pt-br');\\n\\n// Importação dos módulos\\nconst whatsapp = require('./whatsapp');\\nconst geradorDevocional = require('./geradorDevocional');\\nconst leitorContatos = require('./leitorContatos');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst conversasHandler = require('./conversasHandler');\\nconst leitorDocumentos = require('./leitorDocumentos');\\nconst { criarDiretorios, formatarData, logger } = require('./utils');\\n\\n// Garantir que os diretórios necessários existam\\ncriarDiretorios();\\n\\n// Função principal que executa o envio dos devocionais\\nasync function enviarDevocionaisDiarios() {\\n  try {\\n    logger.info('Iniciando o processo de envio de devocionais diários');\\n    \\n    // Obter a data atual formatada\\n    const dataAtual = formatarData(new Date());\\n    logger.info(`Data atual: ${dataAtual}`);\\n    \\n    // Gerar o devocional do dia\\n    logger.info('Gerando devocional...');\\n    const devocional = await geradorDevocional.gerarDevocional(dataAtual);\\n    logger.info('Devocional gerado com sucesso');\\n    \\n    // Verificar se o cliente WhatsApp está pronto\\n    if (!whatsapp.clientePronto()) {\\n      logger.error('Cliente WhatsApp não está pronto. Tentando novamente em 5 minutos.');\\n      setTimeout(enviarDevocionaisDiarios, 5 * 60 * 1000);\\n      return;\\n    }\\n    \\n    // Obter a lista de contatos\\n    logger.info('Obtendo lista de contatos...');\\n    const contatos = await leitorContatos.obterContatos();\\n    logger.info(`${contatos.length} contatos encontrados`);\\n    \\n    // Enviar o devocional para cada contato\\n    let enviosComSucesso = 0;\\n    \\n    for (const contato of contatos) {\\n      try {\\n        logger.info(`Enviando devocional para ${contato.nome} (${contato.telefone})...`);\\n        await whatsapp.enviarMensagem(contato.telefone, devocional);\\n        \\n        // Registrar o devocional enviado para referência em conversas futuras\\n        await conversasHandler.registrarDevocionalEnviado(contato.telefone, devocional);\\n        \\n        enviosComSucesso++;\\n        logger.info(`Devocional enviado com sucesso para ${contato.nome}`);\\n      } catch (erro) {\\n        logger.error(`Erro ao enviar devocional para ${contato.nome}: ${erro.message}`);\\n      }\\n    }\\n    \\n    // Registrar no histórico\\n    historicoMensagens.registrarEnvio({\\n      data: dataAtual,\\n      devocional: devocional,\\n      totalContatos: contatos.length,\\n      enviosComSucesso: enviosComSucesso\\n    });\\n    \\n    logger.info(`Processo concluído. Enviado para ${enviosComSucesso}/${contatos.length} contatos.`);\\n  } catch (erro) {\\n    logger.error(`Erro ao executar o processo de envio: ${erro.message}`);\\n    logger.error(erro.stack);\\n  }\\n}\\n\\n// Pré-processar a base de conhecimento\\nasync function preprocessarBaseConhecimento() {\\n  try {\\n    logger.info('Iniciando pré-processamento da base de conhecimento...');\\n    const conteudoBase = await leitorDocumentos.obterConteudoBase();\\n    logger.info(`Base de conhecimento processada: ${conteudoBase.length} caracteres`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao processar base de conhecimento: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Inicialização do sistema\\nasync function iniciarSistema() {\\n  try {\\n    logger.info('Iniciando o sistema WhatsApp Devocional IA...');\\n    \\n    // Primeiro, processar a base de conhecimento\\n    logger.info('Processando base de conhecimento...');\\n    const baseProcessada = await preprocessarBaseConhecimento();\\n    \\n    if (!baseProcessada) {\\n      logger.warn('Houve um problema no processamento da base de conhecimento, mas o sistema continuará.');\\n    }\\n    \\n    // Depois, iniciar o cliente WhatsApp\\n    logger.info('Inicializando conexão com WhatsApp...');\\n    await whatsapp.iniciarCliente();\\n    \\n    // Agendar o envio diário de devocionais no horário configurado\\n    const horarioEnvio = process.env.SCHEDULE_TIME || '07:00';\\n    const [hora, minuto] = horarioEnvio.split(':').map(Number);\\n    \\n    schedule.scheduleJob(`${minuto} ${hora} * * *`, async () => {\\n      logger.info('Executando tarefa agendada de envio de devocionais');\\n      await enviarDevocionaisDiarios();\\n    });\\n    \\n    logger.info(`Sistema iniciado. Devocionais serão enviados diariamente às ${horarioEnvio}`);\\n    \\n    // Para desenvolvimento/testes: Descomentar para enviar um devocional imediatamente\\n     setTimeout(enviarDevocionaisDiarios, 10000);\\n  } catch (erro) {\\n    logger.error(`Erro ao iniciar o sistema: ${erro.message}`);\\n    logger.error(erro.stack);\\n  }\\n}\\n\\n// Iniciar o sistema\\niniciarSistema();\\n\\n// Tratamento de encerramento gracioso\\nprocess.on('SIGINT', async () => {\\n  logger.info('Encerrando o sistema...');\\n  await whatsapp.encerrarCliente();\\n  process.exit(0);\\n});\"\n    },\n    {\n      \"path\": \"src\\\\leitorContatos.js\",\n      \"name\": \"leitorContatos.js\",\n      \"extension\": \".js\",\n      \"size\": 8837,\n      \"last_modified\": \"2025-04-03T13:54:43.522193\",\n      \"content\": \"// Módulo para leitura da lista de contatos de arquivos Excel ou CSV\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\nconst csvParser = require('csv-parser');\\nconst { adicionarNovoContatoNaPlanilha } = require('./adicionarContato');\\nconst { logger } = require('./utils');\\n\\n// Diretório de contatos\\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\\n\\n// Obter a lista de arquivos de contatos disponíveis\\nfunction obterArquivosContatos() {\\n  try {\\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\\n    return arquivos.filter(arquivo => {\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      return extensao === '.xlsx' || extensao === '.csv';\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao ler diretório de contatos: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Ler contatos de um arquivo Excel\\nasync function lerContatosExcel(caminhoArquivo) {\\n  try {\\n    logger.info(`Lendo arquivo Excel: ${caminhoArquivo}`);\\n    \\n    // Opções adicionais para melhorar a leitura\\n    const workbook = xlsx.readFile(caminhoArquivo, {\\n      cellDates: true,\\n      cellNF: true,\\n      cellText: true\\n    });\\n    \\n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\\n      logger.error('Arquivo Excel sem planilhas');\\n      return [];\\n    }\\n    \\n    // Verificar todas as planilhas para encontrar contatos\\n    let todosContatos = [];\\n    \\n    for (const sheetName of workbook.SheetNames) {\\n      logger.info(`Processando planilha: ${sheetName}`);\\n      \\n      const worksheet = workbook.Sheets[sheetName];\\n      \\n      // Verificar se a planilha tem dados\\n      if (!worksheet['!ref']) {\\n        logger.warn(`Planilha ${sheetName} vazia, pulando...`);\\n        continue;\\n      }\\n      \\n      // Tentar ler os dados da planilha\\n      try {\\n        const dados = xlsx.utils.sheet_to_json(worksheet, {\\n          defval: '',  // Valor padrão para células vazias\\n          raw: false   // Não converter tipos automaticamente\\n        });\\n        \\n        logger.info(`Encontrados ${dados.length} registros na planilha ${sheetName}`);\\n        \\n        if (dados.length > 0) {\\n          const contatos = normalizarContatos(dados);\\n          logger.info(`${contatos.length} contatos válidos na planilha ${sheetName}`);\\n          todosContatos = todosContatos.concat(contatos);\\n        }\\n      } catch (erroLeitura) {\\n        logger.error(`Erro ao processar planilha ${sheetName}: ${erroLeitura.message}`);\\n      }\\n    }\\n    \\n    return todosContatos;\\n  } catch (erro) {\\n    logger.error(`Erro ao ler arquivo Excel: ${erro.message}`);\\n    logger.error(erro.stack);\\n    return [];\\n  }\\n}\\n\\n// Ler contatos de um arquivo CSV\\nasync function lerContatosCsv(caminhoArquivo) {\\n  return new Promise((resolve, reject) => {\\n    const contatos = [];\\n    \\n    fs.createReadStream(caminhoArquivo)\\n      .pipe(csvParser())\\n      .on('data', (row) => {\\n        contatos.push(row);\\n      })\\n      .on('end', () => {\\n        resolve(normalizarContatos(contatos));\\n      })\\n      .on('error', (erro) => {\\n        logger.error(`Erro ao ler arquivo CSV: ${erro.message}`);\\n        reject(erro);\\n      });\\n  });\\n}\\n\\n// Normalizar os dados dos contatos para um formato padrão\\nfunction normalizarContatos(dados) {\\n  if (!dados || !Array.isArray(dados) || dados.length === 0) {\\n    logger.warn('Nenhum dado de contato válido encontrado para normalizar');\\n    return [];\\n  }\\n  \\n  // Registrar os campos encontrados no primeiro registro para debug\\n  if (dados.length > 0) {\\n    logger.info(`Campos encontrados na planilha: ${Object.keys(dados[0]).join(', ')}`);\\n  }\\n  \\n  return dados.map(contato => {\\n    // Tentar encontrar os campos de nome e telefone, independente da capitalização\\n    const entradas = Object.entries(contato);\\n    let nome = '';\\n    let telefone = '';\\n    let ativo = true;\\n    \\n    // Debug para cada contato\\n    logger.info(`Processando contato: ${JSON.stringify(contato)}`);\\n    \\n    for (const [chave, valor] of entradas) {\\n      if (!chave) continue;\\n      \\n      const chaveLower = String(chave).toLowerCase();\\n      \\n      if (chaveLower.includes('nome')) {\\n        nome = valor;\\n        logger.info(`Nome encontrado: ${nome}`);\\n      } else if (\\n        chaveLower.includes('telefone') || \\n        chaveLower.includes('celular') || \\n        chaveLower.includes('whatsapp') || \\n        chaveLower.includes('fone') ||\\n        chaveLower.includes('phone') ||\\n        chaveLower.includes('numero')\\n      ) {\\n        telefone = valor;\\n        logger.info(`Telefone encontrado (original): ${telefone}`);\\n      } else if (\\n        chaveLower.includes('ativo') || \\n        chaveLower.includes('status') || \\n        chaveLower.includes('habilitado')\\n      ) {\\n        // Considerar o contato ativo se o campo for 'sim', 'true', 1, etc.\\n        if (typeof valor === 'string') {\\n          const valorLower = String(valor).toLowerCase();\\n          ativo = valorLower === 'sim' || valorLower === 'true' || valorLower === 's' || valorLower === 'y' || valorLower === 'yes';\\n        } else {\\n          ativo = Boolean(valor);\\n        }\\n      }\\n    }\\n    \\n    // Se não encontrar telefone, tentar encontrar algum campo que pareça ser um número de telefone\\n    if (!telefone) {\\n      for (const [chave, valor] of entradas) {\\n        // Verificar se o valor se parece com um número de telefone (apenas dígitos e com pelo menos 8 caracteres)\\n        if (valor && typeof valor === 'string' && valor.replace(/\\\\D/g, '').length >= 8) {\\n          telefone = valor;\\n          logger.info(`Possível telefone encontrado no campo ${chave}: ${telefone}`);\\n          break;\\n        }\\n      }\\n    }\\n    \\n    // Garantir que telefone seja uma string antes de aplicar replace\\n    let telefoneFormatado = '';\\n    if (telefone !== undefined && telefone !== null) {\\n      // Normalizar o telefone (remover caracteres não numéricos)\\n      telefoneFormatado = String(telefone).replace(/\\\\D/g, '');\\n      \\n      // Adicionar código do país (55) se não estiver presente e for um número brasileiro\\n      if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\\n        telefoneFormatado = `55${telefoneFormatado}`;\\n        logger.info(`Adicionado código do país: ${telefoneFormatado}`);\\n      }\\n    }\\n    \\n    logger.info(`Telefone formatado: ${telefoneFormatado}`);\\n    \\n    return {\\n      nome: nome || 'Sem nome',\\n      telefone: telefoneFormatado,\\n      ativo: ativo\\n    };\\n  })\\n  // Filtrar contatos sem telefone ou inativos\\n  .filter(contato => {\\n    // Verificar se o telefone é válido (pelo menos 10 dígitos)\\n    const telefoneValido = contato.telefone && contato.telefone.length >= 10;\\n    \\n    if (!telefoneValido) {\\n      logger.warn(`Contato \\\"${contato.nome}\\\" ignorado: número de telefone inválido (${contato.telefone})`);\\n    } else if (!contato.ativo) {\\n      logger.info(`Contato \\\"${contato.nome}\\\" ignorado: está marcado como inativo`);\\n    } else {\\n      logger.info(`Contato válido: ${contato.nome} (${contato.telefone})`);\\n    }\\n    \\n    return telefoneValido && contato.ativo;\\n  });\\n}\\n\\n// Função principal para obter todos os contatos de todos os arquivos\\nasync function obterContatos() {\\n  try {\\n    const arquivos = obterArquivosContatos();\\n    \\n    if (arquivos.length === 0) {\\n      logger.warn('Nenhum arquivo de contatos encontrado no diretório');\\n      return [];\\n    }\\n    \\n    let todosContatos = [];\\n    \\n    for (const arquivo of arquivos) {\\n      const caminhoArquivo = path.join(CONTATOS_DIR, arquivo);\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      \\n      logger.info(`Lendo contatos do arquivo: ${arquivo}`);\\n      \\n      let contatos = [];\\n      if (extensao === '.xlsx') {\\n        contatos = await lerContatosExcel(caminhoArquivo);\\n      } else if (extensao === '.csv') {\\n        contatos = await lerContatosCsv(caminhoArquivo);\\n      }\\n      \\n      logger.info(`${contatos.length} contatos válidos encontrados em ${arquivo}`);\\n      todosContatos = todosContatos.concat(contatos);\\n    }\\n    \\n    // Remover duplicatas baseadas no número de telefone\\n    const contatosUnicos = {};\\n    todosContatos.forEach(contato => {\\n      contatosUnicos[contato.telefone] = contato;\\n    });\\n    \\n    const resultado = Object.values(contatosUnicos);\\n    logger.info(`Total de ${resultado.length} contatos únicos encontrados`);\\n    \\n    return resultado;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter contatos: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\nmodule.exports = {\\n  obterContatos,\\n  adicionarNovoContatoNaPlanilha\\n};\"\n    },\n    {\n      \"path\": \"src\\\\leitorDocumentos.js\",\n      \"name\": \"leitorDocumentos.js\",\n      \"extension\": \".js\",\n      \"size\": 6949,\n      \"last_modified\": \"2025-04-03T13:54:43.522193\",\n      \"content\": \"// Módulo para processamento dos documentos base\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\nconst csvParser = require('csv-parser');\\nconst pdfParse = require('pdf-parse');\\nconst cheerio = require('cheerio');\\nconst { logger } = require('./utils');\\n\\n// Diretório de documentos base\\nconst BASE_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\\n\\n// Cache de documentos processados para evitar reprocessamento\\nlet documentosCache = null;\\nlet dataUltimaAtualizacao = null;\\n\\n// Verificar a necessidade de atualização do cache\\nfunction verificarCacheAtualizado() {\\n  if (!documentosCache || !dataUltimaAtualizacao) {\\n    return false;\\n  }\\n  \\n  // Verificar se algum arquivo foi modificado desde a última atualização\\n  try {\\n    const arquivos = obterArquivosBase();\\n    \\n    for (const arquivo of arquivos) {\\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\\n      const stats = fs.statSync(caminhoArquivo);\\n      \\n      if (stats.mtime > dataUltimaAtualizacao) {\\n        return false;\\n      }\\n    }\\n    \\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar cache: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Obter a lista de arquivos da base de conhecimento\\nfunction obterArquivosBase() {\\n  try {\\n    const arquivos = fs.readdirSync(BASE_DIR);\\n    return arquivos.filter(arquivo => {\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      return ['.pdf', '.json', '.txt', '.csv', '.xlsx'].includes(extensao);\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao ler diretório da base de conhecimento: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Processar um arquivo PDF\\nasync function processarPdf(caminhoArquivo) {\\n  try {\\n    const dataBuffer = fs.readFileSync(caminhoArquivo);\\n    const data = await pdfParse(dataBuffer);\\n    return data.text;\\n  } catch (erro) {\\n    logger.error(`Erro ao processar PDF ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Processar um arquivo JSON\\nfunction processarJson(caminhoArquivo) {\\n  try {\\n    const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n    const data = JSON.parse(conteudo);\\n    \\n    // Extrair textos do JSON (considerando diferentes estruturas possíveis)\\n    return extrairTextosJson(data);\\n  } catch (erro) {\\n    logger.error(`Erro ao processar JSON ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Extrair textos recursivamente de um objeto JSON\\nfunction extrairTextosJson(obj, textos = []) {\\n  if (!obj) return textos;\\n  \\n  if (typeof obj === 'string') {\\n    textos.push(obj);\\n  } else if (Array.isArray(obj)) {\\n    obj.forEach(item => extrairTextosJson(item, textos));\\n  } else if (typeof obj === 'object') {\\n    Object.values(obj).forEach(valor => extrairTextosJson(valor, textos));\\n  }\\n  \\n  return textos.join('\\\\n');\\n}\\n\\n// Processar um arquivo TXT\\nfunction processarTxt(caminhoArquivo) {\\n  try {\\n    return fs.readFileSync(caminhoArquivo, 'utf8');\\n  } catch (erro) {\\n    logger.error(`Erro ao processar TXT ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Processar um arquivo CSV\\nasync function processarCsv(caminhoArquivo) {\\n  return new Promise((resolve, reject) => {\\n    const linhas = [];\\n    \\n    fs.createReadStream(caminhoArquivo)\\n      .pipe(csvParser())\\n      .on('data', (row) => {\\n        linhas.push(Object.values(row).join(' '));\\n      })\\n      .on('end', () => {\\n        resolve(linhas.join('\\\\n'));\\n      })\\n      .on('error', (erro) => {\\n        logger.error(`Erro ao processar CSV ${caminhoArquivo}: ${erro.message}`);\\n        reject(erro);\\n      });\\n  });\\n}\\n\\n// Processar um arquivo Excel\\nfunction processarExcel(caminhoArquivo) {\\n  try {\\n    const workbook = xlsx.readFile(caminhoArquivo);\\n    const resultado = [];\\n    \\n    workbook.SheetNames.forEach(sheetName => {\\n      const worksheet = workbook.Sheets[sheetName];\\n      const dados = xlsx.utils.sheet_to_json(worksheet);\\n      \\n      dados.forEach(linha => {\\n        resultado.push(Object.values(linha).join(' '));\\n      });\\n    });\\n    \\n    return resultado.join('\\\\n');\\n  } catch (erro) {\\n    logger.error(`Erro ao processar Excel ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Processar HTML (para arquivos que possam conter HTML)\\nfunction processarHtml(conteudo) {\\n  try {\\n    const $ = cheerio.load(conteudo);\\n    // Remover scripts e estilos\\n    $('script').remove();\\n    $('style').remove();\\n    \\n    // Obter o texto\\n    return $('body').text().trim();\\n  } catch (erro) {\\n    logger.error(`Erro ao processar HTML: ${erro.message}`);\\n    return conteudo;\\n  }\\n}\\n\\n// Obter todo o conteúdo da base de conhecimento\\nasync function obterConteudoBase() {\\n  // Verificar se o cache está atualizado\\n  if (verificarCacheAtualizado()) {\\n    logger.info('Usando cache da base de conhecimento (sem alterações desde a última leitura)');\\n    return documentosCache;\\n  }\\n  \\n  try {\\n    const arquivos = obterArquivosBase();\\n    \\n    if (arquivos.length === 0) {\\n      logger.warn('Nenhum arquivo encontrado na base de conhecimento');\\n      return '';\\n    }\\n    \\n    logger.info(`Processando ${arquivos.length} arquivos da base de conhecimento...`);\\n    \\n    let conteudoCompleto = '';\\n    \\n    for (const arquivo of arquivos) {\\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      \\n      logger.info(`Processando arquivo: ${arquivo}`);\\n      \\n      let conteudo = '';\\n      \\n      switch (extensao) {\\n        case '.pdf':\\n          conteudo = await processarPdf(caminhoArquivo);\\n          break;\\n        case '.json':\\n          conteudo = processarJson(caminhoArquivo);\\n          break;\\n        case '.txt':\\n          conteudo = processarTxt(caminhoArquivo);\\n          break;\\n        case '.csv':\\n          conteudo = await processarCsv(caminhoArquivo);\\n          break;\\n        case '.xlsx':\\n          conteudo = processarExcel(caminhoArquivo);\\n          break;\\n        default:\\n          logger.warn(`Tipo de arquivo não suportado: ${extensao}`);\\n          continue;\\n      }\\n      \\n      // Verificar se o conteúdo pode conter HTML e processá-lo se necessário\\n      if (conteudo.includes('<html') || conteudo.includes('<body') || conteudo.includes('<div')) {\\n        conteudo = processarHtml(conteudo);\\n      }\\n      \\n      conteudoCompleto += conteudo + '\\\\n\\\\n';\\n    }\\n    \\n    // Atualizar o cache\\n    documentosCache = conteudoCompleto;\\n    dataUltimaAtualizacao = new Date();\\n    \\n    logger.info('Base de conhecimento processada com sucesso');\\n    return conteudoCompleto;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter conteúdo da base: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\nmodule.exports = {\\n  obterConteudoBase\\n};\"\n    },\n    {\n      \"path\": \"src\\\\utils.js\",\n      \"name\": \"utils.js\",\n      \"extension\": \".js\",\n      \"size\": 3074,\n      \"last_modified\": \"2025-04-03T13:54:43.522193\",\n      \"content\": \"// Módulo de funções utilitárias\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst moment = require('moment');\\nmoment.locale('pt-br');\\n\\n// Configurações dos diretórios\\nconst BASE_CONHECIMENTO_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Histórico';\\n\\n// Logger simples\\nconst logger = {\\n  info: (mensagem) => {\\n    console.log(`[INFO] ${new Date().toISOString()} - ${mensagem}`);\\n  },\\n  warn: (mensagem) => {\\n    console.warn(`[WARN] ${new Date().toISOString()} - ${mensagem}`);\\n  },\\n  error: (mensagem) => {\\n    console.error(`[ERROR] ${new Date().toISOString()} - ${mensagem}`);\\n  }\\n};\\n\\n// Criar diretórios necessários\\nfunction criarDiretorios() {\\n  try {\\n    [BASE_CONHECIMENTO_DIR, CONTATOS_DIR, HISTORICO_DIR].forEach(dir => {\\n      if (!fs.existsSync(dir)) {\\n        fs.mkdirSync(dir, { recursive: true });\\n        logger.info(`Diretório criado: ${dir}`);\\n      }\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao criar diretórios: ${erro.message}`);\\n  }\\n}\\n\\n// Verificar se um caminho existe\\nfunction caminhoExiste(caminho) {\\n  return fs.existsSync(caminho);\\n}\\n\\n// Formatar data no estilo brasileiro (dia de mês de ano)\\nfunction formatarData(data) {\\n  return moment(data).format('D [de] MMMM [de] YYYY');\\n}\\n\\n// Remover acentos de uma string\\nfunction removerAcentos(texto) {\\n  return texto.normalize('NFD').replace(/[\\\\u0300-\\\\u036f]/g, '');\\n}\\n\\n// Limpar string (remover caracteres especiais, espaços extras, etc.)\\nfunction limparString(texto) {\\n  if (!texto) return '';\\n  \\n  return texto\\n    .replace(/\\\\s+/g, ' ')              // Substitui múltiplos espaços por um único\\n    .replace(/[^\\\\w\\\\s\\\\-\\\\.,;:!?'\\\"()]/g, '') // Remove caracteres especiais (exceto pontuação básica)\\n    .trim();                           // Remove espaços no início e fim\\n}\\n\\n// Escapar caracteres especiais para regex\\nfunction escaparRegex(texto) {\\n  return texto.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, '\\\\\\\\$&');\\n}\\n\\n// Gerar um ID único\\nfunction gerarIdUnico() {\\n  return Date.now().toString(36) + Math.random().toString(36).substring(2);\\n}\\n\\n// Função para esperar um tempo determinado (útil para retry)\\nfunction esperar(ms) {\\n  return new Promise(resolve => setTimeout(resolve, ms));\\n}\\n\\n// Retry de uma função assíncrona\\nasync function retryAsync(funcao, tentativas = 3, intervalo = 1000) {\\n  let ultimoErro;\\n  \\n  for (let i = 0; i < tentativas; i++) {\\n    try {\\n      return await funcao();\\n    } catch (erro) {\\n      ultimoErro = erro;\\n      logger.warn(`Tentativa ${i + 1}/${tentativas} falhou: ${erro.message}`);\\n      \\n      if (i < tentativas - 1) {\\n        await esperar(intervalo);\\n      }\\n    }\\n  }\\n  \\n  throw ultimoErro;\\n}\\n\\nmodule.exports = {\\n  logger,\\n  criarDiretorios,\\n  caminhoExiste,\\n  formatarData,\\n  removerAcentos,\\n  limparString,\\n  escaparRegex,\\n  gerarIdUnico,\\n  esperar,\\n  retryAsync\\n};\"\n    },\n    {\n      \"path\": \"src\\\\whatsapp.js\",\n      \"name\": \"whatsapp.js\",\n      \"extension\": \".js\",\n      \"size\": 14929,\n      \"last_modified\": \"2025-04-03T13:54:43.525038\",\n      \"content\": \"// Módulo de conexão com WhatsApp usando Baileys (mais leve que Puppeteer)\\n\\nconst { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');\\nconst qrcode = require('qrcode-terminal');\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst { logger } = require('./utils');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst { obterContatos, adicionarNovoContatoNaPlanilha } = require('./leitorContatos');\\n\\n// Cliente WhatsApp\\nlet wa = null;\\nlet clienteInicializado = false;\\n\\n// Importar o gerenciador de conversas\\nconst conversasHandler = require('./conversasHandler');\\n\\n// Pasta para armazenar os dados de autenticação\\nconst AUTH_FOLDER = process.env.WHATSAPP_SESSION_PATH || './whatsapp-session';\\n\\n// Configuração de presença\\nconst TEMPO_ONLINE = 60000; // 1 minuto em milissegundos\\nlet timerPresenca = null;\\n\\n// Função para definir o status como offline\\nasync function definirOffline() {\\n  try {\\n    if (wa && clienteInicializado) {\\n      // Definir o status como 'unavailable' (que mostra o \\\"visto por último\\\")\\n      await wa.sendPresenceUpdate('unavailable', null);\\n      logger.info('Status definido como offline (visto por último)');\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao definir status offline: ${erro.message}`);\\n  }\\n}\\n\\n// Função para gerenciar o status online\\nasync function gerenciarPresenca() {\\n  // Limpar o timer existente, se houver\\n  if (timerPresenca) {\\n    clearTimeout(timerPresenca);\\n  }\\n  \\n  // Definir um novo timer para ficar offline após o tempo configurado\\n  timerPresenca = setTimeout(definirOffline, TEMPO_ONLINE);\\n}\\n\\n// Inicializar o cliente WhatsApp\\nasync function iniciarCliente() {\\n  try {\\n    logger.info('Inicializando cliente WhatsApp usando Baileys...');\\n    \\n    // Garantir que a pasta de autenticação existe\\n    if (!fs.existsSync(AUTH_FOLDER)) {\\n      fs.mkdirSync(AUTH_FOLDER, { recursive: true });\\n      logger.info(`Diretório de autenticação criado: ${AUTH_FOLDER}`);\\n    }\\n    \\n    // Carregar estado de autenticação (se existir)\\n    const { state, saveCreds } = await useMultiFileAuthState(AUTH_FOLDER);\\n    \\n    const nullLogger = {\\n      child: () => nullLogger,\\n      info: () => {},\\n      warn: () => {},\\n      error: () => {},\\n      debug: () => {},\\n      trace: () => {}\\n    };\\n\\n    // Criar o socket WhatsApp\\n    wa = makeWASocket({\\n      auth: state,\\n      printQRInTerminal: true,\\n      defaultQueryTimeoutMs: 60000, // Timeout mais longo para Raspberry Pi\\n      logger: nullLogger\\n    });\\n    \\n    // Manipular eventos de conexão e mensagens\\n    wa.ev.on('connection.update', async (update) => {\\n      const { connection, lastDisconnect, qr } = update;\\n      \\n      if (qr) {\\n        // Exibir QR code no terminal\\n        logger.info('QR Code gerado. Escaneie-o com seu WhatsApp:');\\n        qrcode.generate(qr, { small: true });\\n      }\\n      \\n      if (connection === 'close') {\\n        const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;\\n        logger.warn(`Conexão fechada devido a ${lastDisconnect.error}. ${shouldReconnect ? 'Reconectando...' : 'Não será reconectado.'}`);\\n        \\n        clienteInicializado = false;\\n        \\n        if (shouldReconnect) {\\n          // Tentar reconectar após um breve intervalo\\n          setTimeout(iniciarCliente, 5000);\\n        }\\n      } else if (connection === 'open') {\\n        logger.info('Cliente WhatsApp conectado com sucesso!');\\n        clienteInicializado = true;\\n        \\n        // Definir como online inicialmente\\n        await wa.sendPresenceUpdate('available', null);\\n        // Iniciar o timer para ficar offline\\n        gerenciarPresenca();\\n      }\\n    });\\n    \\n    // Salvar credenciais quando atualizadas\\n    wa.ev.on('creds.update', saveCreds);\\n    \\n    // Manipular mensagens recebidas\\n    wa.ev.on('messages.upsert', async (m) => {\\n      if (m.type === 'notify') {\\n        for (const msg of m.messages) {\\n          // Processar apenas mensagens de outros (não enviadas por nós)\\n          if (!msg.key.fromMe) {\\n            await processarMensagemRecebida(msg);\\n          }\\n        }\\n      }\\n    });\\n    \\n    logger.info('Sistema de eventos do WhatsApp inicializado');\\n    return wa;\\n  } catch (erro) {\\n    logger.error(`Erro ao inicializar cliente WhatsApp: ${erro.message}`);\\n    logger.error(erro.stack);\\n    throw erro;\\n  }\\n}\\n\\n// Processar mensagens recebidas\\nasync function processarMensagemRecebida(msg) {\\n  try {\\n    \\n    // Verificar se é uma mensagem de grupo\\n    if (msg.key.remoteJid.includes('@g.us')) {\\n      return; // Ignorar mensagens de grupos\\n    }\\n    \\n    // Obter informações do remetente\\n    const remetente = msg.key.remoteJid;\\n    const telefone = remetente.split('@')[0];\\n    \\n    // Verificar se não é uma mensagem muito antiga\\n    const timestampMensagem = msg.messageTimestamp * 1000;\\n    const agora = Date.now();\\n    const diffMinutos = (agora - timestampMensagem) / (1000 * 60);\\n    \\n    if (diffMinutos > 10) {\\n      logger.info(`Ignorando mensagem antiga (${Math.floor(diffMinutos)} minutos atrás)`);\\n      return;\\n    }\\n\\n    // Ao receber uma mensagem, definir como online\\n    await wa.sendPresenceUpdate('available', remetente);\\n    gerenciarPresenca(); // Iniciar o timer para ficar offline\\n\\n    // Carregar histórico de conversa\\n    const caminhoArquivo = path.join(process.env.CONVERSAS_DIR || './Conversas', `${telefone}.json`);\\n    let devocionalJaEnviado = false;\\n    \\n    if (fs.existsSync(caminhoArquivo)) {\\n      try {\\n        const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n        const historico = JSON.parse(conteudo);\\n        \\n        // Verificar se já enviamos um devocional\\n        devocionalJaEnviado = historico && historico.ultimoDevocional;\\n        \\n        logger.info(`Usuário ${telefone}: ${devocionalJaEnviado ? 'já recebeu devocional' : 'ainda não recebeu devocional'}`);\\n      } catch (erroLeitura) {\\n        logger.error(`Erro ao ler histórico para ${telefone}: ${erroLeitura.message}`);\\n      }\\n    } else {\\n      logger.info(`Nenhum histórico encontrado para ${telefone}, enviando devocional de boas-vindas`);\\n    }\\n\\n    if (!devocionalJaEnviado) {\\n      logger.info(`Primeira interação detectada para o número ${telefone}`);\\n    \\n      // Adicionar o novo contato à Planilha\\n      try {\\n        // Tenta extrair o nome do contato\\n        let nomeContato = \\\"Novo Contato\\\";\\n        \\n        // Tente pelo pushName que pode estar disponível na própria mensagem\\n        if (msg.pushName) {\\n          nomeContato = msg.pushName;\\n        }\\n        // Ou pelo objeto key da mensagem\\n        else if (msg.key && msg.key.pushName) {\\n          nomeContato = msg.key.pushName;\\n        }\\n        \\n        // Adicionar à Planilha\\n        await adicionarNovoContatoNaPlanilha(telefone, nomeContato);\\n        logger.info(`Contato ${telefone} (${nomeContato}) adicionado à planilha de contatos`);\\n      } catch (erroContato) {\\n        logger.error(`Erro ao adicionar contato à planilha: ${erroContato.message}`);\\n      }\\n      \\n      // Buscar o último devocional enviado hoje\\n      const devocionalHoje = await historicoMensagens.obterUltimoDevocionalEnviado();\\n      if (devocionalHoje) {\\n        \\n        // Enviar mensagem de boas-vindas\\n        await wa.sendMessage(remetente, { \\n          text: \\\"Olá 😀! Seja bem-vindo(a) ao Whatsapp Devocional-IA. Aqui está o devocional de hoje:\\\" \\n        });\\n        \\n        // Pequena pausa\\n        await new Promise(resolve => setTimeout(resolve, 1500));\\n        \\n        // Enviar o devocional\\n        await wa.sendMessage(remetente, { text: devocionalHoje });\\n        \\n        // Registrar o devocional enviado para este contato\\n        await conversasHandler.registrarDevocionalEnviado(telefone, devocionalHoje);\\n        logger.info(`Devocional do dia enviado para novo contato: ${telefone}`);\\n        return;\\n      } else {\\n        logger.warn(`Não foi possível encontrar um devocional para enviar ao novo contato ${telefone}`);\\n      }\\n    }\\n    \\n    // Verificar o tipo de mensagem\\n    const messageType = Object.keys(msg.message || {})[0];\\n    \\n    // Processar áudio\\n    if (['audioMessage', 'pttMessage'].includes(messageType)) {\\n      logger.info(`Áudio recebido de ${telefone}, respondendo com mensagem padrão`);\\n      \\n      // Mensagens gentis e educadas para responder a áudios\\n      const mensagensAudio = [\\n        \\\"Olá! Recebi seu áudio, mas ainda não consigo processá-lo. Você poderia, por gentileza, enviar sua pergunta ou comentário como mensagem de texto? Assim poderei lhe ajudar melhor. 🙏\\\",\\n        \\\"Agradeço pelo seu áudio! No momento, não disponho da capacidade de ouvi-lo. Poderia, por favor, compartilhar seu pensamento ou pergunta em forma de texto? Ficarei feliz em responder!\\\",\\n        \\\"Recebi sua mensagem de voz! Infelizmente, ainda não consigo compreender áudios. Se puder enviar o mesmo conteúdo em texto, será um prazer conversar sobre o devocional de hoje ou qualquer outro assunto espiritual.\\\"\\n      ];\\n      \\n      // Escolher uma mensagem aleatoriamente\\n      const respostaAudio = mensagensAudio[Math.floor(Math.random() * mensagensAudio.length)];\\n      \\n      // Indicar que está digitando (simulando digitação)\\n      await wa.sendPresenceUpdate('composing', remetente);\\n      \\n      // Pequena pausa para simular digitação (entre 1-3 segundos)\\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\\n      \\n      // Enviar a resposta\\n      await wa.sendMessage(remetente, { text: respostaAudio });\\n      logger.info(`Resposta para áudio enviada para ${telefone}`);\\n      \\n      // Reiniciar o timer de presença\\n      gerenciarPresenca();\\n      return;\\n    }\\n    \\n    // Extrair o conteúdo da mensagem de texto\\n    let conteudo = '';\\n    \\n    if (messageType === 'conversation') {\\n      conteudo = msg.message.conversation;\\n    } else if (messageType === 'extendedTextMessage') {\\n      conteudo = msg.message.extendedTextMessage.text;\\n    } else {\\n      // Outros tipos de mensagem (imagem, vídeo, etc.)\\n      conteudo = \\\"Mídia recebida\\\";\\n    }\\n    \\n    logger.info(`Mensagem recebida de ${telefone}: ${conteudo.substring(0, 50)}${conteudo.length > 50 ? '...' : ''}`);\\n    \\n    // Verificar se a mensagem precisa de resposta\\n    if (conversasHandler.ePergunta(conteudo) || conteudo.length >= 10) {\\n      logger.info(`Gerando resposta para mensagem de ${telefone}...`);\\n      \\n      // Indicar que está digitando (simulando digitação)\\n      await wa.sendPresenceUpdate('composing', remetente);\\n      \\n      // Gerar a resposta\\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\\n      \\n      // Calcular tempo de digitação baseado no tamanho da resposta\\n      // Média de digitação: cerca de 5 caracteres por segundo (ajuste conforme necessário)\\n      const tempoDigitacao = Math.min(Math.max(resposta.length / 5 * 1000, 2000), 8000);\\n      \\n      // Simular tempo de digitação\\n      await new Promise(resolve => setTimeout(resolve, tempoDigitacao));\\n      \\n      // Parar de \\\"digitar\\\"\\n      await wa.sendPresenceUpdate('paused', remetente);\\n      \\n      // Pequena pausa antes de enviar (como se estivesse revisando)\\n      await new Promise(resolve => setTimeout(resolve, 500));\\n      \\n      // Enviar a resposta\\n      await wa.sendMessage(remetente, { text: resposta });\\n      \\n      logger.info(`Resposta enviada para ${telefone}`);\\n    } else {\\n      logger.info(`Mensagem curta, enviando resposta simples`);\\n      \\n      // Indicar que está digitando\\n      await wa.sendPresenceUpdate('composing', remetente);\\n      \\n      // Para mensagens curtas ou agradecimentos, enviar uma resposta simples\\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\\n      \\n      // Simular digitação rápida (1-3 segundos)\\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\\n      \\n      // Enviar resposta\\n      await wa.sendMessage(remetente, { text: resposta });\\n    }\\n    \\n    // Reiniciar o timer de presença após enviar mensagem\\n    gerenciarPresenca();\\n  } catch (erro) {\\n    logger.error(`Erro ao processar mensagem recebida: ${erro.message}`);\\n    try {\\n      // Tentar enviar uma mensagem de erro para o usuário\\n      await wa.sendMessage(msg.key.remoteJid, { \\n        text: \\\"Desculpe, ocorreu um erro ao processar sua mensagem. Por favor, tente novamente mais tarde.\\\" \\n      });\\n    } catch (erroEnvio) {\\n      logger.error(`Erro ao enviar mensagem de erro: ${erroEnvio.message}`);\\n    }\\n  }\\n}\\n\\n// Verificar se o cliente está pronto\\nfunction clientePronto() {\\n  return wa !== null && clienteInicializado;\\n}\\n\\n// Enviar mensagem para um contato\\nasync function enviarMensagem(telefone, mensagem) {\\n  try {\\n    if (!clientePronto()) {\\n      throw new Error('Cliente WhatsApp não está pronto');\\n    }\\n    \\n    // Formatar o número de telefone (remover caracteres não numéricos)\\n    const numeroFormatado = telefone.toString().replace(/\\\\D/g, '');\\n    \\n    // Garantir que o número tenha o formato correto para o WhatsApp\\n    const chatId = `${numeroFormatado}@s.whatsapp.net`;\\n    \\n    // Definir como online ao enviar mensagem\\n    await wa.sendPresenceUpdate('available', chatId);\\n    \\n    // Enviar a mensagem\\n    await wa.sendMessage(chatId, { text: mensagem });\\n    \\n    // Iniciar o timer para ficar offline\\n    gerenciarPresenca();\\n    \\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao enviar mensagem: ${erro.message}`);\\n    throw erro;\\n  }\\n}\\n\\n// Encerrar o cliente\\nasync function encerrarCliente() {\\n  try {\\n    if (wa) {\\n      // Definir como offline antes de desconectar\\n      try {\\n        await definirOffline();\\n      } catch (erroPresenca) {\\n        logger.warn(`Erro ao definir offline antes de encerrar: ${erroPresenca.message}`);\\n      }\\n      \\n      // Limpar o timer de presença\\n      if (timerPresenca) {\\n        clearTimeout(timerPresenca);\\n        timerPresenca = null;\\n      }\\n      \\n      // Não há um método específico para \\\"destruir\\\" no Baileys,\\n      // mas podemos remover os listeners e limpar referências\\n      wa.ev.removeAllListeners();\\n      wa = null;\\n      clienteInicializado = false;\\n      logger.info('Cliente WhatsApp encerrado');\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao encerrar cliente WhatsApp: ${erro.message}`);\\n  }\\n}\\n\\nmodule.exports = {\\n  iniciarCliente,\\n  clientePronto,\\n  enviarMensagem,\\n  encerrarCliente,\\n};\"\n    }\n  ]\n}"
    },
    {
      "path": "package.json",
      "name": "package.json",
      "extension": ".json",
      "size": 906,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "{\n  \"name\": \"whatsapp-devocional-ia\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Bot de WhatsApp que envia mensagens devocionais diárias geradas por IA e responde a perguntas\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"start\": \"NODE_OPTIONS=\\\"--max-old-space-size=512\\\" node src/index.js\",\n    \"test:devocional\": \"node scripts/testar_devocional.js\",\n    \"test:conversas\": \"node scripts/testar_conversas.js\",\n    \"setup:contatos\": \"node scripts/criar_exemplo_contato.js\"\n  },\n  \"dependencies\": {\n    \"@google/generative-ai\": \"^0.1.1\",\n    \"@whiskeysockets/baileys\": \"^6.6.0\",\n    \"cheerio\": \"^1.0.0-rc.12\",\n    \"csv-parser\": \"^3.0.0\",\n    \"dotenv\": \"^16.0.3\",\n    \"fs-extra\": \"^11.1.0\",\n    \"jimp\": \"^0.16.13\",\n    \"moment\": \"^2.29.4\",\n    \"node-schedule\": \"^2.1.1\",\n    \"pdf-parse\": \"^1.1.1\",\n    \"qrcode-terminal\": \"^0.12.0\",\n    \"sharp\": \"^0.33.2\",\n    \"xlsx\": \"^0.18.5\"\n  }\n}"
    },
    {
      "path": "README.md",
      "name": "README.md",
      "extension": ".md",
      "size": 7771,
      "last_modified": "2025-04-03T13:54:43.498753",
      "content": "## Funcionalidade de Diálogo Interativo\n\nEsta versão do sistema inclui suporte para diálogo individualizado com os usuários:\n\n### Como funciona:\n\n1. **Envio do Devocional**: O sistema envia automaticamente o devocional diário para todos os contatos cadastrados no horário programado.\n\n2. **Recebimento de Mensagens**: Quando um usuário responde ou faz uma pergunta sobre o devocional, o sistema:\n   - Analisa se a mensagem requer uma resposta elaborada\n   - Usa a IA para gerar uma resposta personalizada considerando:\n     - O devocional enviado recentemente\n     - O histórico de conversa com aquele usuário específico\n     - A base de conhecimento religiosa\n\n3. **Contexto Individualizado**: O sistema mantém históricos de conversa separados para cada usuário, permitindo:\n   - Respostas personalizadas\n   - Referências a mensagens anteriores da mesma conversa\n   - Continuidade no diálogo\n\n### Configurações:\n\nNo arquivo `.env` você pode ajustar:\n\n- `RESPONDER_AUTOMATICAMENTE=true` - Ativar/desativar resposta automática\n- `MAX_HISTORICO_CONVERSAS=10` - Número de mensagens armazenadas por conversa\n\n### Limitações:\n\n- O sistema foi projetado para responder a perguntas relacionadas ao devocional\n- Mensagens curtas ou simples recebem respostas padrão mais breves\n- A IA foi instruída a manter um tom amigável, acolhedor e espiritual# WhatsApp Devocional Diário com IA\n\nUm bot de WhatsApp automatizado que envia mensagens devocionais diárias geradas por IA para uma lista de contatos pré-definida.\n\n## Testes e Exemplos\n\nO sistema inclui scripts de teste para verificar componentes individuais:\n\n### Testar geração de devocionais:\n\n```bash\nnode scripts/testar_devocional.js\n```\n\nEste script gera um devocional usando a API do Google Gemini e sua base de conhecimento, sem enviar mensagens para os contatos. O resultado é exibido no console e salvo no arquivo `scripts/devocional_gerado.txt`.\n\n### Criar arquivo de contatos de exemplo:\n\n```bash\nnode scripts/criar_exemplo_contatos.js\n```\n\nEste script cria um arquivo Excel com contatos de exemplo na pasta `Contatos/` que você pode usar como referência para o formato correto.\n\n### Testar sistema de conversas com IA:\n\n```bash\nnode scripts/testar_conversas.js\n```\n\nEste script simula uma conversa interativa entre um usuário e o bot, permitindo testar como o sistema responde a perguntas sobre o devocional enviado. Você pode digitar mensagens como se fosse um usuário e ver as respostas geradas pela IA. Características\n\n- 🤖 Integração com o Google Gemini para geração de conteúdo devocional\n- 📱 Envio automático de mensagens via WhatsApp\n- 💬 **Diálogo individualizado com usuários através de IA generativa**\n- 📊 Suporte para leitura de contatos de arquivos Excel e CSV\n- 📚 Base de conhecimento personalizável com suporte para diversos formatos de arquivo\n- 📅 Agendamento diário automático\n- 📝 Registro de histórico para evitar repetição de versículos\n- 🧩 Arquitetura modular para fácil manutenção e extensão\n\n## Requisitos\n\n- Node.js (v14 ou superior)\n- Acesso à API do Google Gemini (chave de API)\n- Um dispositivo ou servidor para executar o bot\n\n## Estrutura do Projeto\n\n```\n📁 WhatsApp-Devocional-IA/\n├── 📁 Base_de_conhecimento/     # Coloque aqui seus documentos de referência\n├── 📁 Contatos/                 # Coloque aqui suas planilhas de contatos\n├── 📁 Conversas/                # Armazena históricos de conversas individuais\n├── 📁 Histórico/                # Histórico de mensagens enviadas\n│   └── 📄 historico.json        # Registro automático dos envios\n├── 📁 src/                      # Código fonte do sistema\n│   ├── 📄 index.js              # Ponto de entrada da aplicação\n│   ├── 📄 whatsapp.js           # Módulo de conexão com WhatsApp\n│   ├── 📄 geradorDevocional.js  # Módulo gerador de devocionais com IA\n│   ├── 📄 leitorDocumentos.js   # Módulo para processamento dos documentos base\n│   ├── 📄 leitorContatos.js     # Módulo para leitura da lista de contatos\n│   ├── 📄 historicoMensagens.js # Módulo para gerenciamento do histórico\n│   ├── 📄 conversasHandler.js   # Módulo para diálogo individualizado com IA\n│   └── 📄 utils.js              # Funções utilitárias\n├── 📁 scripts/                  # Scripts de teste e utilitários\n├── 📄 package.json              # Dependências do projeto\n├── 📄 .env                      # Configurações do projeto\n└── 📄 README.md                 # Esta documentação\n```\n\n## Configuração\n\n1. Clone este repositório\n2. Execute `npm install` para instalar as dependências\n3. Copie o arquivo `.env.example` para `.env` e configure:\n   - Chave de API do Google Gemini\n   - Horário de envio das mensagens\n   - Outras configurações conforme necessário\n4. Adicione seus documentos de referência à pasta `Base_de_conhecimento`\n5. Adicione sua lista de contatos à pasta `Contatos` (em formato Excel ou CSV)\n\n### Formato da Planilha de Contatos\n\nA planilha deve conter pelo menos as seguintes colunas:\n- `Nome`: Nome do contato\n- `Telefone`: Número de telefone com código do país (ex: 5511987654321)\n- `Ativo`: Opcional, para indicar se o contato deve receber mensagens (Sim/Não)\n\n## Uso\n\nPara iniciar o bot:\n\n```bash\nnpm start\n```\n\nNa primeira execução, será exibido um QR Code que deve ser escaneado com o WhatsApp do seu celular para autenticar a sessão.\n\n##\n\n## Base de Conhecimento\n\nA pasta `Base_de_conhecimento` aceita os seguintes formatos de arquivo:\n- PDF (.pdf)\n- Texto simples (.txt)\n- JSON (.json)\n- Excel (.xlsx)\n- CSV (.csv)\n\nEstes documentos serão utilizados como referência para a IA gerar os devocionais diários.\n\n## Personalização\n\nPara personalizar o formato dos devocionais, edite o arquivo `src/geradorDevocional.js`.\n\n## Manutenção\n\nO sistema mantém um histórico de mensagens enviadas para evitar repetição de versículos. Este histórico é armazenado em `Histórico/historico.json`.\n\n## Solução de Problemas\n\n### Cliente do WhatsApp não conecta\n- Verifique se não há outra sessão do WhatsApp Web ativa\n- Apague a pasta `whatsapp-session` e reinicie o sistema\n- Certifique-se de escanear o QR code quando solicitado\n\n### Erros na geração do devocional\n- Verifique se a chave de API do Google Gemini está correta no arquivo `.env`\n- Certifique-se de usar o nome correto do modelo na API (gemini-1.5-pro ou gemini-pro)\n- Verifique se há documentos válidos na pasta `Base_de_conhecimento`\n- Execute o script de teste `scripts/testar_devocional.js` para verificar se a geração funciona\n\n### Problemas com contatos\n- Verifique se o arquivo de contatos está no formato correto (Excel ou CSV)\n- Certifique-se de que os contatos tenham pelo menos uma coluna chamada \"Nome\" e outra \"Telefone\"\n- Confirme que os números de telefone estão completos com código do país (ex: 5511987654321)\n- Use o arquivo de exemplo `contatos_exemplo.xlsx` como referência\n- Para diagnóstico, verifique os logs detalhados que mostram como os contatos estão sendo processados\n\n### Erros no histórico de mensagens\n- Se ocorrerem erros relacionados ao histórico, verifique se o arquivo `historico.json` existe e tem o formato correto\n- Em caso de problemas persistentes, exclua o arquivo `Histórico/historico.json` e deixe o sistema recriá-lo automaticamente\n\n## Licença\n\nEste projeto está licenciado sob a Licença MIT - veja o arquivo LICENSE para detalhes."
    },
    {
      "path": "Histórico\\historico.json",
      "name": "historico.json",
      "extension": ".json",
      "size": 270,
      "last_modified": "2025-04-03T13:54:43.498753",
      "content": "[\n  {\n    \"date\": \"1 de abril de 2025\",\n    \"verse\": \"\\\"Confie no Senhor de todo o seu coração.\\\" (Provérbios 3:5)\"\n  },\n  {\n    \"date\": \"1 de abril de 2025\",\n    \"verse\": \"\\\"Alegrem-se na esperança, sejam pacientes na tribulação.\\\" (Romanos 12:12)\"\n  }\n]"
    },
    {
      "path": "scripts\\criar_exemplo_contato.js",
      "name": "criar_exemplo_contato.js",
      "extension": ".js",
      "size": 1594,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// Script para criar um arquivo de exemplo de contatos\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\n\n// Diretório e arquivo\nconst CONTATOS_DIR = '../Contatos';\nconst ARQUIVO_EXEMPLO = path.join(CONTATOS_DIR, 'contatos_exemplo.xlsx');\n\n// Garantir que o diretório exista\nif (!fs.existsSync(CONTATOS_DIR)) {\n  fs.mkdirSync(CONTATOS_DIR, { recursive: true });\n  console.log(`Diretório criado: ${CONTATOS_DIR}`);\n}\n\n// Dados de exemplo\nconst contatos = [\n  { \n    Nome: 'João Silva', \n    Telefone: '5511987654321', \n    Ativo: 'Sim',\n    Observacoes: 'Contato principal'\n  },\n  { \n    Nome: 'Maria Oliveira', \n    Telefone: '5521998765432', \n    Ativo: 'Sim',\n    Observacoes: 'Contato secundário'\n  },\n  { \n    Nome: 'Pedro Santos', \n    Telefone: '5531987654321', \n    Ativo: 'Não',\n    Observacoes: 'Desativado temporariamente'\n  },\n  { \n    Nome: 'Ana Costa', \n    Telefone: '5541999887766', \n    Ativo: 'Sim',\n    Observacoes: 'Novo contato'\n  },\n  { \n    Nome: 'Carlos Pereira', \n    Telefone: '5551988776655', \n    Ativo: 'Sim',\n    Observacoes: ''\n  }\n];\n\n// Criar workbook e adicionar dados\nconst workbook = xlsx.utils.book_new();\nconst worksheet = xlsx.utils.json_to_sheet(contatos);\n\n// Adicionar a planilha ao workbook\nxlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\n\n// Salvar o arquivo\nxlsx.writeFile(workbook, ARQUIVO_EXEMPLO);\n\nconsole.log(`Arquivo de exemplo criado: ${ARQUIVO_EXEMPLO}`);\nconsole.log('Modelo de contatos:');\nconsole.table(contatos);"
    },
    {
      "path": "scripts\\testar_devocional.js",
      "name": "testar_devocional.js",
      "extension": ".js",
      "size": 3225,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// Script para testar o sistema de conversas individualizadas com IA\n\nrequire('dotenv').config({ path: '../.env' });\nconst moment = require('moment');\nmoment.locale('pt-br');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst readline = require('readline');\n\n// Configurar o ambiente para execução independente\nprocess.env.BASE_CONHECIMENTO_DIR = path.resolve(__dirname, '../Base_de_conhecimento');\nprocess.env.CONVERSAS_DIR = path.resolve(__dirname, '../Conversas');\n\n// Importar módulos\nconst conversasHandler = require('../src/conversasHandler');\nconst { formatarData, logger } = require('../src/utils');\n\n// Configurar interface de linha de comando\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// Telefone de teste\nconst TELEFONE_TESTE = '5511999999999';\n\n// Devocional de exemplo para contextualizar a conversa\nconst devocionalExemplo = `${formatarData(new Date())}\n\nVersículo: \"Não andeis ansiosos por coisa alguma; antes em tudo sejam os vossos pedidos conhecidos diante de Deus pela oração e súplica com ações de graças. E a paz de Deus, que excede todo entendimento, guardará os vossos corações e as vossas mentes em Cristo Jesus.\" (Filipenses 4:6-7)\n\nReflexão: A ansiedade tem sido um desafio comum em nossos dias. Este versículo nos lembra que podemos trazer todas as nossas preocupações a Deus através da oração. Quando escolhemos confiar nEle ao invés de nos sobrecarregarmos com preocupações, experimentamos uma paz que vai além da compreensão humana. É uma promessa poderosa para nossos momentos de inquietação.\n\nPrática: Hoje, quando sentir ansiedade surgindo, faça uma pausa para respirar e apresente a situação a Deus em oração, agradecendo antecipadamente por Sua intervenção.`;\n\n// Função para inicializar a conversa\nasync function iniciarConversa() {\n  console.log('=== TESTE DO SISTEMA DE CONVERSAS ===\\n');\n  console.log('Simulando uma conversa individualizada com o bot\\n');\n  \n  // Registrar o devocional de exemplo\n  await conversasHandler.registrarDevocionalEnviado(TELEFONE_TESTE, devocionalExemplo);\n  \n  console.log('Devocional enviado hoje:');\n  console.log(devocionalExemplo);\n  console.log('\\n-------------------------------------------\\n');\n  console.log('Digite suas mensagens como se fosse um usuário respondendo ao devocional.');\n  console.log('Digite \"sair\" para encerrar o teste.\\n');\n  \n  perguntarUsuario();\n}\n\n// Função para processar a entrada do usuário\nfunction perguntarUsuario() {\n  rl.question('Você: ', async (mensagem) => {\n    if (mensagem.toLowerCase() === 'sair') {\n      console.log('\\nEncerrando teste...');\n      rl.close();\n      return;\n    }\n    \n    console.log('\\nProcessando mensagem...');\n    \n    try {\n      // Gerar resposta do bot\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(TELEFONE_TESTE, mensagem);\n      \n      console.log(`\\nBot: ${resposta}\\n`);\n    } catch (erro) {\n      console.error('Erro ao gerar resposta:', erro.message);\n    }\n    \n    // Continuar a conversa\n    perguntarUsuario();\n  });\n}\n\n// Iniciar o teste\niniciarConversa();"
    },
    {
      "path": "src\\adicionarContato.js",
      "name": "adicionarContato.js",
      "extension": ".js",
      "size": 8492,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// Módulo para adicionar novos contatos à planilha\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\nconst csvParser = require('csv-parser');\nconst { logger } = require('./utils');\n\n// Diretório de contatos\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\n\n// Obter a lista de arquivos de contatos disponíveis\nfunction obterArquivosContatos() {\n  try {\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\n    return arquivos.filter(arquivo => {\n      const extensao = path.extname(arquivo).toLowerCase();\n      return extensao === '.xlsx' || extensao === '.csv';\n    });\n  } catch (erro) {\n    logger.error(`Erro ao ler diretório de contatos: ${erro.message}`);\n    return [];\n  }\n}\n\n// Adicionar novo contato à planilha\nasync function adicionarNovoContatoNaPlanilha(telefone, nomeContato = \"Novo Contato\") {\n  try {\n    const arquivos = obterArquivosContatos();\n    \n    if (arquivos.length === 0) {\n      logger.warn('Nenhum arquivo de contatos encontrado. Criando novo arquivo.');\n      return criarNovoArquivoContatos(telefone, nomeContato);\n    }\n    \n    // Usar o primeiro arquivo encontrado (normalmente contatos_exemplo.xlsx)\n    const arquivoContatos = path.join(CONTATOS_DIR, arquivos[0]);\n    const extensao = path.extname(arquivoContatos).toLowerCase();\n    \n    // Verificar se é Excel ou CSV\n    if (extensao === '.xlsx') {\n      return adicionarContatoExcel(arquivoContatos, telefone, nomeContato);\n    } else if (extensao === '.csv') {\n      return adicionarContatoCsv(arquivoContatos, telefone, nomeContato);\n    } else {\n      logger.error(`Formato de arquivo não suportado: ${extensao}`);\n      return false;\n    }\n  } catch (erro) {\n    logger.error(`Erro ao adicionar novo contato ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Adicionar contato a um arquivo Excel\nasync function adicionarContatoExcel(caminhoArquivo, telefone, nomeContato) {\n  try {\n    logger.info(`Adicionando contato ${telefone} ao arquivo Excel: ${caminhoArquivo}`);\n    \n    // Formatar o telefone conforme o padrão\n    const telefoneFormatado = formatarTelefone(telefone);\n    \n    // Ler o arquivo Excel existente\n    const workbook = xlsx.readFile(caminhoArquivo, {\n      cellDates: true,\n      cellNF: true,\n      cellText: true\n    });\n    \n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\n      logger.error('Arquivo Excel sem planilhas');\n      return false;\n    }\n    \n    // Usar a primeira planilha\n    const sheetName = workbook.SheetNames[0];\n    const worksheet = workbook.Sheets[sheetName];\n    \n    // Converter para JSON para manipulação\n    const dados = xlsx.utils.sheet_to_json(worksheet, {\n      defval: '',\n      raw: false\n    });\n    \n    // Verificar se o contato já existe\n    const contatoExistente = dados.find(contato => {\n      // Normalizar números de telefone para comparação\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\D/g, '');\n      const telefoneNovo = telefoneFormatado.replace(/\\D/g, '');\n      \n      return telefoneExistente === telefoneNovo || \n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \n             `55${telefoneExistente}` === telefoneNovo;\n    });\n    \n    if (contatoExistente) {\n      logger.info(`Contato ${telefone} já existe na planilha.`);\n      return false;\n    }\n    \n    // Adicionar o novo contato\n    const novoContato = {\n      Nome: nomeContato,\n      Telefone: telefoneFormatado,\n      Ativo: 'Sim',\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\n    };\n    \n    dados.push(novoContato);\n    \n    // Converter de volta para planilha\n    const novaWorksheet = xlsx.utils.json_to_sheet(dados);\n    workbook.Sheets[sheetName] = novaWorksheet;\n    \n    // Salvar o arquivo atualizado\n    xlsx.writeFile(workbook, caminhoArquivo);\n    \n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado à planilha com sucesso.`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao adicionar contato no Excel: ${erro.message}`);\n    return false;\n  }\n}\n\n// Adicionar contato a um arquivo CSV\nasync function adicionarContatoCsv(caminhoArquivo, telefone, nomeContato) {\n  try {\n    logger.info(`Adicionando contato ${telefone} ao arquivo CSV: ${caminhoArquivo}`);\n    \n    // Formatar o telefone conforme o padrão\n    const telefoneFormatado = formatarTelefone(telefone);\n    \n    // Ler o arquivo CSV existente\n    const contatos = await new Promise((resolve, reject) => {\n      const linhas = [];\n      \n      fs.createReadStream(caminhoArquivo)\n        .pipe(csvParser())\n        .on('data', (row) => {\n          linhas.push(row);\n        })\n        .on('end', () => {\n          resolve(linhas);\n        })\n        .on('error', (erro) => {\n          reject(erro);\n        });\n    });\n    \n    // Verificar se o contato já existe\n    const contatoExistente = contatos.find(contato => {\n      // Normalizar números de telefone para comparação\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\D/g, '');\n      const telefoneNovo = telefoneFormatado.replace(/\\D/g, '');\n      \n      return telefoneExistente === telefoneNovo || \n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \n             `55${telefoneExistente}` === telefoneNovo;\n    });\n    \n    if (contatoExistente) {\n      logger.info(`Contato ${telefone} já existe no arquivo CSV.`);\n      return false;\n    }\n    \n    // Adicionar o novo contato\n    const novoContato = {\n      Nome: nomeContato,\n      Telefone: telefoneFormatado,\n      Ativo: 'Sim',\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\n    };\n    \n    contatos.push(novoContato);\n    \n    // Obter os cabeçalhos\n    const cabecalhos = Object.keys(contatos[0]);\n    \n    // Criar o conteúdo CSV\n    const csvContent = [\n      cabecalhos.join(','),\n      ...contatos.map(contato => \n        cabecalhos.map(cabecalho => \n          `\"${String(contato[cabecalho] || '').replace(/\"/g, '\"\"')}\"`\n        ).join(',')\n      )\n    ].join('\\n');\n    \n    // Salvar o arquivo atualizado\n    fs.writeFileSync(caminhoArquivo, csvContent, 'utf8');\n    \n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado ao CSV com sucesso.`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao adicionar contato no CSV: ${erro.message}`);\n    return false;\n  }\n}\n\n// Criar novo arquivo de contatos se não existir nenhum\nfunction criarNovoArquivoContatos(telefone, nomeContato) {\n  try {\n    logger.info('Criando novo arquivo de contatos...');\n    \n    // Garantir que o diretório existe\n    if (!fs.existsSync(CONTATOS_DIR)) {\n      fs.mkdirSync(CONTATOS_DIR, { recursive: true });\n    }\n    \n    // Formatar o telefone conforme o padrão\n    const telefoneFormatado = formatarTelefone(telefone);\n    \n    // Criar dados iniciais\n    const contatos = [\n      {\n        Nome: nomeContato,\n        Telefone: telefoneFormatado,\n        Ativo: 'Sim',\n        Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\n      }\n    ];\n    \n    // Criar arquivo Excel\n    const caminhoArquivo = path.join(CONTATOS_DIR, 'contatos.xlsx');\n    const workbook = xlsx.utils.book_new();\n    const worksheet = xlsx.utils.json_to_sheet(contatos);\n    \n    xlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\n    xlsx.writeFile(workbook, caminhoArquivo);\n    \n    logger.info(`Novo arquivo de contatos criado com o contato ${telefoneFormatado}`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao criar novo arquivo de contatos: ${erro.message}`);\n    return false;\n  }\n}\n\n// Função auxiliar para formatar número de telefone\nfunction formatarTelefone(telefone) {\n  // Remover caracteres não numéricos\n  let telefoneFormatado = String(telefone).replace(/\\D/g, '');\n  \n  // Adicionar código do país (55) se não estiver presente e for um número brasileiro\n  if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\n    telefoneFormatado = `55${telefoneFormatado}`;\n  }\n  \n  return telefoneFormatado;\n}\n\nmodule.exports = {\n  adicionarNovoContatoNaPlanilha\n};"
    },
    {
      "path": "src\\conversasHandler.js",
      "name": "conversasHandler.js",
      "extension": ".js",
      "size": 11390,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// Módulo para gerenciar conversas individuais com os usuários\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\nconst leitorDocumentos = require('./leitorDocumentos');\nconst historicoMensagens = require('./historicoMensagens');\nconst { logger, removerAcentos, limparString } = require('./utils');\n\n// Configurações\nconst CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\nconst MAX_HISTORICO_CONVERSAS = parseInt(process.env.MAX_HISTORICO_CONVERSAS || '10', 10);\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\n\n// Inicializar cliente Gemini\nlet genAI;\nlet geminiModel;\n\n// Função para inicializar a API do Gemini\nfunction inicializarGeminiAPI() {\n  try {\n    if (!GEMINI_API_KEY) {\n      logger.error('Chave da API do Gemini não configurada no arquivo .env');\n      return false;\n    }\n    \n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\n    \n    // Tentar usar o modelo mais avançado primeiro\n    try {\n      geminiModel = genAI.getGenerativeModel({ model: \"gemini-1.5-pro\" });\n      logger.info('API do Google Gemini (gemini-1.5-pro) inicializada com sucesso');\n    } catch (erro) {\n      logger.warn(`Erro ao inicializar modelo gemini-1.5-pro: ${erro.message}`);\n      // Fallback para outro modelo\n      geminiModel = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n      logger.info('API do Google Gemini (gemini-pro) inicializada com sucesso');\n    }\n    \n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\n    return false;\n  }\n}\n\n// Inicializar a API\ninicializarGeminiAPI();\n\n// Garantir que o diretório de conversas exista\nfunction garantirDiretorioConversas() {\n  if (!fs.existsSync(CONVERSAS_DIR)) {\n    fs.mkdirSync(CONVERSAS_DIR, { recursive: true });\n    logger.info(`Diretório de conversas criado: ${CONVERSAS_DIR}`);\n  }\n}\n\n// Obter o caminho do arquivo de histórico para um telefone específico\nfunction obterCaminhoHistoricoConversa(telefone) {\n  garantirDiretorioConversas();\n  const nomeArquivo = `${telefone}.json`;\n  return path.join(CONVERSAS_DIR, nomeArquivo);\n}\n\n// Carregar histórico de conversa de um usuário\nfunction carregarHistoricoConversa(telefone) {\n  try {\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\n    \n    if (fs.existsSync(caminhoArquivo)) {\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n      return JSON.parse(conteudo);\n    }\n    \n    // Retornar histórico vazio se não existir\n    return {\n      telefone: telefone,\n      ultimaAtualizacao: new Date().toISOString(),\n      ultimoDevocional: null,\n      conversas: []\n    };\n  } catch (erro) {\n    logger.error(`Erro ao carregar histórico de conversa para ${telefone}: ${erro.message}`);\n    return {\n      telefone: telefone,\n      ultimaAtualizacao: new Date().toISOString(),\n      ultimoDevocional: null,\n      conversas: []\n    };\n  }\n}\n\n// Salvar histórico de conversa de um usuário\nfunction salvarHistoricoConversa(historico) {\n  try {\n    garantirDiretorioConversas();\n    \n    // Atualizar a data da última atualização\n    historico.ultimaAtualizacao = new Date().toISOString();\n    \n    // Limitar o número de mensagens no histórico\n    if (historico.conversas.length > MAX_HISTORICO_CONVERSAS) {\n      historico.conversas = historico.conversas.slice(-MAX_HISTORICO_CONVERSAS);\n    }\n    \n    const caminhoArquivo = obterCaminhoHistoricoConversa(historico.telefone);\n    fs.writeFileSync(caminhoArquivo, JSON.stringify(historico, null, 2));\n    \n    logger.info(`Histórico de conversa salvo para ${historico.telefone}`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao salvar histórico de conversa para ${historico.telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Registrar um devocional enviado para um usuário\nfunction registrarDevocionalEnviado(telefone, devocional) {\n  try {\n    const historico = carregarHistoricoConversa(telefone);\n    \n    // Registrar o devocional atual\n    historico.ultimoDevocional = {\n      data: new Date().toISOString(),\n      conteudo: devocional\n    };\n    \n    return salvarHistoricoConversa(historico);\n  } catch (erro) {\n    logger.error(`Erro ao registrar devocional para ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Registrar uma mensagem na conversa\nfunction registrarMensagem(telefone, remetente, mensagem) {\n  try {\n    const historico = carregarHistoricoConversa(telefone);\n    \n    // Adicionar a mensagem ao histórico\n    historico.conversas.push({\n      timestamp: new Date().toISOString(),\n      remetente: remetente, // 'usuario' ou 'bot'\n      mensagem: mensagem\n    });\n    \n    return salvarHistoricoConversa(historico);\n  } catch (erro) {\n    logger.error(`Erro ao registrar mensagem para ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Verificar se uma mensagem parece ser uma pergunta\nfunction ePergunta(mensagem) {\n  // Remover acentos e converter para minúsculas\n  const textoNormalizado = removerAcentos(mensagem.toLowerCase());\n  \n  // Verificar se termina com ponto de interrogação\n  if (textoNormalizado.includes('?')) {\n    return true;\n  }\n  \n  // Verificar palavras-chave de perguntas\n  const palavrasChavePergunta = [\n    'quem', 'como', 'por que', 'porque', 'quando', 'onde', 'qual', 'quais',\n    'o que', 'oq', 'pq', 'me explica', 'pode explicar', 'explique', 'significa',\n    'entendi', 'não entendi', 'nao entendi', 'duvida', 'dúvida'\n  ];\n  \n  return palavrasChavePergunta.some(palavra => textoNormalizado.includes(palavra));\n}\n\n// Verificar se é a primeira interação de um usuário\nasync function isPrimeiraInteracao(telefone) {\n  try {\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\n    \n    // Verificar se o arquivo de histórico existe\n    const existeHistorico = fs.existsSync(caminhoArquivo);\n    \n    // Se o arquivo não existir, é a primeira interação\n    if (!existeHistorico) {\n      logger.info(`Arquivo de histórico não encontrado para ${telefone}, é a primeira interação`);\n      return true;\n    }\n    \n    // Se o arquivo existir, verificar se tem conteúdo válido\n    try {\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n      const historico = JSON.parse(conteudo);\n      \n      // Verificar se o histórico tem conversas\n      if (!historico.conversas || historico.conversas.length === 0) {\n        logger.info(`Histórico vazio para ${telefone}, considerando como primeira interação`);\n        return true;\n      }\n      \n      // Se chegou aqui, não é a primeira interação\n      logger.info(`Usuário ${telefone} já tem histórico com ${historico.conversas.length} mensagens`);\n      return false;\n    } catch (erroLeitura) {\n      logger.error(`Erro ao ler histórico para ${telefone}: ${erroLeitura.message}`);\n      // Em caso de erro de leitura, considerar como primeira interação para garantir\n      return true;\n    }\n  } catch (erro) {\n    logger.error(`Erro ao verificar primeira interação para ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Preparar o prompt para a resposta da IA\nasync function prepararPromptResposta(telefone, mensagemUsuario) {\n  const historico = carregarHistoricoConversa(telefone);\n  const ultimoDevocional = historico.ultimoDevocional ? historico.ultimoDevocional.conteudo : '';\n  \n  // Obter últimas conversas para contexto (limitado às 5 últimas)\n  const conversasRecentes = historico.conversas.slice(-5);\n  const conversasFormatadas = conversasRecentes.map(c => \n    `${c.remetente === 'usuario' ? 'Pessoa' : 'Bot'}: ${c.mensagem}`\n  ).join('\\n');\n  \n  // Obter conteúdo da base de conhecimento\n  const baseConhecimento = await leitorDocumentos.obterConteudoBase();\n  \n  const prompt = `\n  Você é um assistente espiritual que está respondendo perguntas sobre um devocional diário que você enviou para uma pessoa via WhatsApp.\n  \n  Seu último devocional enviado foi:\n  ${ultimoDevocional}\n  \n  O contexto da conversa recente é:\n  ${conversasFormatadas}\n  \n  A pessoa acabou de enviar esta mensagem para você:\n  \"${mensagemUsuario}\"\n  \n  Baseie-se no devocional enviado e na seguinte base de conhecimento religiosa para responder:\n  ${baseConhecimento.substring(0, 10000)}\n  \n  Responda à pergunta ou comentário da pessoa de forma amigável, acolhedora e espiritual. \n  Mantenha a resposta concisa (até 5 frases), mas esclarecedora e relevante para a mensagem da pessoa.\n  Se for uma pergunta sobre o devocional, dê uma resposta específica baseada no versículo e na reflexão.\n  Se não for uma pergunta relacionada ao devocional, responda de forma generalista e gentil, evitando debates teológicos complexos.\n  \n  Não mencione que você é uma IA ou um bot. Responda como um aconselhador espiritual amigável.\n  `;\n  \n  return prompt.trim();\n}\n\n// Gerar resposta para uma mensagem do usuário\nasync function gerarRespostaParaMensagem(telefone, mensagemUsuario) {\n  try {\n    // Verificar se a API Gemini está inicializada\n    if (!geminiModel) {\n      const inicializou = inicializarGeminiAPI();\n      if (!inicializou) {\n        return \"Não foi possível responder no momento. Por favor, tente novamente mais tarde.\";\n      }\n    }\n    \n    // Registrar a mensagem do usuário\n    registrarMensagem(telefone, 'usuario', mensagemUsuario);\n    \n    // Verificar se a mensagem é uma pergunta ou comentário que precisa de resposta\n    if (!ePergunta(mensagemUsuario) && mensagemUsuario.length < 10) {\n      const respostasSimples = [\n        \"Amém! Tenha um dia abençoado.\",\n        \"Que Deus te abençoe hoje e sempre.\",\n        \"Obrigado por compartilhar. Fique na paz de Cristo.\",\n        \"Louvado seja Deus! Tenha um excelente dia.\",\n        \"Que a graça de Deus esteja com você hoje.\"\n      ];\n      \n      const resposta = respostasSimples[Math.floor(Math.random() * respostasSimples.length)];\n      registrarMensagem(telefone, 'bot', resposta);\n      return resposta;\n    }\n    \n    // Preparar o prompt\n    const prompt = await prepararPromptResposta(telefone, mensagemUsuario);\n    \n    // Gerar resposta com a IA\n    const result = await geminiModel.generateContent({\n      contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n      generationConfig: {\n        temperature: 0.7,\n        topK: 40,\n        topP: 0.95,\n        maxOutputTokens: 1024,\n      },\n    });\n    \n    const resposta = result.response.text().trim();\n    \n    // Registrar a resposta do bot\n    registrarMensagem(telefone, 'bot', resposta);\n    \n    return resposta;\n  } catch (erro) {\n    logger.error(`Erro ao gerar resposta para ${telefone}: ${erro.message}`);\n    \n    // Resposta de fallback em caso de erro\n    const respostaFallback = \"Agradeço sua mensagem. Estou refletindo sobre isso e logo poderei responder com mais clareza. Que Deus abençoe seu dia.\";\n    registrarMensagem(telefone, 'bot', respostaFallback);\n    \n    return respostaFallback;\n  }\n}\n\nmodule.exports = {\n  registrarDevocionalEnviado,\n  gerarRespostaParaMensagem,\n  ePergunta,\n  isPrimeiraInteracao\n};"
    },
    {
      "path": "src\\geradorDevocional.js",
      "name": "geradorDevocional.js",
      "extension": ".js",
      "size": 10685,
      "last_modified": "2025-04-03T15:18:23.726040",
      "content": "// Módulo gerador de devocionais com IA (Google Gemini)\n\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\nconst leitorDocumentos = require('./leitorDocumentos');\nconst historicoMensagens = require('./historicoMensagens');\nconst { logger } = require('./utils');\n\n// Configuração da API do Gemini\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\n\n// Inicializar o cliente Gemini\nlet genAI;\nlet geminiModel;\n\n// Função para inicializar a API do Gemini\nfunction inicializarGeminiAPI() {\n  try {\n    if (!GEMINI_API_KEY) {\n      logger.error('Chave da API do Gemini não configurada no arquivo .env');\n      return false;\n    }\n    \n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\n    \n    // Corrigindo para usar o nome do modelo correto\n    // Verificar qual modelo está disponível (gemini-pro ou gemini-1.5-pro)\n    geminiModel = genAI.getGenerativeModel({ model: \"gemini-2.0-flash\" });\n    \n    logger.info('API do Google Gemini inicializada com sucesso');\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\n    return false;\n  }\n}\n\n// Tentar inicializar a API\ninicializarGeminiAPI();\n\n// Gerar um prompt para o Gemini\nasync function gerarPrompt(dataAtual) {\n  try {\n    // Obter conteúdo da base de conhecimento\n    const baseConhecimento = await leitorDocumentos.obterConteudoBase();\n    \n    // Obter versículos recentes (para evitar repetições)\n    const versiculosRecentes = historicoMensagens.obterVersiculosRecentes(10); // Aumentei para 10 dias\n    const versiculosRecentesTexto = versiculosRecentes\n      .map(v => {\n        if (!v || !v.referencia || !v.texto) return '';\n        return `${v.referencia}: \"${v.texto}\"`;\n      })\n      .filter(v => v) // Remove entradas vazias\n      .join('\\n');\n    \n    // Adicionar log para debug\n    logger.info(`Versículos a serem evitados: ${versiculosRecentesTexto || \"Nenhum\"}`);\n    \n    // Construir o prompt\n    const prompt = `\n      Você é um bot de WhatsApp com inteligência artificial projetado para enviar um devocional diário todas as manhãs.\n      \n      Seu objetivo é criar uma mensagem devocional que contenha:\n      1. A data atual (${dataAtual})\n      2. Um versículo bíblico relevante\n      3. Um texto explicativo sobre o versículo (3-5 frases)\n      4. Uma sugestão prática para o dia (1-2 frases)\n      \n      MUITO IMPORTANTE: Você deve gerar um devocional com um versículo diferente a cada dia. Nunca repita versículos que já foram usados recentemente.\n      \n      Baseie-se no seguinte conteúdo para selecionar o versículo e elaborar a reflexão:\n      \n      ${baseConhecimento.substring(0, 15000)} \n      \n      Evite usar ABSOLUTAMENTE os seguintes versículos que foram utilizados recentemente:\n      ${versiculosRecentesTexto || \"Nenhum versículo recente a evitar.\"}\n      \n      O tom deve ser amigável, acolhedor e espiritual.\n      \n      Exemplo do formato esperado:\n      \n      \"📅 ${dataAtual}\n      \n      📖 *Versículo:* \\\"Tudo o que fizerem, façam de todo o coração, como para o Senhor.\\\" (Colossenses 3:23)\n      \n      💭 *Reflexão:* Este versículo nos lembra que nossas ações diárias, por menores que sejam, ganham significado quando as dedicamos a Deus. Trabalhar, ajudar alguém ou até descansar pode ser uma forma de honrá-Lo se fizermos com amor e propósito. Que tal começar o dia com essa intenção no coração?\n      \n      🧗🏼 *Prática:* Hoje, escolha uma tarefa simples e a realize com dedicação, pensando em como ela pode refletir seu cuidado com os outros e com Deus.\\\"\n      \n      Gere o devocional seguindo exatamente esse formato. induza o usuário a continuar a conversa.\n    `;\n    \n    return prompt.trim();\n  } catch (erro) {\n    logger.error(`Erro ao gerar prompt: ${erro.message}`);\n    throw erro;\n  }\n}\n\n// Modifique a função gerarDevocional para incluir a validação\nasync function gerarDevocional(dataAtual) {\n  try {\n    // Verificar se a API foi inicializada corretamente\n    if (!geminiModel) {\n      logger.warn('API do Gemini não inicializada. Tentando inicializar novamente...');\n      \n      // Tentar inicializar novamente\n      const inicializou = inicializarGeminiAPI();\n      \n      if (!inicializou || !geminiModel) {\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\n      }\n    }\n    \n    // Contador de tentativas para evitar loop infinito\n    let tentativas = 0;\n    const maxTentativas = 3;\n    let devocionalValido = false;\n    let devocional = '';\n    \n    while (!devocionalValido && tentativas < maxTentativas) {\n      tentativas++;\n      logger.info(`Gerando devocional - tentativa ${tentativas}/${maxTentativas}`);\n      \n      // Gerar o prompt com os versículos a serem evitados\n      const prompt = await gerarPrompt(dataAtual);\n      \n      try {\n        const result = await geminiModel.generateContent({\n          contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n          generationConfig: {\n            temperature: 0.7 + (tentativas * 0.1), // Aumentar a temperatura a cada tentativa\n            topK: 40,\n            topP: 0.95,\n            maxOutputTokens: 1024,\n          },\n        });\n        \n        const response = result.response;\n        devocional = response.text().trim();\n        \n        // Verificar se o devocional foi gerado corretamente\n        if (!devocional || devocional.length < 50) {\n          logger.warn('Devocional gerado muito curto ou vazio. Tentando novamente.');\n          continue;\n        }\n        \n        // Validar se o versículo não foi usado recentemente\n        devocionalValido = await validarDevocionalGerado(devocional);\n        \n        if (devocionalValido) {\n          logger.info('Devocional válido gerado com sucesso');\n          return devocional;\n        } else {\n          logger.warn('Devocional gerado usa versículo repetido. Tentando novamente.');\n        }\n      } catch (erroGemini) {\n        logger.warn(`Erro com o modelo na tentativa ${tentativas}: ${erroGemini.message}`);\n        \n        if (tentativas >= maxTentativas) {\n          logger.error('Número máximo de tentativas atingido. Usando fallback.');\n          return gerarDevocionalFallback(dataAtual);\n        }\n      }\n    }\n    \n    // Se chegou aqui sem um devocional válido, usar fallback\n    if (!devocionalValido) {\n      logger.warn('Não foi possível gerar um devocional com versículo único. Usando fallback.');\n      return gerarDevocionalFallback(dataAtual);\n    }\n    \n    return devocional;\n  } catch (erro) {\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\n    return gerarDevocionalFallback(dataAtual);\n  }\n}\n\n// Gerar o devocional utilizando o Gemini\nasync function gerarDevocional(dataAtual) {\n  try {\n    // Verificar se a API foi inicializada corretamente\n    if (!geminiModel) {\n      logger.warn('API do Gemini não inicializada. Tentando inicializar novamente...');\n      \n      // Tentar inicializar novamente\n      const inicializou = inicializarGeminiAPI();\n      \n      if (!inicializou || !geminiModel) {\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\n      }\n    }\n    \n    logger.info('Gerando prompt para o Gemini...');\n    const prompt = await gerarPrompt(dataAtual);\n    \n    logger.info('Solicitando geração de devocional ao Gemini...');\n    \n    try {\n      const result = await geminiModel.generateContent({\n        contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 1024,\n        },\n      });\n      \n      const response = result.response;\n      const devocional = response.text().trim();\n      \n      // Verificar se o devocional foi gerado corretamente\n      if (!devocional || devocional.length < 50) {\n        logger.warn('Devocional gerado muito curto ou vazio. Usando fallback.');\n        return gerarDevocionalFallback(dataAtual);\n      }\n      \n      logger.info('Devocional gerado com sucesso');\n      return devocional;\n    } catch (erroGemini) {\n      // Tentar usar outro modelo se o modelo atual falhar\n      logger.warn(`Erro com o modelo atual. Detalhe: ${erroGemini.message}`);\n      \n      try {\n        // Tentar com modelo alternativo\n        logger.info('Tentando modelo alternativo gemini-pro...');\n        const modeloAlternativo = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n        \n        const resultadoAlternativo = await modeloAlternativo.generateContent({\n          contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n          generationConfig: {\n            temperature: 0.7,\n            topK: 40,\n            topP: 0.95,\n            maxOutputTokens: 1024,\n          },\n        });\n        \n        const respostaAlternativa = resultadoAlternativo.response;\n        const devocionalAlternativo = respostaAlternativa.text().trim();\n        \n        logger.info('Devocional gerado com sucesso usando modelo alternativo');\n        return devocionalAlternativo;\n      } catch (erroModeloAlternativo) {\n        logger.error(`Erro também no modelo alternativo: ${erroModeloAlternativo.message}`);\n        throw new Error(`Falha em todos os modelos Gemini disponíveis`);\n      }\n    }\n  } catch (erro) {\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\n    \n    // Retornar um devocional de fallback em caso de erro\n    return gerarDevocionalFallback(dataAtual);\n  }\n}\n\n// Gerar um devocional de fallback em caso de erro na API\nfunction gerarDevocionalFallback(dataAtual) {\n  logger.info('Gerando devocional de fallback...');\n  \n  return `${dataAtual}\n\n*✝️ Versículo:* \"Não temas, porque eu sou contigo; não te assombres, porque eu sou teu Deus; eu te fortaleço, e te ajudo, e te sustento com a destra da minha justiça.\" (Isaías 41:10)\n\n*💭 Reflexão:* Mesmo quando enfrentamos dificuldades ou desafios inesperados, Deus está ao nosso lado, pronto para nos dar força e sustento. Este versículo nos lembra que não precisamos temer, pois temos a presença constante do Senhor em nossas vidas, guiando nossos passos e iluminando nosso caminho.\n\n*🧗🏻 Prática:* Hoje, ao enfrentar qualquer situação desafiadora, faça uma pausa, respire e relembre esta promessa de sustento divino antes de prosseguir.`;\n}\n\nmodule.exports = {\n  gerarDevocional\n};"
    },
    {
      "path": "src\\historicoMensagens.js",
      "name": "historicoMensagens.js",
      "extension": ".js",
      "size": 11682,
      "last_modified": "2025-04-03T14:06:05.760106",
      "content": "// Módulo para gerenciamento do histórico de mensagens enviadas\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst { logger } = require('./utils');\n\n// Configurações do histórico\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Histórico';\nconst HISTORICO_FILE = process.env.HISTORICO_FILE || './Histórico/historico.json';\nconst MAX_HISTORICO_DIAS = parseInt(process.env.MAX_HISTORICO_DIAS || '90', 10);\n\n// Garantir que o diretório do histórico exista\nfunction garantirDiretorioHistorico() {\n  if (!fs.existsSync(HISTORICO_DIR)) {\n    fs.mkdirSync(HISTORICO_DIR, { recursive: true });\n    logger.info(`Diretório de histórico criado: ${HISTORICO_DIR}`);\n  }\n  \n  if (!fs.existsSync(HISTORICO_FILE)) {\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify({\n      ultimaAtualizacao: new Date().toISOString(),\n      mensagens: []\n    }, null, 2));\n    logger.info(`Arquivo de histórico criado: ${HISTORICO_FILE}`);\n  }\n}\n\n// Carregar o histórico de mensagens\nfunction carregarHistorico() {\n  try {\n    garantirDiretorioHistorico();\n    \n    // Verificar se o arquivo existe e tem conteúdo válido\n    if (fs.existsSync(HISTORICO_FILE)) {\n      const conteudo = fs.readFileSync(HISTORICO_FILE, 'utf8');\n      if (conteudo && conteudo.trim()) {\n        const historico = JSON.parse(conteudo);\n        // Garantir que o objeto tem a estrutura esperada\n        if (!historico.mensagens) {\n          historico.mensagens = [];\n        }\n        return historico;\n      }\n    }\n    \n    // Se o arquivo não existir, estiver vazio ou não tiver a estrutura esperada\n    const historicoVazio = {\n      ultimaAtualizacao: new Date().toISOString(),\n      mensagens: []\n    };\n    \n    // Salvar o histórico vazio para garantir consistência\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\n    \n    return historicoVazio;\n  } catch (erro) {\n    logger.error(`Erro ao carregar histórico: ${erro.message}`);\n    // Retornar um histórico vazio em caso de erro\n    const historicoVazio = {\n      ultimaAtualizacao: new Date().toISOString(),\n      mensagens: []\n    };\n    \n    // Tentar salvar o histórico vazio\n    try {\n      fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\n    } catch (erroSalvar) {\n      logger.error(`Erro ao salvar histórico vazio: ${erroSalvar.message}`);\n    }\n    \n    return historicoVazio;\n  }\n}\n\n// Salvar o histórico de mensagens\nfunction salvarHistorico(historico) {\n  try {\n    garantirDiretorioHistorico();\n    \n    // Atualizar a data da última atualização\n    historico.ultimaAtualizacao = new Date().toISOString();\n    \n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historico, null, 2));\n    logger.info('Histórico salvo com sucesso');\n  } catch (erro) {\n    logger.error(`Erro ao salvar histórico: ${erro.message}`);\n  }\n}\n\n// Limpar mensagens antigas do histórico\nfunction limparHistoricoAntigo(historico) {\n  try {\n    const dataLimite = new Date();\n    dataLimite.setDate(dataLimite.getDate() - MAX_HISTORICO_DIAS);\n    \n    const mensagensRecentes = historico.mensagens.filter(msg => {\n      const dataMensagem = new Date(msg.data);\n      return dataMensagem >= dataLimite;\n    });\n    \n    const mensagensRemovidas = historico.mensagens.length - mensagensRecentes.length;\n    \n    if (mensagensRemovidas > 0) {\n      logger.info(`Removidas ${mensagensRemovidas} mensagens antigas do histórico`);\n      historico.mensagens = mensagensRecentes;\n      salvarHistorico(historico);\n    }\n    \n    return historico;\n  } catch (erro) {\n    logger.error(`Erro ao limpar histórico antigo: ${erro.message}`);\n    return historico;\n  }\n}\n\n// Extrair versículos de uma mensagem devocional\nfunction extrairVersiculo(devocional) {\n  try {\n    // Procurar o padrão de versículo na mensagem\n    const regexVersiculo = /Versículo:\\s*[\"'](.+?)[\"']\\s*\\((.+?)\\)/i;\n    const match = devocional.match(regexVersiculo);\n    \n    if (match && match.length >= 3) {\n      return {\n        texto: match[1].trim(),\n        referencia: match[2].trim()\n      };\n    }\n    \n    return null;\n  } catch (erro) {\n    logger.error(`Erro ao extrair versículo: ${erro.message}`);\n    return null;\n  }\n}\n\n// Registrar um envio no histórico\nfunction registrarEnvio(dados) {\n  try {\n    const historico = carregarHistorico();\n    const versiculo = extrairVersiculo(dados.devocional);\n    \n    historico.mensagens.push({\n      data: dados.data,\n      devocional: dados.devocional,\n      versiculo: versiculo,\n      totalContatos: dados.totalContatos,\n      enviosComSucesso: dados.enviosComSucesso,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Limpar mensagens antigas antes de salvar\n    limparHistoricoAntigo(historico);\n    \n    logger.info('Envio registrado no histórico com sucesso');\n  } catch (erro) {\n    logger.error(`Erro ao registrar envio no histórico: ${erro.message}`);\n  }\n}\n\n// Obter versículos usados recentemente (para evitar repetições)\nfunction obterVersiculosRecentes(dias = 7) {\n  try {\n    const historico = carregarHistorico();\n    const dataLimite = new Date();\n    dataLimite.setDate(dataLimite.getDate() - dias);\n\n    // Adicionar log para debug\n    logger.info(`Verificando versículos usados nos últimos ${dias} dias`);\n    \n    const versiculosRecentes = historico.mensagens\n      .filter(msg => {\n        if (!msg.data || !msg.versiculo) return false;\n        const dataMensagem = new Date(msg.data);\n        return isRecente = dataMensagem >= dataLimite;\n\n        // Log para cada entrada\n        if (isRecente && msg.versiculo) {\n          logger.info(`Versículo recente encontrado: ${msg.versiculo.referencia} usado em ${dataMensagem.toISOString()}`);\n        }\n        return isRecente && msg.versiculo\n      })\n      .map(msg => msg.versiculo);\n    \n    logger.info(`Total de ${versiculosRecentes.length} versículos recentes encontrados`);\n    return versiculosRecentes;\n  } catch (erro) {\n    logger.error(`Erro ao obter versículos recentes: ${erro.message}`);\n    return [];\n  }\n}\n\n// Verificar se um versículo foi usado recentemente\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 7) { // Aumentei para 7 dias\n  try {\n    const versiculosRecentes = obterVersiculosRecentes(dias);\n    \n    // Normalizar a referência para comparação (remover espaços e converter para minúsculas)\n    const referenciaFormatada = referencia.replace(/\\s+/g, '').toLowerCase();\n    \n    const encontrado = versiculosRecentes.some(versiculo => {\n      if (!versiculo || !versiculo.referencia) return false;\n      \n      const versiculoFormatado = versiculo.referencia.replace(/\\s+/g, '').toLowerCase();\n      const isMatch = versiculoFormatado === referenciaFormatada;\n      \n      if (isMatch) {\n        logger.info(`Versículo ${referencia} já foi usado recentemente`);\n      }\n      \n      return isMatch;\n    });\n    \n    return encontrado;\n  } catch (erro) {\n    logger.error(`Erro ao verificar versículo: ${erro.message}`);\n    return false;\n  }\n}\n\n// Obter o último devocional enviado\nasync function obterUltimoDevocionalEnviado() {\n  try {\n    // Tentar obter do histórico geral primeiro\n    const historico = carregarHistorico();\n    \n    if (historico && historico.mensagens && historico.mensagens.length > 0) {\n      // Ordenar mensagens por data (mais recente primeiro)\n      const mensagensOrdenadas = [...historico.mensagens].sort((a, b) => \n        new Date(b.data) - new Date(a.data)\n      );\n      \n      // Verificar se o último devocional foi enviado hoje\n      const hoje = new Date();\n      const dataHoje = `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, '0')}-${String(hoje.getDate()).padStart(2, '0')}`;\n      \n      // Encontrar o último devocional\n      for (const msg of mensagensOrdenadas) {\n        if (msg.devocional) {\n          // Extrair a data do timestamp\n          const dataMensagem = new Date(msg.timestamp || msg.data);\n          const dataMensagemStr = `${dataMensagem.getFullYear()}-${String(dataMensagem.getMonth() + 1).padStart(2, '0')}-${String(dataMensagem.getDate()).padStart(2, '0')}`;\n          \n          // Se o devocional for de hoje, retorná-lo\n          if (dataMensagemStr === dataHoje) {\n            logger.info(`Devocional de hoje encontrado no histórico geral (${dataMensagemStr})`);\n            return msg.devocional;\n          }\n        }\n      }\n      \n      // Se não encontrar um devocional de hoje, retorna o mais recente\n      const ultimoDevocional = mensagensOrdenadas.find(msg => msg.devocional);\n      if (ultimoDevocional) {\n        logger.info('Retornando devocional mais recente disponível do histórico geral');\n        return ultimoDevocional.devocional;\n      }\n    }\n    \n    // Se não encontrou no histórico geral, buscar nas conversas individuais\n    logger.info('Buscando devocional nas conversas individuais...');\n    \n    const CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\n    if (!fs.existsSync(CONVERSAS_DIR)) {\n      logger.warn(`Diretório de conversas não encontrado: ${CONVERSAS_DIR}`);\n      return null;\n    }\n    \n    // Ler arquivos de conversa\n    const arquivos = fs.readdirSync(CONVERSAS_DIR);\n    const arquivosJson = arquivos.filter(arquivo => arquivo.endsWith('.json'));\n    \n    let devocionalMaisRecente = null;\n    let dataMaisRecente = new Date(0); // Data antiga\n    \n    // Buscar em todas as conversas\n    for (const arquivo of arquivosJson) {\n      try {\n        const conteudo = fs.readFileSync(path.join(CONVERSAS_DIR, arquivo), 'utf8');\n        const conversa = JSON.parse(conteudo);\n        \n        if (conversa.ultimoDevocional) {\n          const dataDevocional = new Date(conversa.ultimoDevocional.data);\n          \n          // Verificar se é mais recente que o último encontrado\n          if (dataDevocional > dataMaisRecente) {\n            devocionalMaisRecente = conversa.ultimoDevocional.conteudo;\n            dataMaisRecente = dataDevocional;\n          }\n        }\n      } catch (erroLeitura) {\n        logger.error(`Erro ao ler arquivo de conversa ${arquivo}: ${erroLeitura.message}`);\n      }\n    }\n    \n    if (devocionalMaisRecente) {\n      logger.info(`Devocional encontrado nas conversas individuais (data: ${dataMaisRecente.toISOString()})`);\n      return devocionalMaisRecente;\n    }\n    \n    logger.warn('Nenhum devocional encontrado no histórico ou nas conversas');\n    return null;\n  } catch (erro) {\n    logger.error(`Erro ao obter último devocional: ${erro.message}`);\n    return null;\n  }\n}\n\n// Verificar se um versículo foi usado recentemente\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 30) {\n  try {\n    const versiculosRecentes = obterVersiculosRecentes(dias);\n    \n    // Normalizar a referência para comparação (remover espaços e converter para minúsculas)\n    const referenciaFormatada = referencia.replace(/\\s+/g, '').toLowerCase();\n    \n    return versiculosRecentes.some(versiculo => {\n      const versiculoFormatado = versiculo.referencia.replace(/\\s+/g, '').toLowerCase();\n      return versiculoFormatado === referenciaFormatada;\n    });\n  } catch (erro) {\n    logger.error(`Erro ao verificar versículo: ${erro.message}`);\n    return false;\n  }\n}\n\nmodule.exports = {\n  registrarEnvio,\n  obterVersiculosRecentes,\n  versiculoFoiUsadoRecentemente,\n  obterUltimoDevocionalEnviado\n};"
    },
    {
      "path": "src\\index.js",
      "name": "index.js",
      "extension": ".js",
      "size": 5072,
      "last_modified": "2025-04-03T14:19:11.019018",
      "content": "// WhatsApp Devocional Diário com IA\n// Ponto de entrada da aplicação\n\nrequire('dotenv').config();\nconst fs = require('fs-extra');\nconst schedule = require('node-schedule');\nconst moment = require('moment');\nmoment.locale('pt-br');\n\n// Importação dos módulos\nconst whatsapp = require('./whatsapp');\nconst geradorDevocional = require('./geradorDevocional');\nconst leitorContatos = require('./leitorContatos');\nconst historicoMensagens = require('./historicoMensagens');\nconst conversasHandler = require('./conversasHandler');\nconst leitorDocumentos = require('./leitorDocumentos');\nconst { criarDiretorios, formatarData, logger } = require('./utils');\n\n// Garantir que os diretórios necessários existam\ncriarDiretorios();\n\n// Função principal que executa o envio dos devocionais\nasync function enviarDevocionaisDiarios() {\n  try {\n    logger.info('Iniciando o processo de envio de devocionais diários');\n    \n    // Obter a data atual formatada\n    const dataAtual = formatarData(new Date());\n    logger.info(`Data atual: ${dataAtual}`);\n    \n    // Gerar o devocional do dia\n    logger.info('Gerando devocional...');\n    const devocional = await geradorDevocional.gerarDevocional(dataAtual);\n    logger.info('Devocional gerado com sucesso');\n    \n    // Verificar se o cliente WhatsApp está pronto\n    if (!whatsapp.clientePronto()) {\n      logger.error('Cliente WhatsApp não está pronto. Tentando novamente em 5 minutos.');\n      setTimeout(enviarDevocionaisDiarios, 5 * 60 * 1000);\n      return;\n    }\n    \n    // Obter a lista de contatos\n    logger.info('Obtendo lista de contatos...');\n    const contatos = await leitorContatos.obterContatos();\n    logger.info(`${contatos.length} contatos encontrados`);\n    \n    // Enviar o devocional para cada contato\n    let enviosComSucesso = 0;\n    \n    for (const contato of contatos) {\n      try {\n        logger.info(`Enviando devocional para ${contato.nome} (${contato.telefone})...`);\n        await whatsapp.enviarMensagem(contato.telefone, devocional);\n        \n        // Registrar o devocional enviado para referência em conversas futuras\n        await conversasHandler.registrarDevocionalEnviado(contato.telefone, devocional);\n        \n        enviosComSucesso++;\n        logger.info(`Devocional enviado com sucesso para ${contato.nome}`);\n      } catch (erro) {\n        logger.error(`Erro ao enviar devocional para ${contato.nome}: ${erro.message}`);\n      }\n    }\n    \n    // Registrar no histórico\n    historicoMensagens.registrarEnvio({\n      data: dataAtual,\n      devocional: devocional,\n      totalContatos: contatos.length,\n      enviosComSucesso: enviosComSucesso\n    });\n    \n    logger.info(`Processo concluído. Enviado para ${enviosComSucesso}/${contatos.length} contatos.`);\n  } catch (erro) {\n    logger.error(`Erro ao executar o processo de envio: ${erro.message}`);\n    logger.error(erro.stack);\n  }\n}\n\n// Pré-processar a base de conhecimento\nasync function preprocessarBaseConhecimento() {\n  try {\n    logger.info('Iniciando pré-processamento da base de conhecimento...');\n    const conteudoBase = await leitorDocumentos.obterConteudoBase();\n    logger.info(`Base de conhecimento processada: ${conteudoBase.length} caracteres`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao processar base de conhecimento: ${erro.message}`);\n    return false;\n  }\n}\n\n// Inicialização do sistema\nasync function iniciarSistema() {\n  try {\n    logger.info('Iniciando o sistema WhatsApp Devocional IA...');\n    \n    // Primeiro, processar a base de conhecimento\n    logger.info('Processando base de conhecimento...');\n    const baseProcessada = await preprocessarBaseConhecimento();\n    \n    if (!baseProcessada) {\n      logger.warn('Houve um problema no processamento da base de conhecimento, mas o sistema continuará.');\n    }\n    \n    // Depois, iniciar o cliente WhatsApp\n    logger.info('Inicializando conexão com WhatsApp...');\n    await whatsapp.iniciarCliente();\n    \n    // Agendar o envio diário de devocionais no horário configurado\n    const horarioEnvio = process.env.SCHEDULE_TIME || '07:00';\n    const [hora, minuto] = horarioEnvio.split(':').map(Number);\n    \n    schedule.scheduleJob(`${minuto} ${hora} * * *`, async () => {\n      logger.info('Executando tarefa agendada de envio de devocionais');\n      await enviarDevocionaisDiarios();\n    });\n    \n    logger.info(`Sistema iniciado. Devocionais serão enviados diariamente às ${horarioEnvio}`);\n    \n    // Para desenvolvimento/testes: Descomentar para enviar um devocional imediatamente\n     setTimeout(enviarDevocionaisDiarios, 10000);\n  } catch (erro) {\n    logger.error(`Erro ao iniciar o sistema: ${erro.message}`);\n    logger.error(erro.stack);\n  }\n}\n\n// Iniciar o sistema\niniciarSistema();\n\n// Tratamento de encerramento gracioso\nprocess.on('SIGINT', async () => {\n  logger.info('Encerrando o sistema...');\n  await whatsapp.encerrarCliente();\n  process.exit(0);\n});"
    },
    {
      "path": "src\\leitorContatos.js",
      "name": "leitorContatos.js",
      "extension": ".js",
      "size": 8837,
      "last_modified": "2025-04-03T13:54:43.522193",
      "content": "// Módulo para leitura da lista de contatos de arquivos Excel ou CSV\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\nconst csvParser = require('csv-parser');\nconst { adicionarNovoContatoNaPlanilha } = require('./adicionarContato');\nconst { logger } = require('./utils');\n\n// Diretório de contatos\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\n\n// Obter a lista de arquivos de contatos disponíveis\nfunction obterArquivosContatos() {\n  try {\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\n    return arquivos.filter(arquivo => {\n      const extensao = path.extname(arquivo).toLowerCase();\n      return extensao === '.xlsx' || extensao === '.csv';\n    });\n  } catch (erro) {\n    logger.error(`Erro ao ler diretório de contatos: ${erro.message}`);\n    return [];\n  }\n}\n\n// Ler contatos de um arquivo Excel\nasync function lerContatosExcel(caminhoArquivo) {\n  try {\n    logger.info(`Lendo arquivo Excel: ${caminhoArquivo}`);\n    \n    // Opções adicionais para melhorar a leitura\n    const workbook = xlsx.readFile(caminhoArquivo, {\n      cellDates: true,\n      cellNF: true,\n      cellText: true\n    });\n    \n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\n      logger.error('Arquivo Excel sem planilhas');\n      return [];\n    }\n    \n    // Verificar todas as planilhas para encontrar contatos\n    let todosContatos = [];\n    \n    for (const sheetName of workbook.SheetNames) {\n      logger.info(`Processando planilha: ${sheetName}`);\n      \n      const worksheet = workbook.Sheets[sheetName];\n      \n      // Verificar se a planilha tem dados\n      if (!worksheet['!ref']) {\n        logger.warn(`Planilha ${sheetName} vazia, pulando...`);\n        continue;\n      }\n      \n      // Tentar ler os dados da planilha\n      try {\n        const dados = xlsx.utils.sheet_to_json(worksheet, {\n          defval: '',  // Valor padrão para células vazias\n          raw: false   // Não converter tipos automaticamente\n        });\n        \n        logger.info(`Encontrados ${dados.length} registros na planilha ${sheetName}`);\n        \n        if (dados.length > 0) {\n          const contatos = normalizarContatos(dados);\n          logger.info(`${contatos.length} contatos válidos na planilha ${sheetName}`);\n          todosContatos = todosContatos.concat(contatos);\n        }\n      } catch (erroLeitura) {\n        logger.error(`Erro ao processar planilha ${sheetName}: ${erroLeitura.message}`);\n      }\n    }\n    \n    return todosContatos;\n  } catch (erro) {\n    logger.error(`Erro ao ler arquivo Excel: ${erro.message}`);\n    logger.error(erro.stack);\n    return [];\n  }\n}\n\n// Ler contatos de um arquivo CSV\nasync function lerContatosCsv(caminhoArquivo) {\n  return new Promise((resolve, reject) => {\n    const contatos = [];\n    \n    fs.createReadStream(caminhoArquivo)\n      .pipe(csvParser())\n      .on('data', (row) => {\n        contatos.push(row);\n      })\n      .on('end', () => {\n        resolve(normalizarContatos(contatos));\n      })\n      .on('error', (erro) => {\n        logger.error(`Erro ao ler arquivo CSV: ${erro.message}`);\n        reject(erro);\n      });\n  });\n}\n\n// Normalizar os dados dos contatos para um formato padrão\nfunction normalizarContatos(dados) {\n  if (!dados || !Array.isArray(dados) || dados.length === 0) {\n    logger.warn('Nenhum dado de contato válido encontrado para normalizar');\n    return [];\n  }\n  \n  // Registrar os campos encontrados no primeiro registro para debug\n  if (dados.length > 0) {\n    logger.info(`Campos encontrados na planilha: ${Object.keys(dados[0]).join(', ')}`);\n  }\n  \n  return dados.map(contato => {\n    // Tentar encontrar os campos de nome e telefone, independente da capitalização\n    const entradas = Object.entries(contato);\n    let nome = '';\n    let telefone = '';\n    let ativo = true;\n    \n    // Debug para cada contato\n    logger.info(`Processando contato: ${JSON.stringify(contato)}`);\n    \n    for (const [chave, valor] of entradas) {\n      if (!chave) continue;\n      \n      const chaveLower = String(chave).toLowerCase();\n      \n      if (chaveLower.includes('nome')) {\n        nome = valor;\n        logger.info(`Nome encontrado: ${nome}`);\n      } else if (\n        chaveLower.includes('telefone') || \n        chaveLower.includes('celular') || \n        chaveLower.includes('whatsapp') || \n        chaveLower.includes('fone') ||\n        chaveLower.includes('phone') ||\n        chaveLower.includes('numero')\n      ) {\n        telefone = valor;\n        logger.info(`Telefone encontrado (original): ${telefone}`);\n      } else if (\n        chaveLower.includes('ativo') || \n        chaveLower.includes('status') || \n        chaveLower.includes('habilitado')\n      ) {\n        // Considerar o contato ativo se o campo for 'sim', 'true', 1, etc.\n        if (typeof valor === 'string') {\n          const valorLower = String(valor).toLowerCase();\n          ativo = valorLower === 'sim' || valorLower === 'true' || valorLower === 's' || valorLower === 'y' || valorLower === 'yes';\n        } else {\n          ativo = Boolean(valor);\n        }\n      }\n    }\n    \n    // Se não encontrar telefone, tentar encontrar algum campo que pareça ser um número de telefone\n    if (!telefone) {\n      for (const [chave, valor] of entradas) {\n        // Verificar se o valor se parece com um número de telefone (apenas dígitos e com pelo menos 8 caracteres)\n        if (valor && typeof valor === 'string' && valor.replace(/\\D/g, '').length >= 8) {\n          telefone = valor;\n          logger.info(`Possível telefone encontrado no campo ${chave}: ${telefone}`);\n          break;\n        }\n      }\n    }\n    \n    // Garantir que telefone seja uma string antes de aplicar replace\n    let telefoneFormatado = '';\n    if (telefone !== undefined && telefone !== null) {\n      // Normalizar o telefone (remover caracteres não numéricos)\n      telefoneFormatado = String(telefone).replace(/\\D/g, '');\n      \n      // Adicionar código do país (55) se não estiver presente e for um número brasileiro\n      if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\n        telefoneFormatado = `55${telefoneFormatado}`;\n        logger.info(`Adicionado código do país: ${telefoneFormatado}`);\n      }\n    }\n    \n    logger.info(`Telefone formatado: ${telefoneFormatado}`);\n    \n    return {\n      nome: nome || 'Sem nome',\n      telefone: telefoneFormatado,\n      ativo: ativo\n    };\n  })\n  // Filtrar contatos sem telefone ou inativos\n  .filter(contato => {\n    // Verificar se o telefone é válido (pelo menos 10 dígitos)\n    const telefoneValido = contato.telefone && contato.telefone.length >= 10;\n    \n    if (!telefoneValido) {\n      logger.warn(`Contato \"${contato.nome}\" ignorado: número de telefone inválido (${contato.telefone})`);\n    } else if (!contato.ativo) {\n      logger.info(`Contato \"${contato.nome}\" ignorado: está marcado como inativo`);\n    } else {\n      logger.info(`Contato válido: ${contato.nome} (${contato.telefone})`);\n    }\n    \n    return telefoneValido && contato.ativo;\n  });\n}\n\n// Função principal para obter todos os contatos de todos os arquivos\nasync function obterContatos() {\n  try {\n    const arquivos = obterArquivosContatos();\n    \n    if (arquivos.length === 0) {\n      logger.warn('Nenhum arquivo de contatos encontrado no diretório');\n      return [];\n    }\n    \n    let todosContatos = [];\n    \n    for (const arquivo of arquivos) {\n      const caminhoArquivo = path.join(CONTATOS_DIR, arquivo);\n      const extensao = path.extname(arquivo).toLowerCase();\n      \n      logger.info(`Lendo contatos do arquivo: ${arquivo}`);\n      \n      let contatos = [];\n      if (extensao === '.xlsx') {\n        contatos = await lerContatosExcel(caminhoArquivo);\n      } else if (extensao === '.csv') {\n        contatos = await lerContatosCsv(caminhoArquivo);\n      }\n      \n      logger.info(`${contatos.length} contatos válidos encontrados em ${arquivo}`);\n      todosContatos = todosContatos.concat(contatos);\n    }\n    \n    // Remover duplicatas baseadas no número de telefone\n    const contatosUnicos = {};\n    todosContatos.forEach(contato => {\n      contatosUnicos[contato.telefone] = contato;\n    });\n    \n    const resultado = Object.values(contatosUnicos);\n    logger.info(`Total de ${resultado.length} contatos únicos encontrados`);\n    \n    return resultado;\n  } catch (erro) {\n    logger.error(`Erro ao obter contatos: ${erro.message}`);\n    return [];\n  }\n}\n\nmodule.exports = {\n  obterContatos,\n  adicionarNovoContatoNaPlanilha\n};"
    },
    {
      "path": "src\\leitorDocumentos.js",
      "name": "leitorDocumentos.js",
      "extension": ".js",
      "size": 6949,
      "last_modified": "2025-04-03T13:54:43.522193",
      "content": "// Módulo para processamento dos documentos base\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\nconst csvParser = require('csv-parser');\nconst pdfParse = require('pdf-parse');\nconst cheerio = require('cheerio');\nconst { logger } = require('./utils');\n\n// Diretório de documentos base\nconst BASE_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\n\n// Cache de documentos processados para evitar reprocessamento\nlet documentosCache = null;\nlet dataUltimaAtualizacao = null;\n\n// Verificar a necessidade de atualização do cache\nfunction verificarCacheAtualizado() {\n  if (!documentosCache || !dataUltimaAtualizacao) {\n    return false;\n  }\n  \n  // Verificar se algum arquivo foi modificado desde a última atualização\n  try {\n    const arquivos = obterArquivosBase();\n    \n    for (const arquivo of arquivos) {\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\n      const stats = fs.statSync(caminhoArquivo);\n      \n      if (stats.mtime > dataUltimaAtualizacao) {\n        return false;\n      }\n    }\n    \n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao verificar cache: ${erro.message}`);\n    return false;\n  }\n}\n\n// Obter a lista de arquivos da base de conhecimento\nfunction obterArquivosBase() {\n  try {\n    const arquivos = fs.readdirSync(BASE_DIR);\n    return arquivos.filter(arquivo => {\n      const extensao = path.extname(arquivo).toLowerCase();\n      return ['.pdf', '.json', '.txt', '.csv', '.xlsx'].includes(extensao);\n    });\n  } catch (erro) {\n    logger.error(`Erro ao ler diretório da base de conhecimento: ${erro.message}`);\n    return [];\n  }\n}\n\n// Processar um arquivo PDF\nasync function processarPdf(caminhoArquivo) {\n  try {\n    const dataBuffer = fs.readFileSync(caminhoArquivo);\n    const data = await pdfParse(dataBuffer);\n    return data.text;\n  } catch (erro) {\n    logger.error(`Erro ao processar PDF ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Processar um arquivo JSON\nfunction processarJson(caminhoArquivo) {\n  try {\n    const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n    const data = JSON.parse(conteudo);\n    \n    // Extrair textos do JSON (considerando diferentes estruturas possíveis)\n    return extrairTextosJson(data);\n  } catch (erro) {\n    logger.error(`Erro ao processar JSON ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Extrair textos recursivamente de um objeto JSON\nfunction extrairTextosJson(obj, textos = []) {\n  if (!obj) return textos;\n  \n  if (typeof obj === 'string') {\n    textos.push(obj);\n  } else if (Array.isArray(obj)) {\n    obj.forEach(item => extrairTextosJson(item, textos));\n  } else if (typeof obj === 'object') {\n    Object.values(obj).forEach(valor => extrairTextosJson(valor, textos));\n  }\n  \n  return textos.join('\\n');\n}\n\n// Processar um arquivo TXT\nfunction processarTxt(caminhoArquivo) {\n  try {\n    return fs.readFileSync(caminhoArquivo, 'utf8');\n  } catch (erro) {\n    logger.error(`Erro ao processar TXT ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Processar um arquivo CSV\nasync function processarCsv(caminhoArquivo) {\n  return new Promise((resolve, reject) => {\n    const linhas = [];\n    \n    fs.createReadStream(caminhoArquivo)\n      .pipe(csvParser())\n      .on('data', (row) => {\n        linhas.push(Object.values(row).join(' '));\n      })\n      .on('end', () => {\n        resolve(linhas.join('\\n'));\n      })\n      .on('error', (erro) => {\n        logger.error(`Erro ao processar CSV ${caminhoArquivo}: ${erro.message}`);\n        reject(erro);\n      });\n  });\n}\n\n// Processar um arquivo Excel\nfunction processarExcel(caminhoArquivo) {\n  try {\n    const workbook = xlsx.readFile(caminhoArquivo);\n    const resultado = [];\n    \n    workbook.SheetNames.forEach(sheetName => {\n      const worksheet = workbook.Sheets[sheetName];\n      const dados = xlsx.utils.sheet_to_json(worksheet);\n      \n      dados.forEach(linha => {\n        resultado.push(Object.values(linha).join(' '));\n      });\n    });\n    \n    return resultado.join('\\n');\n  } catch (erro) {\n    logger.error(`Erro ao processar Excel ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Processar HTML (para arquivos que possam conter HTML)\nfunction processarHtml(conteudo) {\n  try {\n    const $ = cheerio.load(conteudo);\n    // Remover scripts e estilos\n    $('script').remove();\n    $('style').remove();\n    \n    // Obter o texto\n    return $('body').text().trim();\n  } catch (erro) {\n    logger.error(`Erro ao processar HTML: ${erro.message}`);\n    return conteudo;\n  }\n}\n\n// Obter todo o conteúdo da base de conhecimento\nasync function obterConteudoBase() {\n  // Verificar se o cache está atualizado\n  if (verificarCacheAtualizado()) {\n    logger.info('Usando cache da base de conhecimento (sem alterações desde a última leitura)');\n    return documentosCache;\n  }\n  \n  try {\n    const arquivos = obterArquivosBase();\n    \n    if (arquivos.length === 0) {\n      logger.warn('Nenhum arquivo encontrado na base de conhecimento');\n      return '';\n    }\n    \n    logger.info(`Processando ${arquivos.length} arquivos da base de conhecimento...`);\n    \n    let conteudoCompleto = '';\n    \n    for (const arquivo of arquivos) {\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\n      const extensao = path.extname(arquivo).toLowerCase();\n      \n      logger.info(`Processando arquivo: ${arquivo}`);\n      \n      let conteudo = '';\n      \n      switch (extensao) {\n        case '.pdf':\n          conteudo = await processarPdf(caminhoArquivo);\n          break;\n        case '.json':\n          conteudo = processarJson(caminhoArquivo);\n          break;\n        case '.txt':\n          conteudo = processarTxt(caminhoArquivo);\n          break;\n        case '.csv':\n          conteudo = await processarCsv(caminhoArquivo);\n          break;\n        case '.xlsx':\n          conteudo = processarExcel(caminhoArquivo);\n          break;\n        default:\n          logger.warn(`Tipo de arquivo não suportado: ${extensao}`);\n          continue;\n      }\n      \n      // Verificar se o conteúdo pode conter HTML e processá-lo se necessário\n      if (conteudo.includes('<html') || conteudo.includes('<body') || conteudo.includes('<div')) {\n        conteudo = processarHtml(conteudo);\n      }\n      \n      conteudoCompleto += conteudo + '\\n\\n';\n    }\n    \n    // Atualizar o cache\n    documentosCache = conteudoCompleto;\n    dataUltimaAtualizacao = new Date();\n    \n    logger.info('Base de conhecimento processada com sucesso');\n    return conteudoCompleto;\n  } catch (erro) {\n    logger.error(`Erro ao obter conteúdo da base: ${erro.message}`);\n    return '';\n  }\n}\n\nmodule.exports = {\n  obterConteudoBase\n};"
    },
    {
      "path": "src\\utils.js",
      "name": "utils.js",
      "extension": ".js",
      "size": 3074,
      "last_modified": "2025-04-03T13:54:43.522193",
      "content": "// Módulo de funções utilitárias\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst moment = require('moment');\nmoment.locale('pt-br');\n\n// Configurações dos diretórios\nconst BASE_CONHECIMENTO_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Histórico';\n\n// Logger simples\nconst logger = {\n  info: (mensagem) => {\n    console.log(`[INFO] ${new Date().toISOString()} - ${mensagem}`);\n  },\n  warn: (mensagem) => {\n    console.warn(`[WARN] ${new Date().toISOString()} - ${mensagem}`);\n  },\n  error: (mensagem) => {\n    console.error(`[ERROR] ${new Date().toISOString()} - ${mensagem}`);\n  }\n};\n\n// Criar diretórios necessários\nfunction criarDiretorios() {\n  try {\n    [BASE_CONHECIMENTO_DIR, CONTATOS_DIR, HISTORICO_DIR].forEach(dir => {\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n        logger.info(`Diretório criado: ${dir}`);\n      }\n    });\n  } catch (erro) {\n    logger.error(`Erro ao criar diretórios: ${erro.message}`);\n  }\n}\n\n// Verificar se um caminho existe\nfunction caminhoExiste(caminho) {\n  return fs.existsSync(caminho);\n}\n\n// Formatar data no estilo brasileiro (dia de mês de ano)\nfunction formatarData(data) {\n  return moment(data).format('D [de] MMMM [de] YYYY');\n}\n\n// Remover acentos de uma string\nfunction removerAcentos(texto) {\n  return texto.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n}\n\n// Limpar string (remover caracteres especiais, espaços extras, etc.)\nfunction limparString(texto) {\n  if (!texto) return '';\n  \n  return texto\n    .replace(/\\s+/g, ' ')              // Substitui múltiplos espaços por um único\n    .replace(/[^\\w\\s\\-\\.,;:!?'\"()]/g, '') // Remove caracteres especiais (exceto pontuação básica)\n    .trim();                           // Remove espaços no início e fim\n}\n\n// Escapar caracteres especiais para regex\nfunction escaparRegex(texto) {\n  return texto.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// Gerar um ID único\nfunction gerarIdUnico() {\n  return Date.now().toString(36) + Math.random().toString(36).substring(2);\n}\n\n// Função para esperar um tempo determinado (útil para retry)\nfunction esperar(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Retry de uma função assíncrona\nasync function retryAsync(funcao, tentativas = 3, intervalo = 1000) {\n  let ultimoErro;\n  \n  for (let i = 0; i < tentativas; i++) {\n    try {\n      return await funcao();\n    } catch (erro) {\n      ultimoErro = erro;\n      logger.warn(`Tentativa ${i + 1}/${tentativas} falhou: ${erro.message}`);\n      \n      if (i < tentativas - 1) {\n        await esperar(intervalo);\n      }\n    }\n  }\n  \n  throw ultimoErro;\n}\n\nmodule.exports = {\n  logger,\n  criarDiretorios,\n  caminhoExiste,\n  formatarData,\n  removerAcentos,\n  limparString,\n  escaparRegex,\n  gerarIdUnico,\n  esperar,\n  retryAsync\n};"
    },
    {
      "path": "src\\whatsapp.js",
      "name": "whatsapp.js",
      "extension": ".js",
      "size": 14929,
      "last_modified": "2025-04-03T13:54:43.525038",
      "content": "// Módulo de conexão com WhatsApp usando Baileys (mais leve que Puppeteer)\n\nconst { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');\nconst qrcode = require('qrcode-terminal');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst { logger } = require('./utils');\nconst historicoMensagens = require('./historicoMensagens');\nconst { obterContatos, adicionarNovoContatoNaPlanilha } = require('./leitorContatos');\n\n// Cliente WhatsApp\nlet wa = null;\nlet clienteInicializado = false;\n\n// Importar o gerenciador de conversas\nconst conversasHandler = require('./conversasHandler');\n\n// Pasta para armazenar os dados de autenticação\nconst AUTH_FOLDER = process.env.WHATSAPP_SESSION_PATH || './whatsapp-session';\n\n// Configuração de presença\nconst TEMPO_ONLINE = 60000; // 1 minuto em milissegundos\nlet timerPresenca = null;\n\n// Função para definir o status como offline\nasync function definirOffline() {\n  try {\n    if (wa && clienteInicializado) {\n      // Definir o status como 'unavailable' (que mostra o \"visto por último\")\n      await wa.sendPresenceUpdate('unavailable', null);\n      logger.info('Status definido como offline (visto por último)');\n    }\n  } catch (erro) {\n    logger.error(`Erro ao definir status offline: ${erro.message}`);\n  }\n}\n\n// Função para gerenciar o status online\nasync function gerenciarPresenca() {\n  // Limpar o timer existente, se houver\n  if (timerPresenca) {\n    clearTimeout(timerPresenca);\n  }\n  \n  // Definir um novo timer para ficar offline após o tempo configurado\n  timerPresenca = setTimeout(definirOffline, TEMPO_ONLINE);\n}\n\n// Inicializar o cliente WhatsApp\nasync function iniciarCliente() {\n  try {\n    logger.info('Inicializando cliente WhatsApp usando Baileys...');\n    \n    // Garantir que a pasta de autenticação existe\n    if (!fs.existsSync(AUTH_FOLDER)) {\n      fs.mkdirSync(AUTH_FOLDER, { recursive: true });\n      logger.info(`Diretório de autenticação criado: ${AUTH_FOLDER}`);\n    }\n    \n    // Carregar estado de autenticação (se existir)\n    const { state, saveCreds } = await useMultiFileAuthState(AUTH_FOLDER);\n    \n    const nullLogger = {\n      child: () => nullLogger,\n      info: () => {},\n      warn: () => {},\n      error: () => {},\n      debug: () => {},\n      trace: () => {}\n    };\n\n    // Criar o socket WhatsApp\n    wa = makeWASocket({\n      auth: state,\n      printQRInTerminal: true,\n      defaultQueryTimeoutMs: 60000, // Timeout mais longo para Raspberry Pi\n      logger: nullLogger\n    });\n    \n    // Manipular eventos de conexão e mensagens\n    wa.ev.on('connection.update', async (update) => {\n      const { connection, lastDisconnect, qr } = update;\n      \n      if (qr) {\n        // Exibir QR code no terminal\n        logger.info('QR Code gerado. Escaneie-o com seu WhatsApp:');\n        qrcode.generate(qr, { small: true });\n      }\n      \n      if (connection === 'close') {\n        const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;\n        logger.warn(`Conexão fechada devido a ${lastDisconnect.error}. ${shouldReconnect ? 'Reconectando...' : 'Não será reconectado.'}`);\n        \n        clienteInicializado = false;\n        \n        if (shouldReconnect) {\n          // Tentar reconectar após um breve intervalo\n          setTimeout(iniciarCliente, 5000);\n        }\n      } else if (connection === 'open') {\n        logger.info('Cliente WhatsApp conectado com sucesso!');\n        clienteInicializado = true;\n        \n        // Definir como online inicialmente\n        await wa.sendPresenceUpdate('available', null);\n        // Iniciar o timer para ficar offline\n        gerenciarPresenca();\n      }\n    });\n    \n    // Salvar credenciais quando atualizadas\n    wa.ev.on('creds.update', saveCreds);\n    \n    // Manipular mensagens recebidas\n    wa.ev.on('messages.upsert', async (m) => {\n      if (m.type === 'notify') {\n        for (const msg of m.messages) {\n          // Processar apenas mensagens de outros (não enviadas por nós)\n          if (!msg.key.fromMe) {\n            await processarMensagemRecebida(msg);\n          }\n        }\n      }\n    });\n    \n    logger.info('Sistema de eventos do WhatsApp inicializado');\n    return wa;\n  } catch (erro) {\n    logger.error(`Erro ao inicializar cliente WhatsApp: ${erro.message}`);\n    logger.error(erro.stack);\n    throw erro;\n  }\n}\n\n// Processar mensagens recebidas\nasync function processarMensagemRecebida(msg) {\n  try {\n    \n    // Verificar se é uma mensagem de grupo\n    if (msg.key.remoteJid.includes('@g.us')) {\n      return; // Ignorar mensagens de grupos\n    }\n    \n    // Obter informações do remetente\n    const remetente = msg.key.remoteJid;\n    const telefone = remetente.split('@')[0];\n    \n    // Verificar se não é uma mensagem muito antiga\n    const timestampMensagem = msg.messageTimestamp * 1000;\n    const agora = Date.now();\n    const diffMinutos = (agora - timestampMensagem) / (1000 * 60);\n    \n    if (diffMinutos > 10) {\n      logger.info(`Ignorando mensagem antiga (${Math.floor(diffMinutos)} minutos atrás)`);\n      return;\n    }\n\n    // Ao receber uma mensagem, definir como online\n    await wa.sendPresenceUpdate('available', remetente);\n    gerenciarPresenca(); // Iniciar o timer para ficar offline\n\n    // Carregar histórico de conversa\n    const caminhoArquivo = path.join(process.env.CONVERSAS_DIR || './Conversas', `${telefone}.json`);\n    let devocionalJaEnviado = false;\n    \n    if (fs.existsSync(caminhoArquivo)) {\n      try {\n        const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n        const historico = JSON.parse(conteudo);\n        \n        // Verificar se já enviamos um devocional\n        devocionalJaEnviado = historico && historico.ultimoDevocional;\n        \n        logger.info(`Usuário ${telefone}: ${devocionalJaEnviado ? 'já recebeu devocional' : 'ainda não recebeu devocional'}`);\n      } catch (erroLeitura) {\n        logger.error(`Erro ao ler histórico para ${telefone}: ${erroLeitura.message}`);\n      }\n    } else {\n      logger.info(`Nenhum histórico encontrado para ${telefone}, enviando devocional de boas-vindas`);\n    }\n\n    if (!devocionalJaEnviado) {\n      logger.info(`Primeira interação detectada para o número ${telefone}`);\n    \n      // Adicionar o novo contato à Planilha\n      try {\n        // Tenta extrair o nome do contato\n        let nomeContato = \"Novo Contato\";\n        \n        // Tente pelo pushName que pode estar disponível na própria mensagem\n        if (msg.pushName) {\n          nomeContato = msg.pushName;\n        }\n        // Ou pelo objeto key da mensagem\n        else if (msg.key && msg.key.pushName) {\n          nomeContato = msg.key.pushName;\n        }\n        \n        // Adicionar à Planilha\n        await adicionarNovoContatoNaPlanilha(telefone, nomeContato);\n        logger.info(`Contato ${telefone} (${nomeContato}) adicionado à planilha de contatos`);\n      } catch (erroContato) {\n        logger.error(`Erro ao adicionar contato à planilha: ${erroContato.message}`);\n      }\n      \n      // Buscar o último devocional enviado hoje\n      const devocionalHoje = await historicoMensagens.obterUltimoDevocionalEnviado();\n      if (devocionalHoje) {\n        \n        // Enviar mensagem de boas-vindas\n        await wa.sendMessage(remetente, { \n          text: \"Olá 😀! Seja bem-vindo(a) ao Whatsapp Devocional-IA. Aqui está o devocional de hoje:\" \n        });\n        \n        // Pequena pausa\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        \n        // Enviar o devocional\n        await wa.sendMessage(remetente, { text: devocionalHoje });\n        \n        // Registrar o devocional enviado para este contato\n        await conversasHandler.registrarDevocionalEnviado(telefone, devocionalHoje);\n        logger.info(`Devocional do dia enviado para novo contato: ${telefone}`);\n        return;\n      } else {\n        logger.warn(`Não foi possível encontrar um devocional para enviar ao novo contato ${telefone}`);\n      }\n    }\n    \n    // Verificar o tipo de mensagem\n    const messageType = Object.keys(msg.message || {})[0];\n    \n    // Processar áudio\n    if (['audioMessage', 'pttMessage'].includes(messageType)) {\n      logger.info(`Áudio recebido de ${telefone}, respondendo com mensagem padrão`);\n      \n      // Mensagens gentis e educadas para responder a áudios\n      const mensagensAudio = [\n        \"Olá! Recebi seu áudio, mas ainda não consigo processá-lo. Você poderia, por gentileza, enviar sua pergunta ou comentário como mensagem de texto? Assim poderei lhe ajudar melhor. 🙏\",\n        \"Agradeço pelo seu áudio! No momento, não disponho da capacidade de ouvi-lo. Poderia, por favor, compartilhar seu pensamento ou pergunta em forma de texto? Ficarei feliz em responder!\",\n        \"Recebi sua mensagem de voz! Infelizmente, ainda não consigo compreender áudios. Se puder enviar o mesmo conteúdo em texto, será um prazer conversar sobre o devocional de hoje ou qualquer outro assunto espiritual.\"\n      ];\n      \n      // Escolher uma mensagem aleatoriamente\n      const respostaAudio = mensagensAudio[Math.floor(Math.random() * mensagensAudio.length)];\n      \n      // Indicar que está digitando (simulando digitação)\n      await wa.sendPresenceUpdate('composing', remetente);\n      \n      // Pequena pausa para simular digitação (entre 1-3 segundos)\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n      \n      // Enviar a resposta\n      await wa.sendMessage(remetente, { text: respostaAudio });\n      logger.info(`Resposta para áudio enviada para ${telefone}`);\n      \n      // Reiniciar o timer de presença\n      gerenciarPresenca();\n      return;\n    }\n    \n    // Extrair o conteúdo da mensagem de texto\n    let conteudo = '';\n    \n    if (messageType === 'conversation') {\n      conteudo = msg.message.conversation;\n    } else if (messageType === 'extendedTextMessage') {\n      conteudo = msg.message.extendedTextMessage.text;\n    } else {\n      // Outros tipos de mensagem (imagem, vídeo, etc.)\n      conteudo = \"Mídia recebida\";\n    }\n    \n    logger.info(`Mensagem recebida de ${telefone}: ${conteudo.substring(0, 50)}${conteudo.length > 50 ? '...' : ''}`);\n    \n    // Verificar se a mensagem precisa de resposta\n    if (conversasHandler.ePergunta(conteudo) || conteudo.length >= 10) {\n      logger.info(`Gerando resposta para mensagem de ${telefone}...`);\n      \n      // Indicar que está digitando (simulando digitação)\n      await wa.sendPresenceUpdate('composing', remetente);\n      \n      // Gerar a resposta\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\n      \n      // Calcular tempo de digitação baseado no tamanho da resposta\n      // Média de digitação: cerca de 5 caracteres por segundo (ajuste conforme necessário)\n      const tempoDigitacao = Math.min(Math.max(resposta.length / 5 * 1000, 2000), 8000);\n      \n      // Simular tempo de digitação\n      await new Promise(resolve => setTimeout(resolve, tempoDigitacao));\n      \n      // Parar de \"digitar\"\n      await wa.sendPresenceUpdate('paused', remetente);\n      \n      // Pequena pausa antes de enviar (como se estivesse revisando)\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Enviar a resposta\n      await wa.sendMessage(remetente, { text: resposta });\n      \n      logger.info(`Resposta enviada para ${telefone}`);\n    } else {\n      logger.info(`Mensagem curta, enviando resposta simples`);\n      \n      // Indicar que está digitando\n      await wa.sendPresenceUpdate('composing', remetente);\n      \n      // Para mensagens curtas ou agradecimentos, enviar uma resposta simples\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\n      \n      // Simular digitação rápida (1-3 segundos)\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n      \n      // Enviar resposta\n      await wa.sendMessage(remetente, { text: resposta });\n    }\n    \n    // Reiniciar o timer de presença após enviar mensagem\n    gerenciarPresenca();\n  } catch (erro) {\n    logger.error(`Erro ao processar mensagem recebida: ${erro.message}`);\n    try {\n      // Tentar enviar uma mensagem de erro para o usuário\n      await wa.sendMessage(msg.key.remoteJid, { \n        text: \"Desculpe, ocorreu um erro ao processar sua mensagem. Por favor, tente novamente mais tarde.\" \n      });\n    } catch (erroEnvio) {\n      logger.error(`Erro ao enviar mensagem de erro: ${erroEnvio.message}`);\n    }\n  }\n}\n\n// Verificar se o cliente está pronto\nfunction clientePronto() {\n  return wa !== null && clienteInicializado;\n}\n\n// Enviar mensagem para um contato\nasync function enviarMensagem(telefone, mensagem) {\n  try {\n    if (!clientePronto()) {\n      throw new Error('Cliente WhatsApp não está pronto');\n    }\n    \n    // Formatar o número de telefone (remover caracteres não numéricos)\n    const numeroFormatado = telefone.toString().replace(/\\D/g, '');\n    \n    // Garantir que o número tenha o formato correto para o WhatsApp\n    const chatId = `${numeroFormatado}@s.whatsapp.net`;\n    \n    // Definir como online ao enviar mensagem\n    await wa.sendPresenceUpdate('available', chatId);\n    \n    // Enviar a mensagem\n    await wa.sendMessage(chatId, { text: mensagem });\n    \n    // Iniciar o timer para ficar offline\n    gerenciarPresenca();\n    \n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao enviar mensagem: ${erro.message}`);\n    throw erro;\n  }\n}\n\n// Encerrar o cliente\nasync function encerrarCliente() {\n  try {\n    if (wa) {\n      // Definir como offline antes de desconectar\n      try {\n        await definirOffline();\n      } catch (erroPresenca) {\n        logger.warn(`Erro ao definir offline antes de encerrar: ${erroPresenca.message}`);\n      }\n      \n      // Limpar o timer de presença\n      if (timerPresenca) {\n        clearTimeout(timerPresenca);\n        timerPresenca = null;\n      }\n      \n      // Não há um método específico para \"destruir\" no Baileys,\n      // mas podemos remover os listeners e limpar referências\n      wa.ev.removeAllListeners();\n      wa = null;\n      clienteInicializado = false;\n      logger.info('Cliente WhatsApp encerrado');\n    }\n  } catch (erro) {\n    logger.error(`Erro ao encerrar cliente WhatsApp: ${erro.message}`);\n  }\n}\n\nmodule.exports = {\n  iniciarCliente,\n  clientePronto,\n  enviarMensagem,\n  encerrarCliente,\n};"
    },
    {
      "path": "Tutoriais\\Deploy.md",
      "name": "Deploy.md",
      "extension": ".md",
      "size": 5617,
      "last_modified": "2025-04-03T13:54:43.498753",
      "content": "# README - Comandos Linux para Deploy e Manutenção do WhatsApp Devocional\n\nEste documento detalha todos os comandos Linux necessários para configurar, implantar e manter o sistema WhatsApp Devocional em um servidor Raspberry Pi/DietPi.\n\n## Índice\n1. [Instalação de Pré-requisitos](#1-instalação-de-pré-requisitos)\n2. [Configuração do Projeto](#2-configuração-do-projeto)\n3. [Configuração do Serviço Systemd](#3-configuração-do-serviço-systemd)\n4. [Gerenciamento de Permissões](#4-gerenciamento-de-permissões)\n5. [Gerenciamento do Serviço](#5-gerenciamento-do-serviço)\n6. [Visualização de Logs](#6-visualização-de-logs)\n7. [Manutenção do Sistema](#7-manutenção-do-sistema)\n8. [Solução de Problemas](#8-solução-de-problemas)\n\n## 1. Instalação de Pré-requisitos\n\n### Atualizar o sistema\n```bash\nsudo apt update\nsudo apt upgrade -y\n```\n\n### Instalar o Node.js\n```bash\n# Instalar o Node.js (recomendado versão LTS)\ncurl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -\nsudo apt install -y nodejs\n```\n\n### Instalar as dependências essenciais\n```bash\nsudo apt install -y git\n```\n\n## 2. Configuração do Projeto\n\n### Clonar/Preparar o Projeto\n```bash\n# Criar diretório para o projeto\nmkdir -p /home/dietpi/Node.js\ncd /home/dietpi/Node.js\n\n# Instalar dependências do projeto\nnpm install\n```\n\n### Criar diretórios necessários e ajustar permissões iniciais\n```bash\n# Criar diretórios de sistema\nmkdir -p Conversas\nmkdir -p Histórico\nmkdir -p whatsapp-session\nmkdir -p Base_de_conhecimento\nmkdir -p Contatos\n\n# Ajustar permissões iniciais\nchmod -R 755 /home/dietpi/Node.js/\n```\n\n## 3. Configuração do Serviço Systemd\n\n### Criar o arquivo de serviço\n```bash\nsudo nano /etc/systemd/system/whatsapp-devocional.service\n```\n\n### Conteúdo do arquivo de serviço\n```ini\n[Unit]\nDescription=WhatsApp Devocional Service\nAfter=network.target\n\n[Service]\nType=simple\nUser=dietpi\nGroup=dietpi\nWorkingDirectory=/home/dietpi/Node.js\nExecStart=/usr/local/bin/npm start\nRestart=on-failure\nRestartSec=10\nStandardOutput=syslog\nStandardError=syslog\nSyslogIdentifier=whatsapp-devocional\nEnvironment=NODE_ENV=production\n\n[Install]\nWantedBy=multi-user.target\n```\n\n### Recarregar o daemon do systemd\n```bash\nsudo systemctl daemon-reload\n```\n\n### Habilitar o serviço para iniciar na inicialização\n```bash\nsudo systemctl enable whatsapp-devocional.service\n```\n\n## 4. Gerenciamento de Permissões\n\n### Configurar permissões corretas para todos os diretórios do projeto\n```bash\n# Tornar o usuário dietpi proprietário de todos os arquivos\nsudo chown -R dietpi:dietpi /home/dietpi/Node.js/\n\n# Definir permissões para diretórios que precisam de escrita\nsudo chmod -R 777 /home/dietpi/Node.js/Conversas/\nsudo chmod -R 777 /home/dietpi/Node.js/whatsapp-session/\nsudo chmod -R 777 /home/dietpi/Node.js/Histórico/\nsudo chmod -R 777 /home/dietpi/Node.js/temp_audio/\n```\n\n## 5. Gerenciamento do Serviço\n\n### Iniciar o serviço\n```bash\nsudo systemctl start whatsapp-devocional.service\n```\n\n### Verificar status do serviço\n```bash\nsudo systemctl status whatsapp-devocional.service\n```\n\n### Parar o serviço\n```bash\nsudo systemctl stop whatsapp-devocional.service\n```\n\n### Reiniciar o serviço\n```bash\nsudo systemctl restart whatsapp-devocional.service\n```\n\n### Recarregar configuração sem reiniciar\n```bash\nsudo systemctl reload whatsapp-devocional.service\n```\n\n## 6. Visualização de Logs\n\n### Ver logs do serviço em tempo real\n```bash\nsudo journalctl -u whatsapp-devocional.service -f\n```\n\n### Ver logs do serviço com timestamps\n```bash\nsudo journalctl -u whatsapp-devocional.service --no-pager\n```\n\n### Ver logs das últimas 100 linhas\n```bash\nsudo journalctl -u whatsapp-devocional.service -n 100\n```\n\n### Ver logs desde a última inicialização\n```bash\nsudo journalctl -u whatsapp-devocional.service -b\n```\n\n### Ver logs de um período específico\n```bash\nsudo journalctl -u whatsapp-devocional.service --since \"2025-04-02 12:00:00\" --until \"2025-04-02 14:00:00\"\n```\n\n## 7. Manutenção do Sistema\n\n### Verificar espaço em disco\n```bash\ndf -h\n```\n\n### Verificar uso de memória\n```bash\nfree -h\n```\n\n### Verificar processos em execução\n```bash\nhtop  # Instale com: sudo apt install htop\n```\n\n### Verificar conexões de rede\n```bash\nnetstat -tuln\n```\n\n### Configurar reinicialização automática semanal (bom para limpeza de memória)\n```bash\nsudo crontab -e\n```\nAdicione esta linha para reiniciar todo domingo às 4h da manhã:\n```\n0 4 * * 0 /sbin/reboot\n```\n\n## 8. Solução de Problemas\n\n### Se o serviço não iniciar\nVerifique primeiro os logs:\n```bash\nsudo journalctl -u whatsapp-devocional.service -n 50\n```\n\n### Verificar se o Node.js está funcionando corretamente\n```bash\nnode -v\nnpm -v\n```\n\n### Verificar permissões dos arquivos críticos\n```bash\nls -la /home/dietpi/Node.js/whatsapp-session/\nls -la /home/dietpi/Node.js/Conversas/\n```\n\n### Corrigir permissões novamente se necessário\n```bash\nsudo chown -R dietpi:dietpi /home/dietpi/Node.js/\nsudo chmod -R 777 /home/dietpi/Node.js/Conversas/\nsudo chmod -R 777 /home/dietpi/Node.js/whatsapp-session/\n```\n\n### Reiniciar o sistema em último caso\n```bash\nsudo reboot\n```\n\n---\n\nEste documento cobre os comandos essenciais para o gerenciamento do WhatsApp Devocional em um servidor Linux. Consulte este guia sempre que precisar realizar manutenção ou solucionar problemas no sistema."
    }
  ]
}