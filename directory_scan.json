{
  "metadata": {
    "created_at": "2025-04-03T16:32:12.236916",
    "root_directory": "C:\\Users\\Bruno Martins\\Desktop\\Projetos Pessoais\\Node.js\\Em Produ√ß√£o\\whatsapp-devocional-IA",
    "excluded_paths": [
      "node_modules",
      ".venv",
      ".wwebjs_auth",
      ".wwebjs_cache",
      "Base_de_conhecimento",
      "whatsapp-session",
      "Conversas",
      "Contatos",
      ".env",
      "exclusion.txt",
      "package-lock.json",
      "app.py"
    ],
    "excluded_patterns": [
      "*.log",
      "*.tmp",
      "temp/*",
      "__pycache__/**"
    ]
  },
  "files": [
    {
      "path": "directory_scan.json",
      "name": "directory_scan.json",
      "extension": ".json",
      "size": 97624,
      "last_modified": "2025-04-03T16:28:53.159074",
      "content": "{\n  \"files\": [\n    {\n      \"path\": \"package.json\",\n      \"name\": \"package.json\",\n      \"extension\": \".json\",\n      \"size\": 906,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"{\\n  \\\"name\\\": \\\"whatsapp-devocional-ia\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"Bot de WhatsApp que envia mensagens devocionais di√°rias geradas por IA e responde a perguntas\\\",\\n  \\\"main\\\": \\\"src/index.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"NODE_OPTIONS=\\\\\\\"--max-old-space-size=512\\\\\\\" node src/index.js\\\",\\n    \\\"test:devocional\\\": \\\"node scripts/testar_devocional.js\\\",\\n    \\\"test:conversas\\\": \\\"node scripts/testar_conversas.js\\\",\\n    \\\"setup:contatos\\\": \\\"node scripts/criar_exemplo_contato.js\\\"\\n  },\\n  \\\"dependencies\\\": {\\n    \\\"@google/generative-ai\\\": \\\"^0.1.1\\\",\\n    \\\"@whiskeysockets/baileys\\\": \\\"^6.6.0\\\",\\n    \\\"cheerio\\\": \\\"^1.0.0-rc.12\\\",\\n    \\\"csv-parser\\\": \\\"^3.0.0\\\",\\n    \\\"dotenv\\\": \\\"^16.0.3\\\",\\n    \\\"fs-extra\\\": \\\"^11.1.0\\\",\\n    \\\"jimp\\\": \\\"^0.16.13\\\",\\n    \\\"moment\\\": \\\"^2.29.4\\\",\\n    \\\"node-schedule\\\": \\\"^2.1.1\\\",\\n    \\\"pdf-parse\\\": \\\"^1.1.1\\\",\\n    \\\"qrcode-terminal\\\": \\\"^0.12.0\\\",\\n    \\\"sharp\\\": \\\"^0.33.2\\\",\\n    \\\"xlsx\\\": \\\"^0.18.5\\\"\\n  }\\n}\"\n    },\n    {\n      \"path\": \"README.md\",\n      \"name\": \"README.md\",\n      \"extension\": \".md\",\n      \"size\": 7771,\n      \"last_modified\": \"2025-04-03T13:54:43.498753\",\n      \"content\": \"## Funcionalidade de Di√°logo Interativo\\n\\nEsta vers√£o do sistema inclui suporte para di√°logo individualizado com os usu√°rios:\\n\\n### Como funciona:\\n\\n1. **Envio do Devocional**: O sistema envia automaticamente o devocional di√°rio para todos os contatos cadastrados no hor√°rio programado.\\n\\n2. **Recebimento de Mensagens**: Quando um usu√°rio responde ou faz uma pergunta sobre o devocional, o sistema:\\n   - Analisa se a mensagem requer uma resposta elaborada\\n   - Usa a IA para gerar uma resposta personalizada considerando:\\n     - O devocional enviado recentemente\\n     - O hist√≥rico de conversa com aquele usu√°rio espec√≠fico\\n     - A base de conhecimento religiosa\\n\\n3. **Contexto Individualizado**: O sistema mant√©m hist√≥ricos de conversa separados para cada usu√°rio, permitindo:\\n   - Respostas personalizadas\\n   - Refer√™ncias a mensagens anteriores da mesma conversa\\n   - Continuidade no di√°logo\\n\\n### Configura√ß√µes:\\n\\nNo arquivo `.env` voc√™ pode ajustar:\\n\\n- `RESPONDER_AUTOMATICAMENTE=true` - Ativar/desativar resposta autom√°tica\\n- `MAX_HISTORICO_CONVERSAS=10` - N√∫mero de mensagens armazenadas por conversa\\n\\n### Limita√ß√µes:\\n\\n- O sistema foi projetado para responder a perguntas relacionadas ao devocional\\n- Mensagens curtas ou simples recebem respostas padr√£o mais breves\\n- A IA foi instru√≠da a manter um tom amig√°vel, acolhedor e espiritual# WhatsApp Devocional Di√°rio com IA\\n\\nUm bot de WhatsApp automatizado que envia mensagens devocionais di√°rias geradas por IA para uma lista de contatos pr√©-definida.\\n\\n## Testes e Exemplos\\n\\nO sistema inclui scripts de teste para verificar componentes individuais:\\n\\n### Testar gera√ß√£o de devocionais:\\n\\n```bash\\nnode scripts/testar_devocional.js\\n```\\n\\nEste script gera um devocional usando a API do Google Gemini e sua base de conhecimento, sem enviar mensagens para os contatos. O resultado √© exibido no console e salvo no arquivo `scripts/devocional_gerado.txt`.\\n\\n### Criar arquivo de contatos de exemplo:\\n\\n```bash\\nnode scripts/criar_exemplo_contatos.js\\n```\\n\\nEste script cria um arquivo Excel com contatos de exemplo na pasta `Contatos/` que voc√™ pode usar como refer√™ncia para o formato correto.\\n\\n### Testar sistema de conversas com IA:\\n\\n```bash\\nnode scripts/testar_conversas.js\\n```\\n\\nEste script simula uma conversa interativa entre um usu√°rio e o bot, permitindo testar como o sistema responde a perguntas sobre o devocional enviado. Voc√™ pode digitar mensagens como se fosse um usu√°rio e ver as respostas geradas pela IA. Caracter√≠sticas\\n\\n- ü§ñ Integra√ß√£o com o Google Gemini para gera√ß√£o de conte√∫do devocional\\n- üì± Envio autom√°tico de mensagens via WhatsApp\\n- üí¨ **Di√°logo individualizado com usu√°rios atrav√©s de IA generativa**\\n- üìä Suporte para leitura de contatos de arquivos Excel e CSV\\n- üìö Base de conhecimento personaliz√°vel com suporte para diversos formatos de arquivo\\n- üìÖ Agendamento di√°rio autom√°tico\\n- üìù Registro de hist√≥rico para evitar repeti√ß√£o de vers√≠culos\\n- üß© Arquitetura modular para f√°cil manuten√ß√£o e extens√£o\\n\\n## Requisitos\\n\\n- Node.js (v14 ou superior)\\n- Acesso √† API do Google Gemini (chave de API)\\n- Um dispositivo ou servidor para executar o bot\\n\\n## Estrutura do Projeto\\n\\n```\\nüìÅ WhatsApp-Devocional-IA/\\n‚îú‚îÄ‚îÄ üìÅ Base_de_conhecimento/     # Coloque aqui seus documentos de refer√™ncia\\n‚îú‚îÄ‚îÄ üìÅ Contatos/                 # Coloque aqui suas planilhas de contatos\\n‚îú‚îÄ‚îÄ üìÅ Conversas/                # Armazena hist√≥ricos de conversas individuais\\n‚îú‚îÄ‚îÄ üìÅ Hist√≥rico/                # Hist√≥rico de mensagens enviadas\\n‚îÇ   ‚îî‚îÄ‚îÄ üìÑ historico.json        # Registro autom√°tico dos envios\\n‚îú‚îÄ‚îÄ üìÅ src/                      # C√≥digo fonte do sistema\\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ index.js              # Ponto de entrada da aplica√ß√£o\\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ whatsapp.js           # M√≥dulo de conex√£o com WhatsApp\\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ geradorDevocional.js  # M√≥dulo gerador de devocionais com IA\\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ leitorDocumentos.js   # M√≥dulo para processamento dos documentos base\\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ leitorContatos.js     # M√≥dulo para leitura da lista de contatos\\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ historicoMensagens.js # M√≥dulo para gerenciamento do hist√≥rico\\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ conversasHandler.js   # M√≥dulo para di√°logo individualizado com IA\\n‚îÇ   ‚îî‚îÄ‚îÄ üìÑ utils.js              # Fun√ß√µes utilit√°rias\\n‚îú‚îÄ‚îÄ üìÅ scripts/                  # Scripts de teste e utilit√°rios\\n‚îú‚îÄ‚îÄ üìÑ package.json              # Depend√™ncias do projeto\\n‚îú‚îÄ‚îÄ üìÑ .env                      # Configura√ß√µes do projeto\\n‚îî‚îÄ‚îÄ üìÑ README.md                 # Esta documenta√ß√£o\\n```\\n\\n## Configura√ß√£o\\n\\n1. Clone este reposit√≥rio\\n2. Execute `npm install` para instalar as depend√™ncias\\n3. Copie o arquivo `.env.example` para `.env` e configure:\\n   - Chave de API do Google Gemini\\n   - Hor√°rio de envio das mensagens\\n   - Outras configura√ß√µes conforme necess√°rio\\n4. Adicione seus documentos de refer√™ncia √† pasta `Base_de_conhecimento`\\n5. Adicione sua lista de contatos √† pasta `Contatos` (em formato Excel ou CSV)\\n\\n### Formato da Planilha de Contatos\\n\\nA planilha deve conter pelo menos as seguintes colunas:\\n- `Nome`: Nome do contato\\n- `Telefone`: N√∫mero de telefone com c√≥digo do pa√≠s (ex: 5511987654321)\\n- `Ativo`: Opcional, para indicar se o contato deve receber mensagens (Sim/N√£o)\\n\\n## Uso\\n\\nPara iniciar o bot:\\n\\n```bash\\nnpm start\\n```\\n\\nNa primeira execu√ß√£o, ser√° exibido um QR Code que deve ser escaneado com o WhatsApp do seu celular para autenticar a sess√£o.\\n\\n##\\n\\n## Base de Conhecimento\\n\\nA pasta `Base_de_conhecimento` aceita os seguintes formatos de arquivo:\\n- PDF (.pdf)\\n- Texto simples (.txt)\\n- JSON (.json)\\n- Excel (.xlsx)\\n- CSV (.csv)\\n\\nEstes documentos ser√£o utilizados como refer√™ncia para a IA gerar os devocionais di√°rios.\\n\\n## Personaliza√ß√£o\\n\\nPara personalizar o formato dos devocionais, edite o arquivo `src/geradorDevocional.js`.\\n\\n## Manuten√ß√£o\\n\\nO sistema mant√©m um hist√≥rico de mensagens enviadas para evitar repeti√ß√£o de vers√≠culos. Este hist√≥rico √© armazenado em `Hist√≥rico/historico.json`.\\n\\n## Solu√ß√£o de Problemas\\n\\n### Cliente do WhatsApp n√£o conecta\\n- Verifique se n√£o h√° outra sess√£o do WhatsApp Web ativa\\n- Apague a pasta `whatsapp-session` e reinicie o sistema\\n- Certifique-se de escanear o QR code quando solicitado\\n\\n### Erros na gera√ß√£o do devocional\\n- Verifique se a chave de API do Google Gemini est√° correta no arquivo `.env`\\n- Certifique-se de usar o nome correto do modelo na API (gemini-1.5-pro ou gemini-pro)\\n- Verifique se h√° documentos v√°lidos na pasta `Base_de_conhecimento`\\n- Execute o script de teste `scripts/testar_devocional.js` para verificar se a gera√ß√£o funciona\\n\\n### Problemas com contatos\\n- Verifique se o arquivo de contatos est√° no formato correto (Excel ou CSV)\\n- Certifique-se de que os contatos tenham pelo menos uma coluna chamada \\\"Nome\\\" e outra \\\"Telefone\\\"\\n- Confirme que os n√∫meros de telefone est√£o completos com c√≥digo do pa√≠s (ex: 5511987654321)\\n- Use o arquivo de exemplo `contatos_exemplo.xlsx` como refer√™ncia\\n- Para diagn√≥stico, verifique os logs detalhados que mostram como os contatos est√£o sendo processados\\n\\n### Erros no hist√≥rico de mensagens\\n- Se ocorrerem erros relacionados ao hist√≥rico, verifique se o arquivo `historico.json` existe e tem o formato correto\\n- Em caso de problemas persistentes, exclua o arquivo `Hist√≥rico/historico.json` e deixe o sistema recri√°-lo automaticamente\\n\\n## Licen√ßa\\n\\nEste projeto est√° licenciado sob a Licen√ßa MIT - veja o arquivo LICENSE para detalhes.\"\n    },\n    {\n      \"path\": \"scripts\\\\criar_exemplo_contato.js\",\n      \"name\": \"criar_exemplo_contato.js\",\n      \"extension\": \".js\",\n      \"size\": 1594,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// Script para criar um arquivo de exemplo de contatos\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\n\\n// Diret√≥rio e arquivo\\nconst CONTATOS_DIR = '../Contatos';\\nconst ARQUIVO_EXEMPLO = path.join(CONTATOS_DIR, 'contatos_exemplo.xlsx');\\n\\n// Garantir que o diret√≥rio exista\\nif (!fs.existsSync(CONTATOS_DIR)) {\\n  fs.mkdirSync(CONTATOS_DIR, { recursive: true });\\n  console.log(`Diret√≥rio criado: ${CONTATOS_DIR}`);\\n}\\n\\n// Dados de exemplo\\nconst contatos = [\\n  { \\n    Nome: 'Jo√£o Silva', \\n    Telefone: '5511987654321', \\n    Ativo: 'Sim',\\n    Observacoes: 'Contato principal'\\n  },\\n  { \\n    Nome: 'Maria Oliveira', \\n    Telefone: '5521998765432', \\n    Ativo: 'Sim',\\n    Observacoes: 'Contato secund√°rio'\\n  },\\n  { \\n    Nome: 'Pedro Santos', \\n    Telefone: '5531987654321', \\n    Ativo: 'N√£o',\\n    Observacoes: 'Desativado temporariamente'\\n  },\\n  { \\n    Nome: 'Ana Costa', \\n    Telefone: '5541999887766', \\n    Ativo: 'Sim',\\n    Observacoes: 'Novo contato'\\n  },\\n  { \\n    Nome: 'Carlos Pereira', \\n    Telefone: '5551988776655', \\n    Ativo: 'Sim',\\n    Observacoes: ''\\n  }\\n];\\n\\n// Criar workbook e adicionar dados\\nconst workbook = xlsx.utils.book_new();\\nconst worksheet = xlsx.utils.json_to_sheet(contatos);\\n\\n// Adicionar a planilha ao workbook\\nxlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\\n\\n// Salvar o arquivo\\nxlsx.writeFile(workbook, ARQUIVO_EXEMPLO);\\n\\nconsole.log(`Arquivo de exemplo criado: ${ARQUIVO_EXEMPLO}`);\\nconsole.log('Modelo de contatos:');\\nconsole.table(contatos);\"\n    },\n    {\n      \"path\": \"scripts\\\\testar_devocional.js\",\n      \"name\": \"testar_devocional.js\",\n      \"extension\": \".js\",\n      \"size\": 3225,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// Script para testar o sistema de conversas individualizadas com IA\\n\\nrequire('dotenv').config({ path: '../.env' });\\nconst moment = require('moment');\\nmoment.locale('pt-br');\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst readline = require('readline');\\n\\n// Configurar o ambiente para execu√ß√£o independente\\nprocess.env.BASE_CONHECIMENTO_DIR = path.resolve(__dirname, '../Base_de_conhecimento');\\nprocess.env.CONVERSAS_DIR = path.resolve(__dirname, '../Conversas');\\n\\n// Importar m√≥dulos\\nconst conversasHandler = require('../src/conversasHandler');\\nconst { formatarData, logger } = require('../src/utils');\\n\\n// Configurar interface de linha de comando\\nconst rl = readline.createInterface({\\n  input: process.stdin,\\n  output: process.stdout\\n});\\n\\n// Telefone de teste\\nconst TELEFONE_TESTE = '5511999999999';\\n\\n// Devocional de exemplo para contextualizar a conversa\\nconst devocionalExemplo = `${formatarData(new Date())}\\n\\nVers√≠culo: \\\"N√£o andeis ansiosos por coisa alguma; antes em tudo sejam os vossos pedidos conhecidos diante de Deus pela ora√ß√£o e s√∫plica com a√ß√µes de gra√ßas. E a paz de Deus, que excede todo entendimento, guardar√° os vossos cora√ß√µes e as vossas mentes em Cristo Jesus.\\\" (Filipenses 4:6-7)\\n\\nReflex√£o: A ansiedade tem sido um desafio comum em nossos dias. Este vers√≠culo nos lembra que podemos trazer todas as nossas preocupa√ß√µes a Deus atrav√©s da ora√ß√£o. Quando escolhemos confiar nEle ao inv√©s de nos sobrecarregarmos com preocupa√ß√µes, experimentamos uma paz que vai al√©m da compreens√£o humana. √â uma promessa poderosa para nossos momentos de inquieta√ß√£o.\\n\\nPr√°tica: Hoje, quando sentir ansiedade surgindo, fa√ßa uma pausa para respirar e apresente a situa√ß√£o a Deus em ora√ß√£o, agradecendo antecipadamente por Sua interven√ß√£o.`;\\n\\n// Fun√ß√£o para inicializar a conversa\\nasync function iniciarConversa() {\\n  console.log('=== TESTE DO SISTEMA DE CONVERSAS ===\\\\n');\\n  console.log('Simulando uma conversa individualizada com o bot\\\\n');\\n  \\n  // Registrar o devocional de exemplo\\n  await conversasHandler.registrarDevocionalEnviado(TELEFONE_TESTE, devocionalExemplo);\\n  \\n  console.log('Devocional enviado hoje:');\\n  console.log(devocionalExemplo);\\n  console.log('\\\\n-------------------------------------------\\\\n');\\n  console.log('Digite suas mensagens como se fosse um usu√°rio respondendo ao devocional.');\\n  console.log('Digite \\\"sair\\\" para encerrar o teste.\\\\n');\\n  \\n  perguntarUsuario();\\n}\\n\\n// Fun√ß√£o para processar a entrada do usu√°rio\\nfunction perguntarUsuario() {\\n  rl.question('Voc√™: ', async (mensagem) => {\\n    if (mensagem.toLowerCase() === 'sair') {\\n      console.log('\\\\nEncerrando teste...');\\n      rl.close();\\n      return;\\n    }\\n    \\n    console.log('\\\\nProcessando mensagem...');\\n    \\n    try {\\n      // Gerar resposta do bot\\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(TELEFONE_TESTE, mensagem);\\n      \\n      console.log(`\\\\nBot: ${resposta}\\\\n`);\\n    } catch (erro) {\\n      console.error('Erro ao gerar resposta:', erro.message);\\n    }\\n    \\n    // Continuar a conversa\\n    perguntarUsuario();\\n  });\\n}\\n\\n// Iniciar o teste\\niniciarConversa();\"\n    },\n    {\n      \"path\": \"src\\\\adicionarContato.js\",\n      \"name\": \"adicionarContato.js\",\n      \"extension\": \".js\",\n      \"size\": 8492,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// M√≥dulo para adicionar novos contatos √† planilha\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\nconst csvParser = require('csv-parser');\\nconst { logger } = require('./utils');\\n\\n// Diret√≥rio de contatos\\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\\n\\n// Obter a lista de arquivos de contatos dispon√≠veis\\nfunction obterArquivosContatos() {\\n  try {\\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\\n    return arquivos.filter(arquivo => {\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      return extensao === '.xlsx' || extensao === '.csv';\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao ler diret√≥rio de contatos: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Adicionar novo contato √† planilha\\nasync function adicionarNovoContatoNaPlanilha(telefone, nomeContato = \\\"Novo Contato\\\") {\\n  try {\\n    const arquivos = obterArquivosContatos();\\n    \\n    if (arquivos.length === 0) {\\n      logger.warn('Nenhum arquivo de contatos encontrado. Criando novo arquivo.');\\n      return criarNovoArquivoContatos(telefone, nomeContato);\\n    }\\n    \\n    // Usar o primeiro arquivo encontrado (normalmente contatos_exemplo.xlsx)\\n    const arquivoContatos = path.join(CONTATOS_DIR, arquivos[0]);\\n    const extensao = path.extname(arquivoContatos).toLowerCase();\\n    \\n    // Verificar se √© Excel ou CSV\\n    if (extensao === '.xlsx') {\\n      return adicionarContatoExcel(arquivoContatos, telefone, nomeContato);\\n    } else if (extensao === '.csv') {\\n      return adicionarContatoCsv(arquivoContatos, telefone, nomeContato);\\n    } else {\\n      logger.error(`Formato de arquivo n√£o suportado: ${extensao}`);\\n      return false;\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao adicionar novo contato ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Adicionar contato a um arquivo Excel\\nasync function adicionarContatoExcel(caminhoArquivo, telefone, nomeContato) {\\n  try {\\n    logger.info(`Adicionando contato ${telefone} ao arquivo Excel: ${caminhoArquivo}`);\\n    \\n    // Formatar o telefone conforme o padr√£o\\n    const telefoneFormatado = formatarTelefone(telefone);\\n    \\n    // Ler o arquivo Excel existente\\n    const workbook = xlsx.readFile(caminhoArquivo, {\\n      cellDates: true,\\n      cellNF: true,\\n      cellText: true\\n    });\\n    \\n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\\n      logger.error('Arquivo Excel sem planilhas');\\n      return false;\\n    }\\n    \\n    // Usar a primeira planilha\\n    const sheetName = workbook.SheetNames[0];\\n    const worksheet = workbook.Sheets[sheetName];\\n    \\n    // Converter para JSON para manipula√ß√£o\\n    const dados = xlsx.utils.sheet_to_json(worksheet, {\\n      defval: '',\\n      raw: false\\n    });\\n    \\n    // Verificar se o contato j√° existe\\n    const contatoExistente = dados.find(contato => {\\n      // Normalizar n√∫meros de telefone para compara√ß√£o\\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\\\D/g, '');\\n      const telefoneNovo = telefoneFormatado.replace(/\\\\D/g, '');\\n      \\n      return telefoneExistente === telefoneNovo || \\n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \\n             `55${telefoneExistente}` === telefoneNovo;\\n    });\\n    \\n    if (contatoExistente) {\\n      logger.info(`Contato ${telefone} j√° existe na planilha.`);\\n      return false;\\n    }\\n    \\n    // Adicionar o novo contato\\n    const novoContato = {\\n      Nome: nomeContato,\\n      Telefone: telefoneFormatado,\\n      Ativo: 'Sim',\\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\\n    };\\n    \\n    dados.push(novoContato);\\n    \\n    // Converter de volta para planilha\\n    const novaWorksheet = xlsx.utils.json_to_sheet(dados);\\n    workbook.Sheets[sheetName] = novaWorksheet;\\n    \\n    // Salvar o arquivo atualizado\\n    xlsx.writeFile(workbook, caminhoArquivo);\\n    \\n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado √† planilha com sucesso.`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao adicionar contato no Excel: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Adicionar contato a um arquivo CSV\\nasync function adicionarContatoCsv(caminhoArquivo, telefone, nomeContato) {\\n  try {\\n    logger.info(`Adicionando contato ${telefone} ao arquivo CSV: ${caminhoArquivo}`);\\n    \\n    // Formatar o telefone conforme o padr√£o\\n    const telefoneFormatado = formatarTelefone(telefone);\\n    \\n    // Ler o arquivo CSV existente\\n    const contatos = await new Promise((resolve, reject) => {\\n      const linhas = [];\\n      \\n      fs.createReadStream(caminhoArquivo)\\n        .pipe(csvParser())\\n        .on('data', (row) => {\\n          linhas.push(row);\\n        })\\n        .on('end', () => {\\n          resolve(linhas);\\n        })\\n        .on('error', (erro) => {\\n          reject(erro);\\n        });\\n    });\\n    \\n    // Verificar se o contato j√° existe\\n    const contatoExistente = contatos.find(contato => {\\n      // Normalizar n√∫meros de telefone para compara√ß√£o\\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\\\D/g, '');\\n      const telefoneNovo = telefoneFormatado.replace(/\\\\D/g, '');\\n      \\n      return telefoneExistente === telefoneNovo || \\n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \\n             `55${telefoneExistente}` === telefoneNovo;\\n    });\\n    \\n    if (contatoExistente) {\\n      logger.info(`Contato ${telefone} j√° existe no arquivo CSV.`);\\n      return false;\\n    }\\n    \\n    // Adicionar o novo contato\\n    const novoContato = {\\n      Nome: nomeContato,\\n      Telefone: telefoneFormatado,\\n      Ativo: 'Sim',\\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\\n    };\\n    \\n    contatos.push(novoContato);\\n    \\n    // Obter os cabe√ßalhos\\n    const cabecalhos = Object.keys(contatos[0]);\\n    \\n    // Criar o conte√∫do CSV\\n    const csvContent = [\\n      cabecalhos.join(','),\\n      ...contatos.map(contato => \\n        cabecalhos.map(cabecalho => \\n          `\\\"${String(contato[cabecalho] || '').replace(/\\\"/g, '\\\"\\\"')}\\\"`\\n        ).join(',')\\n      )\\n    ].join('\\\\n');\\n    \\n    // Salvar o arquivo atualizado\\n    fs.writeFileSync(caminhoArquivo, csvContent, 'utf8');\\n    \\n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado ao CSV com sucesso.`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao adicionar contato no CSV: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Criar novo arquivo de contatos se n√£o existir nenhum\\nfunction criarNovoArquivoContatos(telefone, nomeContato) {\\n  try {\\n    logger.info('Criando novo arquivo de contatos...');\\n    \\n    // Garantir que o diret√≥rio existe\\n    if (!fs.existsSync(CONTATOS_DIR)) {\\n      fs.mkdirSync(CONTATOS_DIR, { recursive: true });\\n    }\\n    \\n    // Formatar o telefone conforme o padr√£o\\n    const telefoneFormatado = formatarTelefone(telefone);\\n    \\n    // Criar dados iniciais\\n    const contatos = [\\n      {\\n        Nome: nomeContato,\\n        Telefone: telefoneFormatado,\\n        Ativo: 'Sim',\\n        Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\\n      }\\n    ];\\n    \\n    // Criar arquivo Excel\\n    const caminhoArquivo = path.join(CONTATOS_DIR, 'contatos.xlsx');\\n    const workbook = xlsx.utils.book_new();\\n    const worksheet = xlsx.utils.json_to_sheet(contatos);\\n    \\n    xlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\\n    xlsx.writeFile(workbook, caminhoArquivo);\\n    \\n    logger.info(`Novo arquivo de contatos criado com o contato ${telefoneFormatado}`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao criar novo arquivo de contatos: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Fun√ß√£o auxiliar para formatar n√∫mero de telefone\\nfunction formatarTelefone(telefone) {\\n  // Remover caracteres n√£o num√©ricos\\n  let telefoneFormatado = String(telefone).replace(/\\\\D/g, '');\\n  \\n  // Adicionar c√≥digo do pa√≠s (55) se n√£o estiver presente e for um n√∫mero brasileiro\\n  if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\\n    telefoneFormatado = `55${telefoneFormatado}`;\\n  }\\n  \\n  return telefoneFormatado;\\n}\\n\\nmodule.exports = {\\n  adicionarNovoContatoNaPlanilha\\n};\"\n    },\n    {\n      \"path\": \"src\\\\conversasHandler.js\",\n      \"name\": \"conversasHandler.js\",\n      \"extension\": \".js\",\n      \"size\": 11390,\n      \"last_modified\": \"2025-04-03T13:54:43.506143\",\n      \"content\": \"// M√≥dulo para gerenciar conversas individuais com os usu√°rios\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\\nconst leitorDocumentos = require('./leitorDocumentos');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst { logger, removerAcentos, limparString } = require('./utils');\\n\\n// Configura√ß√µes\\nconst CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\\nconst MAX_HISTORICO_CONVERSAS = parseInt(process.env.MAX_HISTORICO_CONVERSAS || '10', 10);\\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\\n\\n// Inicializar cliente Gemini\\nlet genAI;\\nlet geminiModel;\\n\\n// Fun√ß√£o para inicializar a API do Gemini\\nfunction inicializarGeminiAPI() {\\n  try {\\n    if (!GEMINI_API_KEY) {\\n      logger.error('Chave da API do Gemini n√£o configurada no arquivo .env');\\n      return false;\\n    }\\n    \\n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\\n    \\n    // Tentar usar o modelo mais avan√ßado primeiro\\n    try {\\n      geminiModel = genAI.getGenerativeModel({ model: \\\"gemini-1.5-pro\\\" });\\n      logger.info('API do Google Gemini (gemini-1.5-pro) inicializada com sucesso');\\n    } catch (erro) {\\n      logger.warn(`Erro ao inicializar modelo gemini-1.5-pro: ${erro.message}`);\\n      // Fallback para outro modelo\\n      geminiModel = genAI.getGenerativeModel({ model: \\\"gemini-pro\\\" });\\n      logger.info('API do Google Gemini (gemini-pro) inicializada com sucesso');\\n    }\\n    \\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Inicializar a API\\ninicializarGeminiAPI();\\n\\n// Garantir que o diret√≥rio de conversas exista\\nfunction garantirDiretorioConversas() {\\n  if (!fs.existsSync(CONVERSAS_DIR)) {\\n    fs.mkdirSync(CONVERSAS_DIR, { recursive: true });\\n    logger.info(`Diret√≥rio de conversas criado: ${CONVERSAS_DIR}`);\\n  }\\n}\\n\\n// Obter o caminho do arquivo de hist√≥rico para um telefone espec√≠fico\\nfunction obterCaminhoHistoricoConversa(telefone) {\\n  garantirDiretorioConversas();\\n  const nomeArquivo = `${telefone}.json`;\\n  return path.join(CONVERSAS_DIR, nomeArquivo);\\n}\\n\\n// Carregar hist√≥rico de conversa de um usu√°rio\\nfunction carregarHistoricoConversa(telefone) {\\n  try {\\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\\n    \\n    if (fs.existsSync(caminhoArquivo)) {\\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n      return JSON.parse(conteudo);\\n    }\\n    \\n    // Retornar hist√≥rico vazio se n√£o existir\\n    return {\\n      telefone: telefone,\\n      ultimaAtualizacao: new Date().toISOString(),\\n      ultimoDevocional: null,\\n      conversas: []\\n    };\\n  } catch (erro) {\\n    logger.error(`Erro ao carregar hist√≥rico de conversa para ${telefone}: ${erro.message}`);\\n    return {\\n      telefone: telefone,\\n      ultimaAtualizacao: new Date().toISOString(),\\n      ultimoDevocional: null,\\n      conversas: []\\n    };\\n  }\\n}\\n\\n// Salvar hist√≥rico de conversa de um usu√°rio\\nfunction salvarHistoricoConversa(historico) {\\n  try {\\n    garantirDiretorioConversas();\\n    \\n    // Atualizar a data da √∫ltima atualiza√ß√£o\\n    historico.ultimaAtualizacao = new Date().toISOString();\\n    \\n    // Limitar o n√∫mero de mensagens no hist√≥rico\\n    if (historico.conversas.length > MAX_HISTORICO_CONVERSAS) {\\n      historico.conversas = historico.conversas.slice(-MAX_HISTORICO_CONVERSAS);\\n    }\\n    \\n    const caminhoArquivo = obterCaminhoHistoricoConversa(historico.telefone);\\n    fs.writeFileSync(caminhoArquivo, JSON.stringify(historico, null, 2));\\n    \\n    logger.info(`Hist√≥rico de conversa salvo para ${historico.telefone}`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao salvar hist√≥rico de conversa para ${historico.telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Registrar um devocional enviado para um usu√°rio\\nfunction registrarDevocionalEnviado(telefone, devocional) {\\n  try {\\n    const historico = carregarHistoricoConversa(telefone);\\n    \\n    // Registrar o devocional atual\\n    historico.ultimoDevocional = {\\n      data: new Date().toISOString(),\\n      conteudo: devocional\\n    };\\n    \\n    return salvarHistoricoConversa(historico);\\n  } catch (erro) {\\n    logger.error(`Erro ao registrar devocional para ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Registrar uma mensagem na conversa\\nfunction registrarMensagem(telefone, remetente, mensagem) {\\n  try {\\n    const historico = carregarHistoricoConversa(telefone);\\n    \\n    // Adicionar a mensagem ao hist√≥rico\\n    historico.conversas.push({\\n      timestamp: new Date().toISOString(),\\n      remetente: remetente, // 'usuario' ou 'bot'\\n      mensagem: mensagem\\n    });\\n    \\n    return salvarHistoricoConversa(historico);\\n  } catch (erro) {\\n    logger.error(`Erro ao registrar mensagem para ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Verificar se uma mensagem parece ser uma pergunta\\nfunction ePergunta(mensagem) {\\n  // Remover acentos e converter para min√∫sculas\\n  const textoNormalizado = removerAcentos(mensagem.toLowerCase());\\n  \\n  // Verificar se termina com ponto de interroga√ß√£o\\n  if (textoNormalizado.includes('?')) {\\n    return true;\\n  }\\n  \\n  // Verificar palavras-chave de perguntas\\n  const palavrasChavePergunta = [\\n    'quem', 'como', 'por que', 'porque', 'quando', 'onde', 'qual', 'quais',\\n    'o que', 'oq', 'pq', 'me explica', 'pode explicar', 'explique', 'significa',\\n    'entendi', 'n√£o entendi', 'nao entendi', 'duvida', 'd√∫vida'\\n  ];\\n  \\n  return palavrasChavePergunta.some(palavra => textoNormalizado.includes(palavra));\\n}\\n\\n// Verificar se √© a primeira intera√ß√£o de um usu√°rio\\nasync function isPrimeiraInteracao(telefone) {\\n  try {\\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\\n    \\n    // Verificar se o arquivo de hist√≥rico existe\\n    const existeHistorico = fs.existsSync(caminhoArquivo);\\n    \\n    // Se o arquivo n√£o existir, √© a primeira intera√ß√£o\\n    if (!existeHistorico) {\\n      logger.info(`Arquivo de hist√≥rico n√£o encontrado para ${telefone}, √© a primeira intera√ß√£o`);\\n      return true;\\n    }\\n    \\n    // Se o arquivo existir, verificar se tem conte√∫do v√°lido\\n    try {\\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n      const historico = JSON.parse(conteudo);\\n      \\n      // Verificar se o hist√≥rico tem conversas\\n      if (!historico.conversas || historico.conversas.length === 0) {\\n        logger.info(`Hist√≥rico vazio para ${telefone}, considerando como primeira intera√ß√£o`);\\n        return true;\\n      }\\n      \\n      // Se chegou aqui, n√£o √© a primeira intera√ß√£o\\n      logger.info(`Usu√°rio ${telefone} j√° tem hist√≥rico com ${historico.conversas.length} mensagens`);\\n      return false;\\n    } catch (erroLeitura) {\\n      logger.error(`Erro ao ler hist√≥rico para ${telefone}: ${erroLeitura.message}`);\\n      // Em caso de erro de leitura, considerar como primeira intera√ß√£o para garantir\\n      return true;\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar primeira intera√ß√£o para ${telefone}: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Preparar o prompt para a resposta da IA\\nasync function prepararPromptResposta(telefone, mensagemUsuario) {\\n  const historico = carregarHistoricoConversa(telefone);\\n  const ultimoDevocional = historico.ultimoDevocional ? historico.ultimoDevocional.conteudo : '';\\n  \\n  // Obter √∫ltimas conversas para contexto (limitado √†s 5 √∫ltimas)\\n  const conversasRecentes = historico.conversas.slice(-5);\\n  const conversasFormatadas = conversasRecentes.map(c => \\n    `${c.remetente === 'usuario' ? 'Pessoa' : 'Bot'}: ${c.mensagem}`\\n  ).join('\\\\n');\\n  \\n  // Obter conte√∫do da base de conhecimento\\n  const baseConhecimento = await leitorDocumentos.obterConteudoBase();\\n  \\n  const prompt = `\\n  Voc√™ √© um assistente espiritual que est√° respondendo perguntas sobre um devocional di√°rio que voc√™ enviou para uma pessoa via WhatsApp.\\n  \\n  Seu √∫ltimo devocional enviado foi:\\n  ${ultimoDevocional}\\n  \\n  O contexto da conversa recente √©:\\n  ${conversasFormatadas}\\n  \\n  A pessoa acabou de enviar esta mensagem para voc√™:\\n  \\\"${mensagemUsuario}\\\"\\n  \\n  Baseie-se no devocional enviado e na seguinte base de conhecimento religiosa para responder:\\n  ${baseConhecimento.substring(0, 10000)}\\n  \\n  Responda √† pergunta ou coment√°rio da pessoa de forma amig√°vel, acolhedora e espiritual. \\n  Mantenha a resposta concisa (at√© 5 frases), mas esclarecedora e relevante para a mensagem da pessoa.\\n  Se for uma pergunta sobre o devocional, d√™ uma resposta espec√≠fica baseada no vers√≠culo e na reflex√£o.\\n  Se n√£o for uma pergunta relacionada ao devocional, responda de forma generalista e gentil, evitando debates teol√≥gicos complexos.\\n  \\n  N√£o mencione que voc√™ √© uma IA ou um bot. Responda como um aconselhador espiritual amig√°vel.\\n  `;\\n  \\n  return prompt.trim();\\n}\\n\\n// Gerar resposta para uma mensagem do usu√°rio\\nasync function gerarRespostaParaMensagem(telefone, mensagemUsuario) {\\n  try {\\n    // Verificar se a API Gemini est√° inicializada\\n    if (!geminiModel) {\\n      const inicializou = inicializarGeminiAPI();\\n      if (!inicializou) {\\n        return \\\"N√£o foi poss√≠vel responder no momento. Por favor, tente novamente mais tarde.\\\";\\n      }\\n    }\\n    \\n    // Registrar a mensagem do usu√°rio\\n    registrarMensagem(telefone, 'usuario', mensagemUsuario);\\n    \\n    // Verificar se a mensagem √© uma pergunta ou coment√°rio que precisa de resposta\\n    if (!ePergunta(mensagemUsuario) && mensagemUsuario.length < 10) {\\n      const respostasSimples = [\\n        \\\"Am√©m! Tenha um dia aben√ßoado.\\\",\\n        \\\"Que Deus te aben√ßoe hoje e sempre.\\\",\\n        \\\"Obrigado por compartilhar. Fique na paz de Cristo.\\\",\\n        \\\"Louvado seja Deus! Tenha um excelente dia.\\\",\\n        \\\"Que a gra√ßa de Deus esteja com voc√™ hoje.\\\"\\n      ];\\n      \\n      const resposta = respostasSimples[Math.floor(Math.random() * respostasSimples.length)];\\n      registrarMensagem(telefone, 'bot', resposta);\\n      return resposta;\\n    }\\n    \\n    // Preparar o prompt\\n    const prompt = await prepararPromptResposta(telefone, mensagemUsuario);\\n    \\n    // Gerar resposta com a IA\\n    const result = await geminiModel.generateContent({\\n      contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n      generationConfig: {\\n        temperature: 0.7,\\n        topK: 40,\\n        topP: 0.95,\\n        maxOutputTokens: 1024,\\n      },\\n    });\\n    \\n    const resposta = result.response.text().trim();\\n    \\n    // Registrar a resposta do bot\\n    registrarMensagem(telefone, 'bot', resposta);\\n    \\n    return resposta;\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar resposta para ${telefone}: ${erro.message}`);\\n    \\n    // Resposta de fallback em caso de erro\\n    const respostaFallback = \\\"Agrade√ßo sua mensagem. Estou refletindo sobre isso e logo poderei responder com mais clareza. Que Deus aben√ßoe seu dia.\\\";\\n    registrarMensagem(telefone, 'bot', respostaFallback);\\n    \\n    return respostaFallback;\\n  }\\n}\\n\\nmodule.exports = {\\n  registrarDevocionalEnviado,\\n  gerarRespostaParaMensagem,\\n  ePergunta,\\n  isPrimeiraInteracao\\n};\"\n    },\n    {\n      \"path\": \"src\\\\geradorDevocional.js\",\n      \"name\": \"geradorDevocional.js\",\n      \"extension\": \".js\",\n      \"size\": 10685,\n      \"last_modified\": \"2025-04-03T15:18:23.726040\",\n      \"content\": \"// M√≥dulo gerador de devocionais com IA (Google Gemini)\\n\\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\\nconst leitorDocumentos = require('./leitorDocumentos');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst { logger } = require('./utils');\\n\\n// Configura√ß√£o da API do Gemini\\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\\n\\n// Inicializar o cliente Gemini\\nlet genAI;\\nlet geminiModel;\\n\\n// Fun√ß√£o para inicializar a API do Gemini\\nfunction inicializarGeminiAPI() {\\n  try {\\n    if (!GEMINI_API_KEY) {\\n      logger.error('Chave da API do Gemini n√£o configurada no arquivo .env');\\n      return false;\\n    }\\n    \\n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\\n    \\n    // Corrigindo para usar o nome do modelo correto\\n    // Verificar qual modelo est√° dispon√≠vel (gemini-pro ou gemini-1.5-pro)\\n    geminiModel = genAI.getGenerativeModel({ model: \\\"gemini-2.0-flash\\\" });\\n    \\n    logger.info('API do Google Gemini inicializada com sucesso');\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Tentar inicializar a API\\ninicializarGeminiAPI();\\n\\n// Gerar um prompt para o Gemini\\nasync function gerarPrompt(dataAtual) {\\n  try {\\n    // Obter conte√∫do da base de conhecimento\\n    const baseConhecimento = await leitorDocumentos.obterConteudoBase();\\n    \\n    // Obter vers√≠culos recentes (para evitar repeti√ß√µes)\\n    const versiculosRecentes = historicoMensagens.obterVersiculosRecentes(10); // Aumentei para 10 dias\\n    const versiculosRecentesTexto = versiculosRecentes\\n      .map(v => {\\n        if (!v || !v.referencia || !v.texto) return '';\\n        return `${v.referencia}: \\\"${v.texto}\\\"`;\\n      })\\n      .filter(v => v) // Remove entradas vazias\\n      .join('\\\\n');\\n    \\n    // Adicionar log para debug\\n    logger.info(`Vers√≠culos a serem evitados: ${versiculosRecentesTexto || \\\"Nenhum\\\"}`);\\n    \\n    // Construir o prompt\\n    const prompt = `\\n      Voc√™ √© um bot de WhatsApp com intelig√™ncia artificial projetado para enviar um devocional di√°rio todas as manh√£s.\\n      \\n      Seu objetivo √© criar uma mensagem devocional que contenha:\\n      1. A data atual (${dataAtual})\\n      2. Um vers√≠culo b√≠blico relevante\\n      3. Um texto explicativo sobre o vers√≠culo (3-5 frases)\\n      4. Uma sugest√£o pr√°tica para o dia (1-2 frases)\\n      \\n      MUITO IMPORTANTE: Voc√™ deve gerar um devocional com um vers√≠culo diferente a cada dia. Nunca repita vers√≠culos que j√° foram usados recentemente.\\n      \\n      Baseie-se no seguinte conte√∫do para selecionar o vers√≠culo e elaborar a reflex√£o:\\n      \\n      ${baseConhecimento.substring(0, 15000)} \\n      \\n      Evite usar ABSOLUTAMENTE os seguintes vers√≠culos que foram utilizados recentemente:\\n      ${versiculosRecentesTexto || \\\"Nenhum vers√≠culo recente a evitar.\\\"}\\n      \\n      O tom deve ser amig√°vel, acolhedor e espiritual.\\n      \\n      Exemplo do formato esperado:\\n      \\n      \\\"üìÖ ${dataAtual}\\n      \\n      üìñ *Vers√≠culo:* \\\\\\\"Tudo o que fizerem, fa√ßam de todo o cora√ß√£o, como para o Senhor.\\\\\\\" (Colossenses 3:23)\\n      \\n      üí≠ *Reflex√£o:* Este vers√≠culo nos lembra que nossas a√ß√µes di√°rias, por menores que sejam, ganham significado quando as dedicamos a Deus. Trabalhar, ajudar algu√©m ou at√© descansar pode ser uma forma de honr√°-Lo se fizermos com amor e prop√≥sito. Que tal come√ßar o dia com essa inten√ß√£o no cora√ß√£o?\\n      \\n      üßóüèº *Pr√°tica:* Hoje, escolha uma tarefa simples e a realize com dedica√ß√£o, pensando em como ela pode refletir seu cuidado com os outros e com Deus.\\\\\\\"\\n      \\n      Gere o devocional seguindo exatamente esse formato. induza o usu√°rio a continuar a conversa.\\n    `;\\n    \\n    return prompt.trim();\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar prompt: ${erro.message}`);\\n    throw erro;\\n  }\\n}\\n\\n// Modifique a fun√ß√£o gerarDevocional para incluir a valida√ß√£o\\nasync function gerarDevocional(dataAtual) {\\n  try {\\n    // Verificar se a API foi inicializada corretamente\\n    if (!geminiModel) {\\n      logger.warn('API do Gemini n√£o inicializada. Tentando inicializar novamente...');\\n      \\n      // Tentar inicializar novamente\\n      const inicializou = inicializarGeminiAPI();\\n      \\n      if (!inicializou || !geminiModel) {\\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\\n      }\\n    }\\n    \\n    // Contador de tentativas para evitar loop infinito\\n    let tentativas = 0;\\n    const maxTentativas = 3;\\n    let devocionalValido = false;\\n    let devocional = '';\\n    \\n    while (!devocionalValido && tentativas < maxTentativas) {\\n      tentativas++;\\n      logger.info(`Gerando devocional - tentativa ${tentativas}/${maxTentativas}`);\\n      \\n      // Gerar o prompt com os vers√≠culos a serem evitados\\n      const prompt = await gerarPrompt(dataAtual);\\n      \\n      try {\\n        const result = await geminiModel.generateContent({\\n          contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n          generationConfig: {\\n            temperature: 0.7 + (tentativas * 0.1), // Aumentar a temperatura a cada tentativa\\n            topK: 40,\\n            topP: 0.95,\\n            maxOutputTokens: 1024,\\n          },\\n        });\\n        \\n        const response = result.response;\\n        devocional = response.text().trim();\\n        \\n        // Verificar se o devocional foi gerado corretamente\\n        if (!devocional || devocional.length < 50) {\\n          logger.warn('Devocional gerado muito curto ou vazio. Tentando novamente.');\\n          continue;\\n        }\\n        \\n        // Validar se o vers√≠culo n√£o foi usado recentemente\\n        devocionalValido = await validarDevocionalGerado(devocional);\\n        \\n        if (devocionalValido) {\\n          logger.info('Devocional v√°lido gerado com sucesso');\\n          return devocional;\\n        } else {\\n          logger.warn('Devocional gerado usa vers√≠culo repetido. Tentando novamente.');\\n        }\\n      } catch (erroGemini) {\\n        logger.warn(`Erro com o modelo na tentativa ${tentativas}: ${erroGemini.message}`);\\n        \\n        if (tentativas >= maxTentativas) {\\n          logger.error('N√∫mero m√°ximo de tentativas atingido. Usando fallback.');\\n          return gerarDevocionalFallback(dataAtual);\\n        }\\n      }\\n    }\\n    \\n    // Se chegou aqui sem um devocional v√°lido, usar fallback\\n    if (!devocionalValido) {\\n      logger.warn('N√£o foi poss√≠vel gerar um devocional com vers√≠culo √∫nico. Usando fallback.');\\n      return gerarDevocionalFallback(dataAtual);\\n    }\\n    \\n    return devocional;\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\\n    return gerarDevocionalFallback(dataAtual);\\n  }\\n}\\n\\n// Gerar o devocional utilizando o Gemini\\nasync function gerarDevocional(dataAtual) {\\n  try {\\n    // Verificar se a API foi inicializada corretamente\\n    if (!geminiModel) {\\n      logger.warn('API do Gemini n√£o inicializada. Tentando inicializar novamente...');\\n      \\n      // Tentar inicializar novamente\\n      const inicializou = inicializarGeminiAPI();\\n      \\n      if (!inicializou || !geminiModel) {\\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\\n      }\\n    }\\n    \\n    logger.info('Gerando prompt para o Gemini...');\\n    const prompt = await gerarPrompt(dataAtual);\\n    \\n    logger.info('Solicitando gera√ß√£o de devocional ao Gemini...');\\n    \\n    try {\\n      const result = await geminiModel.generateContent({\\n        contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n        generationConfig: {\\n          temperature: 0.7,\\n          topK: 40,\\n          topP: 0.95,\\n          maxOutputTokens: 1024,\\n        },\\n      });\\n      \\n      const response = result.response;\\n      const devocional = response.text().trim();\\n      \\n      // Verificar se o devocional foi gerado corretamente\\n      if (!devocional || devocional.length < 50) {\\n        logger.warn('Devocional gerado muito curto ou vazio. Usando fallback.');\\n        return gerarDevocionalFallback(dataAtual);\\n      }\\n      \\n      logger.info('Devocional gerado com sucesso');\\n      return devocional;\\n    } catch (erroGemini) {\\n      // Tentar usar outro modelo se o modelo atual falhar\\n      logger.warn(`Erro com o modelo atual. Detalhe: ${erroGemini.message}`);\\n      \\n      try {\\n        // Tentar com modelo alternativo\\n        logger.info('Tentando modelo alternativo gemini-pro...');\\n        const modeloAlternativo = genAI.getGenerativeModel({ model: \\\"gemini-pro\\\" });\\n        \\n        const resultadoAlternativo = await modeloAlternativo.generateContent({\\n          contents: [{ role: \\\"user\\\", parts: [{ text: prompt }] }],\\n          generationConfig: {\\n            temperature: 0.7,\\n            topK: 40,\\n            topP: 0.95,\\n            maxOutputTokens: 1024,\\n          },\\n        });\\n        \\n        const respostaAlternativa = resultadoAlternativo.response;\\n        const devocionalAlternativo = respostaAlternativa.text().trim();\\n        \\n        logger.info('Devocional gerado com sucesso usando modelo alternativo');\\n        return devocionalAlternativo;\\n      } catch (erroModeloAlternativo) {\\n        logger.error(`Erro tamb√©m no modelo alternativo: ${erroModeloAlternativo.message}`);\\n        throw new Error(`Falha em todos os modelos Gemini dispon√≠veis`);\\n      }\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\\n    \\n    // Retornar um devocional de fallback em caso de erro\\n    return gerarDevocionalFallback(dataAtual);\\n  }\\n}\\n\\n// Gerar um devocional de fallback em caso de erro na API\\nfunction gerarDevocionalFallback(dataAtual) {\\n  logger.info('Gerando devocional de fallback...');\\n  \\n  return `${dataAtual}\\n\\n*‚úùÔ∏è Vers√≠culo:* \\\"N√£o temas, porque eu sou contigo; n√£o te assombres, porque eu sou teu Deus; eu te fortale√ßo, e te ajudo, e te sustento com a destra da minha justi√ßa.\\\" (Isa√≠as 41:10)\\n\\n*üí≠ Reflex√£o:* Mesmo quando enfrentamos dificuldades ou desafios inesperados, Deus est√° ao nosso lado, pronto para nos dar for√ßa e sustento. Este vers√≠culo nos lembra que n√£o precisamos temer, pois temos a presen√ßa constante do Senhor em nossas vidas, guiando nossos passos e iluminando nosso caminho.\\n\\n*üßóüèª Pr√°tica:* Hoje, ao enfrentar qualquer situa√ß√£o desafiadora, fa√ßa uma pausa, respire e relembre esta promessa de sustento divino antes de prosseguir.`;\\n}\\n\\nmodule.exports = {\\n  gerarDevocional\\n};\"\n    },\n    {\n      \"path\": \"src\\\\historicoMensagens.js\",\n      \"name\": \"historicoMensagens.js\",\n      \"extension\": \".js\",\n      \"size\": 11682,\n      \"last_modified\": \"2025-04-03T14:06:05.760106\",\n      \"content\": \"// M√≥dulo para gerenciamento do hist√≥rico de mensagens enviadas\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst { logger } = require('./utils');\\n\\n// Configura√ß√µes do hist√≥rico\\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Hist√≥rico';\\nconst HISTORICO_FILE = process.env.HISTORICO_FILE || './Hist√≥rico/historico.json';\\nconst MAX_HISTORICO_DIAS = parseInt(process.env.MAX_HISTORICO_DIAS || '90', 10);\\n\\n// Garantir que o diret√≥rio do hist√≥rico exista\\nfunction garantirDiretorioHistorico() {\\n  if (!fs.existsSync(HISTORICO_DIR)) {\\n    fs.mkdirSync(HISTORICO_DIR, { recursive: true });\\n    logger.info(`Diret√≥rio de hist√≥rico criado: ${HISTORICO_DIR}`);\\n  }\\n  \\n  if (!fs.existsSync(HISTORICO_FILE)) {\\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify({\\n      ultimaAtualizacao: new Date().toISOString(),\\n      mensagens: []\\n    }, null, 2));\\n    logger.info(`Arquivo de hist√≥rico criado: ${HISTORICO_FILE}`);\\n  }\\n}\\n\\n// Carregar o hist√≥rico de mensagens\\nfunction carregarHistorico() {\\n  try {\\n    garantirDiretorioHistorico();\\n    \\n    // Verificar se o arquivo existe e tem conte√∫do v√°lido\\n    if (fs.existsSync(HISTORICO_FILE)) {\\n      const conteudo = fs.readFileSync(HISTORICO_FILE, 'utf8');\\n      if (conteudo && conteudo.trim()) {\\n        const historico = JSON.parse(conteudo);\\n        // Garantir que o objeto tem a estrutura esperada\\n        if (!historico.mensagens) {\\n          historico.mensagens = [];\\n        }\\n        return historico;\\n      }\\n    }\\n    \\n    // Se o arquivo n√£o existir, estiver vazio ou n√£o tiver a estrutura esperada\\n    const historicoVazio = {\\n      ultimaAtualizacao: new Date().toISOString(),\\n      mensagens: []\\n    };\\n    \\n    // Salvar o hist√≥rico vazio para garantir consist√™ncia\\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\\n    \\n    return historicoVazio;\\n  } catch (erro) {\\n    logger.error(`Erro ao carregar hist√≥rico: ${erro.message}`);\\n    // Retornar um hist√≥rico vazio em caso de erro\\n    const historicoVazio = {\\n      ultimaAtualizacao: new Date().toISOString(),\\n      mensagens: []\\n    };\\n    \\n    // Tentar salvar o hist√≥rico vazio\\n    try {\\n      fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\\n    } catch (erroSalvar) {\\n      logger.error(`Erro ao salvar hist√≥rico vazio: ${erroSalvar.message}`);\\n    }\\n    \\n    return historicoVazio;\\n  }\\n}\\n\\n// Salvar o hist√≥rico de mensagens\\nfunction salvarHistorico(historico) {\\n  try {\\n    garantirDiretorioHistorico();\\n    \\n    // Atualizar a data da √∫ltima atualiza√ß√£o\\n    historico.ultimaAtualizacao = new Date().toISOString();\\n    \\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historico, null, 2));\\n    logger.info('Hist√≥rico salvo com sucesso');\\n  } catch (erro) {\\n    logger.error(`Erro ao salvar hist√≥rico: ${erro.message}`);\\n  }\\n}\\n\\n// Limpar mensagens antigas do hist√≥rico\\nfunction limparHistoricoAntigo(historico) {\\n  try {\\n    const dataLimite = new Date();\\n    dataLimite.setDate(dataLimite.getDate() - MAX_HISTORICO_DIAS);\\n    \\n    const mensagensRecentes = historico.mensagens.filter(msg => {\\n      const dataMensagem = new Date(msg.data);\\n      return dataMensagem >= dataLimite;\\n    });\\n    \\n    const mensagensRemovidas = historico.mensagens.length - mensagensRecentes.length;\\n    \\n    if (mensagensRemovidas > 0) {\\n      logger.info(`Removidas ${mensagensRemovidas} mensagens antigas do hist√≥rico`);\\n      historico.mensagens = mensagensRecentes;\\n      salvarHistorico(historico);\\n    }\\n    \\n    return historico;\\n  } catch (erro) {\\n    logger.error(`Erro ao limpar hist√≥rico antigo: ${erro.message}`);\\n    return historico;\\n  }\\n}\\n\\n// Extrair vers√≠culos de uma mensagem devocional\\nfunction extrairVersiculo(devocional) {\\n  try {\\n    // Procurar o padr√£o de vers√≠culo na mensagem\\n    const regexVersiculo = /Vers√≠culo:\\\\s*[\\\"'](.+?)[\\\"']\\\\s*\\\\((.+?)\\\\)/i;\\n    const match = devocional.match(regexVersiculo);\\n    \\n    if (match && match.length >= 3) {\\n      return {\\n        texto: match[1].trim(),\\n        referencia: match[2].trim()\\n      };\\n    }\\n    \\n    return null;\\n  } catch (erro) {\\n    logger.error(`Erro ao extrair vers√≠culo: ${erro.message}`);\\n    return null;\\n  }\\n}\\n\\n// Registrar um envio no hist√≥rico\\nfunction registrarEnvio(dados) {\\n  try {\\n    const historico = carregarHistorico();\\n    const versiculo = extrairVersiculo(dados.devocional);\\n    \\n    historico.mensagens.push({\\n      data: dados.data,\\n      devocional: dados.devocional,\\n      versiculo: versiculo,\\n      totalContatos: dados.totalContatos,\\n      enviosComSucesso: dados.enviosComSucesso,\\n      timestamp: new Date().toISOString()\\n    });\\n    \\n    // Limpar mensagens antigas antes de salvar\\n    limparHistoricoAntigo(historico);\\n    \\n    logger.info('Envio registrado no hist√≥rico com sucesso');\\n  } catch (erro) {\\n    logger.error(`Erro ao registrar envio no hist√≥rico: ${erro.message}`);\\n  }\\n}\\n\\n// Obter vers√≠culos usados recentemente (para evitar repeti√ß√µes)\\nfunction obterVersiculosRecentes(dias = 7) {\\n  try {\\n    const historico = carregarHistorico();\\n    const dataLimite = new Date();\\n    dataLimite.setDate(dataLimite.getDate() - dias);\\n\\n    // Adicionar log para debug\\n    logger.info(`Verificando vers√≠culos usados nos √∫ltimos ${dias} dias`);\\n    \\n    const versiculosRecentes = historico.mensagens\\n      .filter(msg => {\\n        if (!msg.data || !msg.versiculo) return false;\\n        const dataMensagem = new Date(msg.data);\\n        return isRecente = dataMensagem >= dataLimite;\\n\\n        // Log para cada entrada\\n        if (isRecente && msg.versiculo) {\\n          logger.info(`Vers√≠culo recente encontrado: ${msg.versiculo.referencia} usado em ${dataMensagem.toISOString()}`);\\n        }\\n        return isRecente && msg.versiculo\\n      })\\n      .map(msg => msg.versiculo);\\n    \\n    logger.info(`Total de ${versiculosRecentes.length} vers√≠culos recentes encontrados`);\\n    return versiculosRecentes;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter vers√≠culos recentes: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Verificar se um vers√≠culo foi usado recentemente\\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 7) { // Aumentei para 7 dias\\n  try {\\n    const versiculosRecentes = obterVersiculosRecentes(dias);\\n    \\n    // Normalizar a refer√™ncia para compara√ß√£o (remover espa√ßos e converter para min√∫sculas)\\n    const referenciaFormatada = referencia.replace(/\\\\s+/g, '').toLowerCase();\\n    \\n    const encontrado = versiculosRecentes.some(versiculo => {\\n      if (!versiculo || !versiculo.referencia) return false;\\n      \\n      const versiculoFormatado = versiculo.referencia.replace(/\\\\s+/g, '').toLowerCase();\\n      const isMatch = versiculoFormatado === referenciaFormatada;\\n      \\n      if (isMatch) {\\n        logger.info(`Vers√≠culo ${referencia} j√° foi usado recentemente`);\\n      }\\n      \\n      return isMatch;\\n    });\\n    \\n    return encontrado;\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar vers√≠culo: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Obter o √∫ltimo devocional enviado\\nasync function obterUltimoDevocionalEnviado() {\\n  try {\\n    // Tentar obter do hist√≥rico geral primeiro\\n    const historico = carregarHistorico();\\n    \\n    if (historico && historico.mensagens && historico.mensagens.length > 0) {\\n      // Ordenar mensagens por data (mais recente primeiro)\\n      const mensagensOrdenadas = [...historico.mensagens].sort((a, b) => \\n        new Date(b.data) - new Date(a.data)\\n      );\\n      \\n      // Verificar se o √∫ltimo devocional foi enviado hoje\\n      const hoje = new Date();\\n      const dataHoje = `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, '0')}-${String(hoje.getDate()).padStart(2, '0')}`;\\n      \\n      // Encontrar o √∫ltimo devocional\\n      for (const msg of mensagensOrdenadas) {\\n        if (msg.devocional) {\\n          // Extrair a data do timestamp\\n          const dataMensagem = new Date(msg.timestamp || msg.data);\\n          const dataMensagemStr = `${dataMensagem.getFullYear()}-${String(dataMensagem.getMonth() + 1).padStart(2, '0')}-${String(dataMensagem.getDate()).padStart(2, '0')}`;\\n          \\n          // Se o devocional for de hoje, retorn√°-lo\\n          if (dataMensagemStr === dataHoje) {\\n            logger.info(`Devocional de hoje encontrado no hist√≥rico geral (${dataMensagemStr})`);\\n            return msg.devocional;\\n          }\\n        }\\n      }\\n      \\n      // Se n√£o encontrar um devocional de hoje, retorna o mais recente\\n      const ultimoDevocional = mensagensOrdenadas.find(msg => msg.devocional);\\n      if (ultimoDevocional) {\\n        logger.info('Retornando devocional mais recente dispon√≠vel do hist√≥rico geral');\\n        return ultimoDevocional.devocional;\\n      }\\n    }\\n    \\n    // Se n√£o encontrou no hist√≥rico geral, buscar nas conversas individuais\\n    logger.info('Buscando devocional nas conversas individuais...');\\n    \\n    const CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\\n    if (!fs.existsSync(CONVERSAS_DIR)) {\\n      logger.warn(`Diret√≥rio de conversas n√£o encontrado: ${CONVERSAS_DIR}`);\\n      return null;\\n    }\\n    \\n    // Ler arquivos de conversa\\n    const arquivos = fs.readdirSync(CONVERSAS_DIR);\\n    const arquivosJson = arquivos.filter(arquivo => arquivo.endsWith('.json'));\\n    \\n    let devocionalMaisRecente = null;\\n    let dataMaisRecente = new Date(0); // Data antiga\\n    \\n    // Buscar em todas as conversas\\n    for (const arquivo of arquivosJson) {\\n      try {\\n        const conteudo = fs.readFileSync(path.join(CONVERSAS_DIR, arquivo), 'utf8');\\n        const conversa = JSON.parse(conteudo);\\n        \\n        if (conversa.ultimoDevocional) {\\n          const dataDevocional = new Date(conversa.ultimoDevocional.data);\\n          \\n          // Verificar se √© mais recente que o √∫ltimo encontrado\\n          if (dataDevocional > dataMaisRecente) {\\n            devocionalMaisRecente = conversa.ultimoDevocional.conteudo;\\n            dataMaisRecente = dataDevocional;\\n          }\\n        }\\n      } catch (erroLeitura) {\\n        logger.error(`Erro ao ler arquivo de conversa ${arquivo}: ${erroLeitura.message}`);\\n      }\\n    }\\n    \\n    if (devocionalMaisRecente) {\\n      logger.info(`Devocional encontrado nas conversas individuais (data: ${dataMaisRecente.toISOString()})`);\\n      return devocionalMaisRecente;\\n    }\\n    \\n    logger.warn('Nenhum devocional encontrado no hist√≥rico ou nas conversas');\\n    return null;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter √∫ltimo devocional: ${erro.message}`);\\n    return null;\\n  }\\n}\\n\\n// Verificar se um vers√≠culo foi usado recentemente\\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 30) {\\n  try {\\n    const versiculosRecentes = obterVersiculosRecentes(dias);\\n    \\n    // Normalizar a refer√™ncia para compara√ß√£o (remover espa√ßos e converter para min√∫sculas)\\n    const referenciaFormatada = referencia.replace(/\\\\s+/g, '').toLowerCase();\\n    \\n    return versiculosRecentes.some(versiculo => {\\n      const versiculoFormatado = versiculo.referencia.replace(/\\\\s+/g, '').toLowerCase();\\n      return versiculoFormatado === referenciaFormatada;\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar vers√≠culo: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\nmodule.exports = {\\n  registrarEnvio,\\n  obterVersiculosRecentes,\\n  versiculoFoiUsadoRecentemente,\\n  obterUltimoDevocionalEnviado\\n};\"\n    },\n    {\n      \"path\": \"src\\\\index.js\",\n      \"name\": \"index.js\",\n      \"extension\": \".js\",\n      \"size\": 5072,\n      \"last_modified\": \"2025-04-03T14:19:11.019018\",\n      \"content\": \"// WhatsApp Devocional Di√°rio com IA\\n// Ponto de entrada da aplica√ß√£o\\n\\nrequire('dotenv').config();\\nconst fs = require('fs-extra');\\nconst schedule = require('node-schedule');\\nconst moment = require('moment');\\nmoment.locale('pt-br');\\n\\n// Importa√ß√£o dos m√≥dulos\\nconst whatsapp = require('./whatsapp');\\nconst geradorDevocional = require('./geradorDevocional');\\nconst leitorContatos = require('./leitorContatos');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst conversasHandler = require('./conversasHandler');\\nconst leitorDocumentos = require('./leitorDocumentos');\\nconst { criarDiretorios, formatarData, logger } = require('./utils');\\n\\n// Garantir que os diret√≥rios necess√°rios existam\\ncriarDiretorios();\\n\\n// Fun√ß√£o principal que executa o envio dos devocionais\\nasync function enviarDevocionaisDiarios() {\\n  try {\\n    logger.info('Iniciando o processo de envio de devocionais di√°rios');\\n    \\n    // Obter a data atual formatada\\n    const dataAtual = formatarData(new Date());\\n    logger.info(`Data atual: ${dataAtual}`);\\n    \\n    // Gerar o devocional do dia\\n    logger.info('Gerando devocional...');\\n    const devocional = await geradorDevocional.gerarDevocional(dataAtual);\\n    logger.info('Devocional gerado com sucesso');\\n    \\n    // Verificar se o cliente WhatsApp est√° pronto\\n    if (!whatsapp.clientePronto()) {\\n      logger.error('Cliente WhatsApp n√£o est√° pronto. Tentando novamente em 5 minutos.');\\n      setTimeout(enviarDevocionaisDiarios, 5 * 60 * 1000);\\n      return;\\n    }\\n    \\n    // Obter a lista de contatos\\n    logger.info('Obtendo lista de contatos...');\\n    const contatos = await leitorContatos.obterContatos();\\n    logger.info(`${contatos.length} contatos encontrados`);\\n    \\n    // Enviar o devocional para cada contato\\n    let enviosComSucesso = 0;\\n    \\n    for (const contato of contatos) {\\n      try {\\n        logger.info(`Enviando devocional para ${contato.nome} (${contato.telefone})...`);\\n        await whatsapp.enviarMensagem(contato.telefone, devocional);\\n        \\n        // Registrar o devocional enviado para refer√™ncia em conversas futuras\\n        await conversasHandler.registrarDevocionalEnviado(contato.telefone, devocional);\\n        \\n        enviosComSucesso++;\\n        logger.info(`Devocional enviado com sucesso para ${contato.nome}`);\\n      } catch (erro) {\\n        logger.error(`Erro ao enviar devocional para ${contato.nome}: ${erro.message}`);\\n      }\\n    }\\n    \\n    // Registrar no hist√≥rico\\n    historicoMensagens.registrarEnvio({\\n      data: dataAtual,\\n      devocional: devocional,\\n      totalContatos: contatos.length,\\n      enviosComSucesso: enviosComSucesso\\n    });\\n    \\n    logger.info(`Processo conclu√≠do. Enviado para ${enviosComSucesso}/${contatos.length} contatos.`);\\n  } catch (erro) {\\n    logger.error(`Erro ao executar o processo de envio: ${erro.message}`);\\n    logger.error(erro.stack);\\n  }\\n}\\n\\n// Pr√©-processar a base de conhecimento\\nasync function preprocessarBaseConhecimento() {\\n  try {\\n    logger.info('Iniciando pr√©-processamento da base de conhecimento...');\\n    const conteudoBase = await leitorDocumentos.obterConteudoBase();\\n    logger.info(`Base de conhecimento processada: ${conteudoBase.length} caracteres`);\\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao processar base de conhecimento: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Inicializa√ß√£o do sistema\\nasync function iniciarSistema() {\\n  try {\\n    logger.info('Iniciando o sistema WhatsApp Devocional IA...');\\n    \\n    // Primeiro, processar a base de conhecimento\\n    logger.info('Processando base de conhecimento...');\\n    const baseProcessada = await preprocessarBaseConhecimento();\\n    \\n    if (!baseProcessada) {\\n      logger.warn('Houve um problema no processamento da base de conhecimento, mas o sistema continuar√°.');\\n    }\\n    \\n    // Depois, iniciar o cliente WhatsApp\\n    logger.info('Inicializando conex√£o com WhatsApp...');\\n    await whatsapp.iniciarCliente();\\n    \\n    // Agendar o envio di√°rio de devocionais no hor√°rio configurado\\n    const horarioEnvio = process.env.SCHEDULE_TIME || '07:00';\\n    const [hora, minuto] = horarioEnvio.split(':').map(Number);\\n    \\n    schedule.scheduleJob(`${minuto} ${hora} * * *`, async () => {\\n      logger.info('Executando tarefa agendada de envio de devocionais');\\n      await enviarDevocionaisDiarios();\\n    });\\n    \\n    logger.info(`Sistema iniciado. Devocionais ser√£o enviados diariamente √†s ${horarioEnvio}`);\\n    \\n    // Para desenvolvimento/testes: Descomentar para enviar um devocional imediatamente\\n     setTimeout(enviarDevocionaisDiarios, 10000);\\n  } catch (erro) {\\n    logger.error(`Erro ao iniciar o sistema: ${erro.message}`);\\n    logger.error(erro.stack);\\n  }\\n}\\n\\n// Iniciar o sistema\\niniciarSistema();\\n\\n// Tratamento de encerramento gracioso\\nprocess.on('SIGINT', async () => {\\n  logger.info('Encerrando o sistema...');\\n  await whatsapp.encerrarCliente();\\n  process.exit(0);\\n});\"\n    },\n    {\n      \"path\": \"src\\\\leitorContatos.js\",\n      \"name\": \"leitorContatos.js\",\n      \"extension\": \".js\",\n      \"size\": 8837,\n      \"last_modified\": \"2025-04-03T13:54:43.522193\",\n      \"content\": \"// M√≥dulo para leitura da lista de contatos de arquivos Excel ou CSV\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\nconst csvParser = require('csv-parser');\\nconst { adicionarNovoContatoNaPlanilha } = require('./adicionarContato');\\nconst { logger } = require('./utils');\\n\\n// Diret√≥rio de contatos\\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\\n\\n// Obter a lista de arquivos de contatos dispon√≠veis\\nfunction obterArquivosContatos() {\\n  try {\\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\\n    return arquivos.filter(arquivo => {\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      return extensao === '.xlsx' || extensao === '.csv';\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao ler diret√≥rio de contatos: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Ler contatos de um arquivo Excel\\nasync function lerContatosExcel(caminhoArquivo) {\\n  try {\\n    logger.info(`Lendo arquivo Excel: ${caminhoArquivo}`);\\n    \\n    // Op√ß√µes adicionais para melhorar a leitura\\n    const workbook = xlsx.readFile(caminhoArquivo, {\\n      cellDates: true,\\n      cellNF: true,\\n      cellText: true\\n    });\\n    \\n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\\n      logger.error('Arquivo Excel sem planilhas');\\n      return [];\\n    }\\n    \\n    // Verificar todas as planilhas para encontrar contatos\\n    let todosContatos = [];\\n    \\n    for (const sheetName of workbook.SheetNames) {\\n      logger.info(`Processando planilha: ${sheetName}`);\\n      \\n      const worksheet = workbook.Sheets[sheetName];\\n      \\n      // Verificar se a planilha tem dados\\n      if (!worksheet['!ref']) {\\n        logger.warn(`Planilha ${sheetName} vazia, pulando...`);\\n        continue;\\n      }\\n      \\n      // Tentar ler os dados da planilha\\n      try {\\n        const dados = xlsx.utils.sheet_to_json(worksheet, {\\n          defval: '',  // Valor padr√£o para c√©lulas vazias\\n          raw: false   // N√£o converter tipos automaticamente\\n        });\\n        \\n        logger.info(`Encontrados ${dados.length} registros na planilha ${sheetName}`);\\n        \\n        if (dados.length > 0) {\\n          const contatos = normalizarContatos(dados);\\n          logger.info(`${contatos.length} contatos v√°lidos na planilha ${sheetName}`);\\n          todosContatos = todosContatos.concat(contatos);\\n        }\\n      } catch (erroLeitura) {\\n        logger.error(`Erro ao processar planilha ${sheetName}: ${erroLeitura.message}`);\\n      }\\n    }\\n    \\n    return todosContatos;\\n  } catch (erro) {\\n    logger.error(`Erro ao ler arquivo Excel: ${erro.message}`);\\n    logger.error(erro.stack);\\n    return [];\\n  }\\n}\\n\\n// Ler contatos de um arquivo CSV\\nasync function lerContatosCsv(caminhoArquivo) {\\n  return new Promise((resolve, reject) => {\\n    const contatos = [];\\n    \\n    fs.createReadStream(caminhoArquivo)\\n      .pipe(csvParser())\\n      .on('data', (row) => {\\n        contatos.push(row);\\n      })\\n      .on('end', () => {\\n        resolve(normalizarContatos(contatos));\\n      })\\n      .on('error', (erro) => {\\n        logger.error(`Erro ao ler arquivo CSV: ${erro.message}`);\\n        reject(erro);\\n      });\\n  });\\n}\\n\\n// Normalizar os dados dos contatos para um formato padr√£o\\nfunction normalizarContatos(dados) {\\n  if (!dados || !Array.isArray(dados) || dados.length === 0) {\\n    logger.warn('Nenhum dado de contato v√°lido encontrado para normalizar');\\n    return [];\\n  }\\n  \\n  // Registrar os campos encontrados no primeiro registro para debug\\n  if (dados.length > 0) {\\n    logger.info(`Campos encontrados na planilha: ${Object.keys(dados[0]).join(', ')}`);\\n  }\\n  \\n  return dados.map(contato => {\\n    // Tentar encontrar os campos de nome e telefone, independente da capitaliza√ß√£o\\n    const entradas = Object.entries(contato);\\n    let nome = '';\\n    let telefone = '';\\n    let ativo = true;\\n    \\n    // Debug para cada contato\\n    logger.info(`Processando contato: ${JSON.stringify(contato)}`);\\n    \\n    for (const [chave, valor] of entradas) {\\n      if (!chave) continue;\\n      \\n      const chaveLower = String(chave).toLowerCase();\\n      \\n      if (chaveLower.includes('nome')) {\\n        nome = valor;\\n        logger.info(`Nome encontrado: ${nome}`);\\n      } else if (\\n        chaveLower.includes('telefone') || \\n        chaveLower.includes('celular') || \\n        chaveLower.includes('whatsapp') || \\n        chaveLower.includes('fone') ||\\n        chaveLower.includes('phone') ||\\n        chaveLower.includes('numero')\\n      ) {\\n        telefone = valor;\\n        logger.info(`Telefone encontrado (original): ${telefone}`);\\n      } else if (\\n        chaveLower.includes('ativo') || \\n        chaveLower.includes('status') || \\n        chaveLower.includes('habilitado')\\n      ) {\\n        // Considerar o contato ativo se o campo for 'sim', 'true', 1, etc.\\n        if (typeof valor === 'string') {\\n          const valorLower = String(valor).toLowerCase();\\n          ativo = valorLower === 'sim' || valorLower === 'true' || valorLower === 's' || valorLower === 'y' || valorLower === 'yes';\\n        } else {\\n          ativo = Boolean(valor);\\n        }\\n      }\\n    }\\n    \\n    // Se n√£o encontrar telefone, tentar encontrar algum campo que pare√ßa ser um n√∫mero de telefone\\n    if (!telefone) {\\n      for (const [chave, valor] of entradas) {\\n        // Verificar se o valor se parece com um n√∫mero de telefone (apenas d√≠gitos e com pelo menos 8 caracteres)\\n        if (valor && typeof valor === 'string' && valor.replace(/\\\\D/g, '').length >= 8) {\\n          telefone = valor;\\n          logger.info(`Poss√≠vel telefone encontrado no campo ${chave}: ${telefone}`);\\n          break;\\n        }\\n      }\\n    }\\n    \\n    // Garantir que telefone seja uma string antes de aplicar replace\\n    let telefoneFormatado = '';\\n    if (telefone !== undefined && telefone !== null) {\\n      // Normalizar o telefone (remover caracteres n√£o num√©ricos)\\n      telefoneFormatado = String(telefone).replace(/\\\\D/g, '');\\n      \\n      // Adicionar c√≥digo do pa√≠s (55) se n√£o estiver presente e for um n√∫mero brasileiro\\n      if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\\n        telefoneFormatado = `55${telefoneFormatado}`;\\n        logger.info(`Adicionado c√≥digo do pa√≠s: ${telefoneFormatado}`);\\n      }\\n    }\\n    \\n    logger.info(`Telefone formatado: ${telefoneFormatado}`);\\n    \\n    return {\\n      nome: nome || 'Sem nome',\\n      telefone: telefoneFormatado,\\n      ativo: ativo\\n    };\\n  })\\n  // Filtrar contatos sem telefone ou inativos\\n  .filter(contato => {\\n    // Verificar se o telefone √© v√°lido (pelo menos 10 d√≠gitos)\\n    const telefoneValido = contato.telefone && contato.telefone.length >= 10;\\n    \\n    if (!telefoneValido) {\\n      logger.warn(`Contato \\\"${contato.nome}\\\" ignorado: n√∫mero de telefone inv√°lido (${contato.telefone})`);\\n    } else if (!contato.ativo) {\\n      logger.info(`Contato \\\"${contato.nome}\\\" ignorado: est√° marcado como inativo`);\\n    } else {\\n      logger.info(`Contato v√°lido: ${contato.nome} (${contato.telefone})`);\\n    }\\n    \\n    return telefoneValido && contato.ativo;\\n  });\\n}\\n\\n// Fun√ß√£o principal para obter todos os contatos de todos os arquivos\\nasync function obterContatos() {\\n  try {\\n    const arquivos = obterArquivosContatos();\\n    \\n    if (arquivos.length === 0) {\\n      logger.warn('Nenhum arquivo de contatos encontrado no diret√≥rio');\\n      return [];\\n    }\\n    \\n    let todosContatos = [];\\n    \\n    for (const arquivo of arquivos) {\\n      const caminhoArquivo = path.join(CONTATOS_DIR, arquivo);\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      \\n      logger.info(`Lendo contatos do arquivo: ${arquivo}`);\\n      \\n      let contatos = [];\\n      if (extensao === '.xlsx') {\\n        contatos = await lerContatosExcel(caminhoArquivo);\\n      } else if (extensao === '.csv') {\\n        contatos = await lerContatosCsv(caminhoArquivo);\\n      }\\n      \\n      logger.info(`${contatos.length} contatos v√°lidos encontrados em ${arquivo}`);\\n      todosContatos = todosContatos.concat(contatos);\\n    }\\n    \\n    // Remover duplicatas baseadas no n√∫mero de telefone\\n    const contatosUnicos = {};\\n    todosContatos.forEach(contato => {\\n      contatosUnicos[contato.telefone] = contato;\\n    });\\n    \\n    const resultado = Object.values(contatosUnicos);\\n    logger.info(`Total de ${resultado.length} contatos √∫nicos encontrados`);\\n    \\n    return resultado;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter contatos: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\nmodule.exports = {\\n  obterContatos,\\n  adicionarNovoContatoNaPlanilha\\n};\"\n    },\n    {\n      \"path\": \"src\\\\leitorDocumentos.js\",\n      \"name\": \"leitorDocumentos.js\",\n      \"extension\": \".js\",\n      \"size\": 6949,\n      \"last_modified\": \"2025-04-03T13:54:43.522193\",\n      \"content\": \"// M√≥dulo para processamento dos documentos base\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst xlsx = require('xlsx');\\nconst csvParser = require('csv-parser');\\nconst pdfParse = require('pdf-parse');\\nconst cheerio = require('cheerio');\\nconst { logger } = require('./utils');\\n\\n// Diret√≥rio de documentos base\\nconst BASE_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\\n\\n// Cache de documentos processados para evitar reprocessamento\\nlet documentosCache = null;\\nlet dataUltimaAtualizacao = null;\\n\\n// Verificar a necessidade de atualiza√ß√£o do cache\\nfunction verificarCacheAtualizado() {\\n  if (!documentosCache || !dataUltimaAtualizacao) {\\n    return false;\\n  }\\n  \\n  // Verificar se algum arquivo foi modificado desde a √∫ltima atualiza√ß√£o\\n  try {\\n    const arquivos = obterArquivosBase();\\n    \\n    for (const arquivo of arquivos) {\\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\\n      const stats = fs.statSync(caminhoArquivo);\\n      \\n      if (stats.mtime > dataUltimaAtualizacao) {\\n        return false;\\n      }\\n    }\\n    \\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao verificar cache: ${erro.message}`);\\n    return false;\\n  }\\n}\\n\\n// Obter a lista de arquivos da base de conhecimento\\nfunction obterArquivosBase() {\\n  try {\\n    const arquivos = fs.readdirSync(BASE_DIR);\\n    return arquivos.filter(arquivo => {\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      return ['.pdf', '.json', '.txt', '.csv', '.xlsx'].includes(extensao);\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao ler diret√≥rio da base de conhecimento: ${erro.message}`);\\n    return [];\\n  }\\n}\\n\\n// Processar um arquivo PDF\\nasync function processarPdf(caminhoArquivo) {\\n  try {\\n    const dataBuffer = fs.readFileSync(caminhoArquivo);\\n    const data = await pdfParse(dataBuffer);\\n    return data.text;\\n  } catch (erro) {\\n    logger.error(`Erro ao processar PDF ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Processar um arquivo JSON\\nfunction processarJson(caminhoArquivo) {\\n  try {\\n    const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n    const data = JSON.parse(conteudo);\\n    \\n    // Extrair textos do JSON (considerando diferentes estruturas poss√≠veis)\\n    return extrairTextosJson(data);\\n  } catch (erro) {\\n    logger.error(`Erro ao processar JSON ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Extrair textos recursivamente de um objeto JSON\\nfunction extrairTextosJson(obj, textos = []) {\\n  if (!obj) return textos;\\n  \\n  if (typeof obj === 'string') {\\n    textos.push(obj);\\n  } else if (Array.isArray(obj)) {\\n    obj.forEach(item => extrairTextosJson(item, textos));\\n  } else if (typeof obj === 'object') {\\n    Object.values(obj).forEach(valor => extrairTextosJson(valor, textos));\\n  }\\n  \\n  return textos.join('\\\\n');\\n}\\n\\n// Processar um arquivo TXT\\nfunction processarTxt(caminhoArquivo) {\\n  try {\\n    return fs.readFileSync(caminhoArquivo, 'utf8');\\n  } catch (erro) {\\n    logger.error(`Erro ao processar TXT ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Processar um arquivo CSV\\nasync function processarCsv(caminhoArquivo) {\\n  return new Promise((resolve, reject) => {\\n    const linhas = [];\\n    \\n    fs.createReadStream(caminhoArquivo)\\n      .pipe(csvParser())\\n      .on('data', (row) => {\\n        linhas.push(Object.values(row).join(' '));\\n      })\\n      .on('end', () => {\\n        resolve(linhas.join('\\\\n'));\\n      })\\n      .on('error', (erro) => {\\n        logger.error(`Erro ao processar CSV ${caminhoArquivo}: ${erro.message}`);\\n        reject(erro);\\n      });\\n  });\\n}\\n\\n// Processar um arquivo Excel\\nfunction processarExcel(caminhoArquivo) {\\n  try {\\n    const workbook = xlsx.readFile(caminhoArquivo);\\n    const resultado = [];\\n    \\n    workbook.SheetNames.forEach(sheetName => {\\n      const worksheet = workbook.Sheets[sheetName];\\n      const dados = xlsx.utils.sheet_to_json(worksheet);\\n      \\n      dados.forEach(linha => {\\n        resultado.push(Object.values(linha).join(' '));\\n      });\\n    });\\n    \\n    return resultado.join('\\\\n');\\n  } catch (erro) {\\n    logger.error(`Erro ao processar Excel ${caminhoArquivo}: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\n// Processar HTML (para arquivos que possam conter HTML)\\nfunction processarHtml(conteudo) {\\n  try {\\n    const $ = cheerio.load(conteudo);\\n    // Remover scripts e estilos\\n    $('script').remove();\\n    $('style').remove();\\n    \\n    // Obter o texto\\n    return $('body').text().trim();\\n  } catch (erro) {\\n    logger.error(`Erro ao processar HTML: ${erro.message}`);\\n    return conteudo;\\n  }\\n}\\n\\n// Obter todo o conte√∫do da base de conhecimento\\nasync function obterConteudoBase() {\\n  // Verificar se o cache est√° atualizado\\n  if (verificarCacheAtualizado()) {\\n    logger.info('Usando cache da base de conhecimento (sem altera√ß√µes desde a √∫ltima leitura)');\\n    return documentosCache;\\n  }\\n  \\n  try {\\n    const arquivos = obterArquivosBase();\\n    \\n    if (arquivos.length === 0) {\\n      logger.warn('Nenhum arquivo encontrado na base de conhecimento');\\n      return '';\\n    }\\n    \\n    logger.info(`Processando ${arquivos.length} arquivos da base de conhecimento...`);\\n    \\n    let conteudoCompleto = '';\\n    \\n    for (const arquivo of arquivos) {\\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\\n      const extensao = path.extname(arquivo).toLowerCase();\\n      \\n      logger.info(`Processando arquivo: ${arquivo}`);\\n      \\n      let conteudo = '';\\n      \\n      switch (extensao) {\\n        case '.pdf':\\n          conteudo = await processarPdf(caminhoArquivo);\\n          break;\\n        case '.json':\\n          conteudo = processarJson(caminhoArquivo);\\n          break;\\n        case '.txt':\\n          conteudo = processarTxt(caminhoArquivo);\\n          break;\\n        case '.csv':\\n          conteudo = await processarCsv(caminhoArquivo);\\n          break;\\n        case '.xlsx':\\n          conteudo = processarExcel(caminhoArquivo);\\n          break;\\n        default:\\n          logger.warn(`Tipo de arquivo n√£o suportado: ${extensao}`);\\n          continue;\\n      }\\n      \\n      // Verificar se o conte√∫do pode conter HTML e process√°-lo se necess√°rio\\n      if (conteudo.includes('<html') || conteudo.includes('<body') || conteudo.includes('<div')) {\\n        conteudo = processarHtml(conteudo);\\n      }\\n      \\n      conteudoCompleto += conteudo + '\\\\n\\\\n';\\n    }\\n    \\n    // Atualizar o cache\\n    documentosCache = conteudoCompleto;\\n    dataUltimaAtualizacao = new Date();\\n    \\n    logger.info('Base de conhecimento processada com sucesso');\\n    return conteudoCompleto;\\n  } catch (erro) {\\n    logger.error(`Erro ao obter conte√∫do da base: ${erro.message}`);\\n    return '';\\n  }\\n}\\n\\nmodule.exports = {\\n  obterConteudoBase\\n};\"\n    },\n    {\n      \"path\": \"src\\\\utils.js\",\n      \"name\": \"utils.js\",\n      \"extension\": \".js\",\n      \"size\": 3074,\n      \"last_modified\": \"2025-04-03T13:54:43.522193\",\n      \"content\": \"// M√≥dulo de fun√ß√µes utilit√°rias\\n\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst moment = require('moment');\\nmoment.locale('pt-br');\\n\\n// Configura√ß√µes dos diret√≥rios\\nconst BASE_CONHECIMENTO_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Hist√≥rico';\\n\\n// Logger simples\\nconst logger = {\\n  info: (mensagem) => {\\n    console.log(`[INFO] ${new Date().toISOString()} - ${mensagem}`);\\n  },\\n  warn: (mensagem) => {\\n    console.warn(`[WARN] ${new Date().toISOString()} - ${mensagem}`);\\n  },\\n  error: (mensagem) => {\\n    console.error(`[ERROR] ${new Date().toISOString()} - ${mensagem}`);\\n  }\\n};\\n\\n// Criar diret√≥rios necess√°rios\\nfunction criarDiretorios() {\\n  try {\\n    [BASE_CONHECIMENTO_DIR, CONTATOS_DIR, HISTORICO_DIR].forEach(dir => {\\n      if (!fs.existsSync(dir)) {\\n        fs.mkdirSync(dir, { recursive: true });\\n        logger.info(`Diret√≥rio criado: ${dir}`);\\n      }\\n    });\\n  } catch (erro) {\\n    logger.error(`Erro ao criar diret√≥rios: ${erro.message}`);\\n  }\\n}\\n\\n// Verificar se um caminho existe\\nfunction caminhoExiste(caminho) {\\n  return fs.existsSync(caminho);\\n}\\n\\n// Formatar data no estilo brasileiro (dia de m√™s de ano)\\nfunction formatarData(data) {\\n  return moment(data).format('D [de] MMMM [de] YYYY');\\n}\\n\\n// Remover acentos de uma string\\nfunction removerAcentos(texto) {\\n  return texto.normalize('NFD').replace(/[\\\\u0300-\\\\u036f]/g, '');\\n}\\n\\n// Limpar string (remover caracteres especiais, espa√ßos extras, etc.)\\nfunction limparString(texto) {\\n  if (!texto) return '';\\n  \\n  return texto\\n    .replace(/\\\\s+/g, ' ')              // Substitui m√∫ltiplos espa√ßos por um √∫nico\\n    .replace(/[^\\\\w\\\\s\\\\-\\\\.,;:!?'\\\"()]/g, '') // Remove caracteres especiais (exceto pontua√ß√£o b√°sica)\\n    .trim();                           // Remove espa√ßos no in√≠cio e fim\\n}\\n\\n// Escapar caracteres especiais para regex\\nfunction escaparRegex(texto) {\\n  return texto.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, '\\\\\\\\$&');\\n}\\n\\n// Gerar um ID √∫nico\\nfunction gerarIdUnico() {\\n  return Date.now().toString(36) + Math.random().toString(36).substring(2);\\n}\\n\\n// Fun√ß√£o para esperar um tempo determinado (√∫til para retry)\\nfunction esperar(ms) {\\n  return new Promise(resolve => setTimeout(resolve, ms));\\n}\\n\\n// Retry de uma fun√ß√£o ass√≠ncrona\\nasync function retryAsync(funcao, tentativas = 3, intervalo = 1000) {\\n  let ultimoErro;\\n  \\n  for (let i = 0; i < tentativas; i++) {\\n    try {\\n      return await funcao();\\n    } catch (erro) {\\n      ultimoErro = erro;\\n      logger.warn(`Tentativa ${i + 1}/${tentativas} falhou: ${erro.message}`);\\n      \\n      if (i < tentativas - 1) {\\n        await esperar(intervalo);\\n      }\\n    }\\n  }\\n  \\n  throw ultimoErro;\\n}\\n\\nmodule.exports = {\\n  logger,\\n  criarDiretorios,\\n  caminhoExiste,\\n  formatarData,\\n  removerAcentos,\\n  limparString,\\n  escaparRegex,\\n  gerarIdUnico,\\n  esperar,\\n  retryAsync\\n};\"\n    },\n    {\n      \"path\": \"src\\\\whatsapp.js\",\n      \"name\": \"whatsapp.js\",\n      \"extension\": \".js\",\n      \"size\": 14929,\n      \"last_modified\": \"2025-04-03T13:54:43.525038\",\n      \"content\": \"// M√≥dulo de conex√£o com WhatsApp usando Baileys (mais leve que Puppeteer)\\n\\nconst { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');\\nconst qrcode = require('qrcode-terminal');\\nconst fs = require('fs-extra');\\nconst path = require('path');\\nconst { logger } = require('./utils');\\nconst historicoMensagens = require('./historicoMensagens');\\nconst { obterContatos, adicionarNovoContatoNaPlanilha } = require('./leitorContatos');\\n\\n// Cliente WhatsApp\\nlet wa = null;\\nlet clienteInicializado = false;\\n\\n// Importar o gerenciador de conversas\\nconst conversasHandler = require('./conversasHandler');\\n\\n// Pasta para armazenar os dados de autentica√ß√£o\\nconst AUTH_FOLDER = process.env.WHATSAPP_SESSION_PATH || './whatsapp-session';\\n\\n// Configura√ß√£o de presen√ßa\\nconst TEMPO_ONLINE = 60000; // 1 minuto em milissegundos\\nlet timerPresenca = null;\\n\\n// Fun√ß√£o para definir o status como offline\\nasync function definirOffline() {\\n  try {\\n    if (wa && clienteInicializado) {\\n      // Definir o status como 'unavailable' (que mostra o \\\"visto por √∫ltimo\\\")\\n      await wa.sendPresenceUpdate('unavailable', null);\\n      logger.info('Status definido como offline (visto por √∫ltimo)');\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao definir status offline: ${erro.message}`);\\n  }\\n}\\n\\n// Fun√ß√£o para gerenciar o status online\\nasync function gerenciarPresenca() {\\n  // Limpar o timer existente, se houver\\n  if (timerPresenca) {\\n    clearTimeout(timerPresenca);\\n  }\\n  \\n  // Definir um novo timer para ficar offline ap√≥s o tempo configurado\\n  timerPresenca = setTimeout(definirOffline, TEMPO_ONLINE);\\n}\\n\\n// Inicializar o cliente WhatsApp\\nasync function iniciarCliente() {\\n  try {\\n    logger.info('Inicializando cliente WhatsApp usando Baileys...');\\n    \\n    // Garantir que a pasta de autentica√ß√£o existe\\n    if (!fs.existsSync(AUTH_FOLDER)) {\\n      fs.mkdirSync(AUTH_FOLDER, { recursive: true });\\n      logger.info(`Diret√≥rio de autentica√ß√£o criado: ${AUTH_FOLDER}`);\\n    }\\n    \\n    // Carregar estado de autentica√ß√£o (se existir)\\n    const { state, saveCreds } = await useMultiFileAuthState(AUTH_FOLDER);\\n    \\n    const nullLogger = {\\n      child: () => nullLogger,\\n      info: () => {},\\n      warn: () => {},\\n      error: () => {},\\n      debug: () => {},\\n      trace: () => {}\\n    };\\n\\n    // Criar o socket WhatsApp\\n    wa = makeWASocket({\\n      auth: state,\\n      printQRInTerminal: true,\\n      defaultQueryTimeoutMs: 60000, // Timeout mais longo para Raspberry Pi\\n      logger: nullLogger\\n    });\\n    \\n    // Manipular eventos de conex√£o e mensagens\\n    wa.ev.on('connection.update', async (update) => {\\n      const { connection, lastDisconnect, qr } = update;\\n      \\n      if (qr) {\\n        // Exibir QR code no terminal\\n        logger.info('QR Code gerado. Escaneie-o com seu WhatsApp:');\\n        qrcode.generate(qr, { small: true });\\n      }\\n      \\n      if (connection === 'close') {\\n        const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;\\n        logger.warn(`Conex√£o fechada devido a ${lastDisconnect.error}. ${shouldReconnect ? 'Reconectando...' : 'N√£o ser√° reconectado.'}`);\\n        \\n        clienteInicializado = false;\\n        \\n        if (shouldReconnect) {\\n          // Tentar reconectar ap√≥s um breve intervalo\\n          setTimeout(iniciarCliente, 5000);\\n        }\\n      } else if (connection === 'open') {\\n        logger.info('Cliente WhatsApp conectado com sucesso!');\\n        clienteInicializado = true;\\n        \\n        // Definir como online inicialmente\\n        await wa.sendPresenceUpdate('available', null);\\n        // Iniciar o timer para ficar offline\\n        gerenciarPresenca();\\n      }\\n    });\\n    \\n    // Salvar credenciais quando atualizadas\\n    wa.ev.on('creds.update', saveCreds);\\n    \\n    // Manipular mensagens recebidas\\n    wa.ev.on('messages.upsert', async (m) => {\\n      if (m.type === 'notify') {\\n        for (const msg of m.messages) {\\n          // Processar apenas mensagens de outros (n√£o enviadas por n√≥s)\\n          if (!msg.key.fromMe) {\\n            await processarMensagemRecebida(msg);\\n          }\\n        }\\n      }\\n    });\\n    \\n    logger.info('Sistema de eventos do WhatsApp inicializado');\\n    return wa;\\n  } catch (erro) {\\n    logger.error(`Erro ao inicializar cliente WhatsApp: ${erro.message}`);\\n    logger.error(erro.stack);\\n    throw erro;\\n  }\\n}\\n\\n// Processar mensagens recebidas\\nasync function processarMensagemRecebida(msg) {\\n  try {\\n    \\n    // Verificar se √© uma mensagem de grupo\\n    if (msg.key.remoteJid.includes('@g.us')) {\\n      return; // Ignorar mensagens de grupos\\n    }\\n    \\n    // Obter informa√ß√µes do remetente\\n    const remetente = msg.key.remoteJid;\\n    const telefone = remetente.split('@')[0];\\n    \\n    // Verificar se n√£o √© uma mensagem muito antiga\\n    const timestampMensagem = msg.messageTimestamp * 1000;\\n    const agora = Date.now();\\n    const diffMinutos = (agora - timestampMensagem) / (1000 * 60);\\n    \\n    if (diffMinutos > 10) {\\n      logger.info(`Ignorando mensagem antiga (${Math.floor(diffMinutos)} minutos atr√°s)`);\\n      return;\\n    }\\n\\n    // Ao receber uma mensagem, definir como online\\n    await wa.sendPresenceUpdate('available', remetente);\\n    gerenciarPresenca(); // Iniciar o timer para ficar offline\\n\\n    // Carregar hist√≥rico de conversa\\n    const caminhoArquivo = path.join(process.env.CONVERSAS_DIR || './Conversas', `${telefone}.json`);\\n    let devocionalJaEnviado = false;\\n    \\n    if (fs.existsSync(caminhoArquivo)) {\\n      try {\\n        const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\\n        const historico = JSON.parse(conteudo);\\n        \\n        // Verificar se j√° enviamos um devocional\\n        devocionalJaEnviado = historico && historico.ultimoDevocional;\\n        \\n        logger.info(`Usu√°rio ${telefone}: ${devocionalJaEnviado ? 'j√° recebeu devocional' : 'ainda n√£o recebeu devocional'}`);\\n      } catch (erroLeitura) {\\n        logger.error(`Erro ao ler hist√≥rico para ${telefone}: ${erroLeitura.message}`);\\n      }\\n    } else {\\n      logger.info(`Nenhum hist√≥rico encontrado para ${telefone}, enviando devocional de boas-vindas`);\\n    }\\n\\n    if (!devocionalJaEnviado) {\\n      logger.info(`Primeira intera√ß√£o detectada para o n√∫mero ${telefone}`);\\n    \\n      // Adicionar o novo contato √† Planilha\\n      try {\\n        // Tenta extrair o nome do contato\\n        let nomeContato = \\\"Novo Contato\\\";\\n        \\n        // Tente pelo pushName que pode estar dispon√≠vel na pr√≥pria mensagem\\n        if (msg.pushName) {\\n          nomeContato = msg.pushName;\\n        }\\n        // Ou pelo objeto key da mensagem\\n        else if (msg.key && msg.key.pushName) {\\n          nomeContato = msg.key.pushName;\\n        }\\n        \\n        // Adicionar √† Planilha\\n        await adicionarNovoContatoNaPlanilha(telefone, nomeContato);\\n        logger.info(`Contato ${telefone} (${nomeContato}) adicionado √† planilha de contatos`);\\n      } catch (erroContato) {\\n        logger.error(`Erro ao adicionar contato √† planilha: ${erroContato.message}`);\\n      }\\n      \\n      // Buscar o √∫ltimo devocional enviado hoje\\n      const devocionalHoje = await historicoMensagens.obterUltimoDevocionalEnviado();\\n      if (devocionalHoje) {\\n        \\n        // Enviar mensagem de boas-vindas\\n        await wa.sendMessage(remetente, { \\n          text: \\\"Ol√° üòÄ! Seja bem-vindo(a) ao Whatsapp Devocional-IA. Aqui est√° o devocional de hoje:\\\" \\n        });\\n        \\n        // Pequena pausa\\n        await new Promise(resolve => setTimeout(resolve, 1500));\\n        \\n        // Enviar o devocional\\n        await wa.sendMessage(remetente, { text: devocionalHoje });\\n        \\n        // Registrar o devocional enviado para este contato\\n        await conversasHandler.registrarDevocionalEnviado(telefone, devocionalHoje);\\n        logger.info(`Devocional do dia enviado para novo contato: ${telefone}`);\\n        return;\\n      } else {\\n        logger.warn(`N√£o foi poss√≠vel encontrar um devocional para enviar ao novo contato ${telefone}`);\\n      }\\n    }\\n    \\n    // Verificar o tipo de mensagem\\n    const messageType = Object.keys(msg.message || {})[0];\\n    \\n    // Processar √°udio\\n    if (['audioMessage', 'pttMessage'].includes(messageType)) {\\n      logger.info(`√Åudio recebido de ${telefone}, respondendo com mensagem padr√£o`);\\n      \\n      // Mensagens gentis e educadas para responder a √°udios\\n      const mensagensAudio = [\\n        \\\"Ol√°! Recebi seu √°udio, mas ainda n√£o consigo process√°-lo. Voc√™ poderia, por gentileza, enviar sua pergunta ou coment√°rio como mensagem de texto? Assim poderei lhe ajudar melhor. üôè\\\",\\n        \\\"Agrade√ßo pelo seu √°udio! No momento, n√£o disponho da capacidade de ouvi-lo. Poderia, por favor, compartilhar seu pensamento ou pergunta em forma de texto? Ficarei feliz em responder!\\\",\\n        \\\"Recebi sua mensagem de voz! Infelizmente, ainda n√£o consigo compreender √°udios. Se puder enviar o mesmo conte√∫do em texto, ser√° um prazer conversar sobre o devocional de hoje ou qualquer outro assunto espiritual.\\\"\\n      ];\\n      \\n      // Escolher uma mensagem aleatoriamente\\n      const respostaAudio = mensagensAudio[Math.floor(Math.random() * mensagensAudio.length)];\\n      \\n      // Indicar que est√° digitando (simulando digita√ß√£o)\\n      await wa.sendPresenceUpdate('composing', remetente);\\n      \\n      // Pequena pausa para simular digita√ß√£o (entre 1-3 segundos)\\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\\n      \\n      // Enviar a resposta\\n      await wa.sendMessage(remetente, { text: respostaAudio });\\n      logger.info(`Resposta para √°udio enviada para ${telefone}`);\\n      \\n      // Reiniciar o timer de presen√ßa\\n      gerenciarPresenca();\\n      return;\\n    }\\n    \\n    // Extrair o conte√∫do da mensagem de texto\\n    let conteudo = '';\\n    \\n    if (messageType === 'conversation') {\\n      conteudo = msg.message.conversation;\\n    } else if (messageType === 'extendedTextMessage') {\\n      conteudo = msg.message.extendedTextMessage.text;\\n    } else {\\n      // Outros tipos de mensagem (imagem, v√≠deo, etc.)\\n      conteudo = \\\"M√≠dia recebida\\\";\\n    }\\n    \\n    logger.info(`Mensagem recebida de ${telefone}: ${conteudo.substring(0, 50)}${conteudo.length > 50 ? '...' : ''}`);\\n    \\n    // Verificar se a mensagem precisa de resposta\\n    if (conversasHandler.ePergunta(conteudo) || conteudo.length >= 10) {\\n      logger.info(`Gerando resposta para mensagem de ${telefone}...`);\\n      \\n      // Indicar que est√° digitando (simulando digita√ß√£o)\\n      await wa.sendPresenceUpdate('composing', remetente);\\n      \\n      // Gerar a resposta\\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\\n      \\n      // Calcular tempo de digita√ß√£o baseado no tamanho da resposta\\n      // M√©dia de digita√ß√£o: cerca de 5 caracteres por segundo (ajuste conforme necess√°rio)\\n      const tempoDigitacao = Math.min(Math.max(resposta.length / 5 * 1000, 2000), 8000);\\n      \\n      // Simular tempo de digita√ß√£o\\n      await new Promise(resolve => setTimeout(resolve, tempoDigitacao));\\n      \\n      // Parar de \\\"digitar\\\"\\n      await wa.sendPresenceUpdate('paused', remetente);\\n      \\n      // Pequena pausa antes de enviar (como se estivesse revisando)\\n      await new Promise(resolve => setTimeout(resolve, 500));\\n      \\n      // Enviar a resposta\\n      await wa.sendMessage(remetente, { text: resposta });\\n      \\n      logger.info(`Resposta enviada para ${telefone}`);\\n    } else {\\n      logger.info(`Mensagem curta, enviando resposta simples`);\\n      \\n      // Indicar que est√° digitando\\n      await wa.sendPresenceUpdate('composing', remetente);\\n      \\n      // Para mensagens curtas ou agradecimentos, enviar uma resposta simples\\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\\n      \\n      // Simular digita√ß√£o r√°pida (1-3 segundos)\\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\\n      \\n      // Enviar resposta\\n      await wa.sendMessage(remetente, { text: resposta });\\n    }\\n    \\n    // Reiniciar o timer de presen√ßa ap√≥s enviar mensagem\\n    gerenciarPresenca();\\n  } catch (erro) {\\n    logger.error(`Erro ao processar mensagem recebida: ${erro.message}`);\\n    try {\\n      // Tentar enviar uma mensagem de erro para o usu√°rio\\n      await wa.sendMessage(msg.key.remoteJid, { \\n        text: \\\"Desculpe, ocorreu um erro ao processar sua mensagem. Por favor, tente novamente mais tarde.\\\" \\n      });\\n    } catch (erroEnvio) {\\n      logger.error(`Erro ao enviar mensagem de erro: ${erroEnvio.message}`);\\n    }\\n  }\\n}\\n\\n// Verificar se o cliente est√° pronto\\nfunction clientePronto() {\\n  return wa !== null && clienteInicializado;\\n}\\n\\n// Enviar mensagem para um contato\\nasync function enviarMensagem(telefone, mensagem) {\\n  try {\\n    if (!clientePronto()) {\\n      throw new Error('Cliente WhatsApp n√£o est√° pronto');\\n    }\\n    \\n    // Formatar o n√∫mero de telefone (remover caracteres n√£o num√©ricos)\\n    const numeroFormatado = telefone.toString().replace(/\\\\D/g, '');\\n    \\n    // Garantir que o n√∫mero tenha o formato correto para o WhatsApp\\n    const chatId = `${numeroFormatado}@s.whatsapp.net`;\\n    \\n    // Definir como online ao enviar mensagem\\n    await wa.sendPresenceUpdate('available', chatId);\\n    \\n    // Enviar a mensagem\\n    await wa.sendMessage(chatId, { text: mensagem });\\n    \\n    // Iniciar o timer para ficar offline\\n    gerenciarPresenca();\\n    \\n    return true;\\n  } catch (erro) {\\n    logger.error(`Erro ao enviar mensagem: ${erro.message}`);\\n    throw erro;\\n  }\\n}\\n\\n// Encerrar o cliente\\nasync function encerrarCliente() {\\n  try {\\n    if (wa) {\\n      // Definir como offline antes de desconectar\\n      try {\\n        await definirOffline();\\n      } catch (erroPresenca) {\\n        logger.warn(`Erro ao definir offline antes de encerrar: ${erroPresenca.message}`);\\n      }\\n      \\n      // Limpar o timer de presen√ßa\\n      if (timerPresenca) {\\n        clearTimeout(timerPresenca);\\n        timerPresenca = null;\\n      }\\n      \\n      // N√£o h√° um m√©todo espec√≠fico para \\\"destruir\\\" no Baileys,\\n      // mas podemos remover os listeners e limpar refer√™ncias\\n      wa.ev.removeAllListeners();\\n      wa = null;\\n      clienteInicializado = false;\\n      logger.info('Cliente WhatsApp encerrado');\\n    }\\n  } catch (erro) {\\n    logger.error(`Erro ao encerrar cliente WhatsApp: ${erro.message}`);\\n  }\\n}\\n\\nmodule.exports = {\\n  iniciarCliente,\\n  clientePronto,\\n  enviarMensagem,\\n  encerrarCliente,\\n};\"\n    }\n  ]\n}"
    },
    {
      "path": "package.json",
      "name": "package.json",
      "extension": ".json",
      "size": 906,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "{\n  \"name\": \"whatsapp-devocional-ia\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Bot de WhatsApp que envia mensagens devocionais di√°rias geradas por IA e responde a perguntas\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"start\": \"NODE_OPTIONS=\\\"--max-old-space-size=512\\\" node src/index.js\",\n    \"test:devocional\": \"node scripts/testar_devocional.js\",\n    \"test:conversas\": \"node scripts/testar_conversas.js\",\n    \"setup:contatos\": \"node scripts/criar_exemplo_contato.js\"\n  },\n  \"dependencies\": {\n    \"@google/generative-ai\": \"^0.1.1\",\n    \"@whiskeysockets/baileys\": \"^6.6.0\",\n    \"cheerio\": \"^1.0.0-rc.12\",\n    \"csv-parser\": \"^3.0.0\",\n    \"dotenv\": \"^16.0.3\",\n    \"fs-extra\": \"^11.1.0\",\n    \"jimp\": \"^0.16.13\",\n    \"moment\": \"^2.29.4\",\n    \"node-schedule\": \"^2.1.1\",\n    \"pdf-parse\": \"^1.1.1\",\n    \"qrcode-terminal\": \"^0.12.0\",\n    \"sharp\": \"^0.33.2\",\n    \"xlsx\": \"^0.18.5\"\n  }\n}"
    },
    {
      "path": "README.md",
      "name": "README.md",
      "extension": ".md",
      "size": 7771,
      "last_modified": "2025-04-03T13:54:43.498753",
      "content": "## Funcionalidade de Di√°logo Interativo\n\nEsta vers√£o do sistema inclui suporte para di√°logo individualizado com os usu√°rios:\n\n### Como funciona:\n\n1. **Envio do Devocional**: O sistema envia automaticamente o devocional di√°rio para todos os contatos cadastrados no hor√°rio programado.\n\n2. **Recebimento de Mensagens**: Quando um usu√°rio responde ou faz uma pergunta sobre o devocional, o sistema:\n   - Analisa se a mensagem requer uma resposta elaborada\n   - Usa a IA para gerar uma resposta personalizada considerando:\n     - O devocional enviado recentemente\n     - O hist√≥rico de conversa com aquele usu√°rio espec√≠fico\n     - A base de conhecimento religiosa\n\n3. **Contexto Individualizado**: O sistema mant√©m hist√≥ricos de conversa separados para cada usu√°rio, permitindo:\n   - Respostas personalizadas\n   - Refer√™ncias a mensagens anteriores da mesma conversa\n   - Continuidade no di√°logo\n\n### Configura√ß√µes:\n\nNo arquivo `.env` voc√™ pode ajustar:\n\n- `RESPONDER_AUTOMATICAMENTE=true` - Ativar/desativar resposta autom√°tica\n- `MAX_HISTORICO_CONVERSAS=10` - N√∫mero de mensagens armazenadas por conversa\n\n### Limita√ß√µes:\n\n- O sistema foi projetado para responder a perguntas relacionadas ao devocional\n- Mensagens curtas ou simples recebem respostas padr√£o mais breves\n- A IA foi instru√≠da a manter um tom amig√°vel, acolhedor e espiritual# WhatsApp Devocional Di√°rio com IA\n\nUm bot de WhatsApp automatizado que envia mensagens devocionais di√°rias geradas por IA para uma lista de contatos pr√©-definida.\n\n## Testes e Exemplos\n\nO sistema inclui scripts de teste para verificar componentes individuais:\n\n### Testar gera√ß√£o de devocionais:\n\n```bash\nnode scripts/testar_devocional.js\n```\n\nEste script gera um devocional usando a API do Google Gemini e sua base de conhecimento, sem enviar mensagens para os contatos. O resultado √© exibido no console e salvo no arquivo `scripts/devocional_gerado.txt`.\n\n### Criar arquivo de contatos de exemplo:\n\n```bash\nnode scripts/criar_exemplo_contatos.js\n```\n\nEste script cria um arquivo Excel com contatos de exemplo na pasta `Contatos/` que voc√™ pode usar como refer√™ncia para o formato correto.\n\n### Testar sistema de conversas com IA:\n\n```bash\nnode scripts/testar_conversas.js\n```\n\nEste script simula uma conversa interativa entre um usu√°rio e o bot, permitindo testar como o sistema responde a perguntas sobre o devocional enviado. Voc√™ pode digitar mensagens como se fosse um usu√°rio e ver as respostas geradas pela IA. Caracter√≠sticas\n\n- ü§ñ Integra√ß√£o com o Google Gemini para gera√ß√£o de conte√∫do devocional\n- üì± Envio autom√°tico de mensagens via WhatsApp\n- üí¨ **Di√°logo individualizado com usu√°rios atrav√©s de IA generativa**\n- üìä Suporte para leitura de contatos de arquivos Excel e CSV\n- üìö Base de conhecimento personaliz√°vel com suporte para diversos formatos de arquivo\n- üìÖ Agendamento di√°rio autom√°tico\n- üìù Registro de hist√≥rico para evitar repeti√ß√£o de vers√≠culos\n- üß© Arquitetura modular para f√°cil manuten√ß√£o e extens√£o\n\n## Requisitos\n\n- Node.js (v14 ou superior)\n- Acesso √† API do Google Gemini (chave de API)\n- Um dispositivo ou servidor para executar o bot\n\n## Estrutura do Projeto\n\n```\nüìÅ WhatsApp-Devocional-IA/\n‚îú‚îÄ‚îÄ üìÅ Base_de_conhecimento/     # Coloque aqui seus documentos de refer√™ncia\n‚îú‚îÄ‚îÄ üìÅ Contatos/                 # Coloque aqui suas planilhas de contatos\n‚îú‚îÄ‚îÄ üìÅ Conversas/                # Armazena hist√≥ricos de conversas individuais\n‚îú‚îÄ‚îÄ üìÅ Hist√≥rico/                # Hist√≥rico de mensagens enviadas\n‚îÇ   ‚îî‚îÄ‚îÄ üìÑ historico.json        # Registro autom√°tico dos envios\n‚îú‚îÄ‚îÄ üìÅ src/                      # C√≥digo fonte do sistema\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ index.js              # Ponto de entrada da aplica√ß√£o\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ whatsapp.js           # M√≥dulo de conex√£o com WhatsApp\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ geradorDevocional.js  # M√≥dulo gerador de devocionais com IA\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ leitorDocumentos.js   # M√≥dulo para processamento dos documentos base\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ leitorContatos.js     # M√≥dulo para leitura da lista de contatos\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ historicoMensagens.js # M√≥dulo para gerenciamento do hist√≥rico\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ conversasHandler.js   # M√≥dulo para di√°logo individualizado com IA\n‚îÇ   ‚îî‚îÄ‚îÄ üìÑ utils.js              # Fun√ß√µes utilit√°rias\n‚îú‚îÄ‚îÄ üìÅ scripts/                  # Scripts de teste e utilit√°rios\n‚îú‚îÄ‚îÄ üìÑ package.json              # Depend√™ncias do projeto\n‚îú‚îÄ‚îÄ üìÑ .env                      # Configura√ß√µes do projeto\n‚îî‚îÄ‚îÄ üìÑ README.md                 # Esta documenta√ß√£o\n```\n\n## Configura√ß√£o\n\n1. Clone este reposit√≥rio\n2. Execute `npm install` para instalar as depend√™ncias\n3. Copie o arquivo `.env.example` para `.env` e configure:\n   - Chave de API do Google Gemini\n   - Hor√°rio de envio das mensagens\n   - Outras configura√ß√µes conforme necess√°rio\n4. Adicione seus documentos de refer√™ncia √† pasta `Base_de_conhecimento`\n5. Adicione sua lista de contatos √† pasta `Contatos` (em formato Excel ou CSV)\n\n### Formato da Planilha de Contatos\n\nA planilha deve conter pelo menos as seguintes colunas:\n- `Nome`: Nome do contato\n- `Telefone`: N√∫mero de telefone com c√≥digo do pa√≠s (ex: 5511987654321)\n- `Ativo`: Opcional, para indicar se o contato deve receber mensagens (Sim/N√£o)\n\n## Uso\n\nPara iniciar o bot:\n\n```bash\nnpm start\n```\n\nNa primeira execu√ß√£o, ser√° exibido um QR Code que deve ser escaneado com o WhatsApp do seu celular para autenticar a sess√£o.\n\n##\n\n## Base de Conhecimento\n\nA pasta `Base_de_conhecimento` aceita os seguintes formatos de arquivo:\n- PDF (.pdf)\n- Texto simples (.txt)\n- JSON (.json)\n- Excel (.xlsx)\n- CSV (.csv)\n\nEstes documentos ser√£o utilizados como refer√™ncia para a IA gerar os devocionais di√°rios.\n\n## Personaliza√ß√£o\n\nPara personalizar o formato dos devocionais, edite o arquivo `src/geradorDevocional.js`.\n\n## Manuten√ß√£o\n\nO sistema mant√©m um hist√≥rico de mensagens enviadas para evitar repeti√ß√£o de vers√≠culos. Este hist√≥rico √© armazenado em `Hist√≥rico/historico.json`.\n\n## Solu√ß√£o de Problemas\n\n### Cliente do WhatsApp n√£o conecta\n- Verifique se n√£o h√° outra sess√£o do WhatsApp Web ativa\n- Apague a pasta `whatsapp-session` e reinicie o sistema\n- Certifique-se de escanear o QR code quando solicitado\n\n### Erros na gera√ß√£o do devocional\n- Verifique se a chave de API do Google Gemini est√° correta no arquivo `.env`\n- Certifique-se de usar o nome correto do modelo na API (gemini-1.5-pro ou gemini-pro)\n- Verifique se h√° documentos v√°lidos na pasta `Base_de_conhecimento`\n- Execute o script de teste `scripts/testar_devocional.js` para verificar se a gera√ß√£o funciona\n\n### Problemas com contatos\n- Verifique se o arquivo de contatos est√° no formato correto (Excel ou CSV)\n- Certifique-se de que os contatos tenham pelo menos uma coluna chamada \"Nome\" e outra \"Telefone\"\n- Confirme que os n√∫meros de telefone est√£o completos com c√≥digo do pa√≠s (ex: 5511987654321)\n- Use o arquivo de exemplo `contatos_exemplo.xlsx` como refer√™ncia\n- Para diagn√≥stico, verifique os logs detalhados que mostram como os contatos est√£o sendo processados\n\n### Erros no hist√≥rico de mensagens\n- Se ocorrerem erros relacionados ao hist√≥rico, verifique se o arquivo `historico.json` existe e tem o formato correto\n- Em caso de problemas persistentes, exclua o arquivo `Hist√≥rico/historico.json` e deixe o sistema recri√°-lo automaticamente\n\n## Licen√ßa\n\nEste projeto est√° licenciado sob a Licen√ßa MIT - veja o arquivo LICENSE para detalhes."
    },
    {
      "path": "Hist√≥rico\\historico.json",
      "name": "historico.json",
      "extension": ".json",
      "size": 270,
      "last_modified": "2025-04-03T13:54:43.498753",
      "content": "[\n  {\n    \"date\": \"1 de abril de 2025\",\n    \"verse\": \"\\\"Confie no Senhor de todo o seu cora√ß√£o.\\\" (Prov√©rbios 3:5)\"\n  },\n  {\n    \"date\": \"1 de abril de 2025\",\n    \"verse\": \"\\\"Alegrem-se na esperan√ßa, sejam pacientes na tribula√ß√£o.\\\" (Romanos 12:12)\"\n  }\n]"
    },
    {
      "path": "scripts\\criar_exemplo_contato.js",
      "name": "criar_exemplo_contato.js",
      "extension": ".js",
      "size": 1594,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// Script para criar um arquivo de exemplo de contatos\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\n\n// Diret√≥rio e arquivo\nconst CONTATOS_DIR = '../Contatos';\nconst ARQUIVO_EXEMPLO = path.join(CONTATOS_DIR, 'contatos_exemplo.xlsx');\n\n// Garantir que o diret√≥rio exista\nif (!fs.existsSync(CONTATOS_DIR)) {\n  fs.mkdirSync(CONTATOS_DIR, { recursive: true });\n  console.log(`Diret√≥rio criado: ${CONTATOS_DIR}`);\n}\n\n// Dados de exemplo\nconst contatos = [\n  { \n    Nome: 'Jo√£o Silva', \n    Telefone: '5511987654321', \n    Ativo: 'Sim',\n    Observacoes: 'Contato principal'\n  },\n  { \n    Nome: 'Maria Oliveira', \n    Telefone: '5521998765432', \n    Ativo: 'Sim',\n    Observacoes: 'Contato secund√°rio'\n  },\n  { \n    Nome: 'Pedro Santos', \n    Telefone: '5531987654321', \n    Ativo: 'N√£o',\n    Observacoes: 'Desativado temporariamente'\n  },\n  { \n    Nome: 'Ana Costa', \n    Telefone: '5541999887766', \n    Ativo: 'Sim',\n    Observacoes: 'Novo contato'\n  },\n  { \n    Nome: 'Carlos Pereira', \n    Telefone: '5551988776655', \n    Ativo: 'Sim',\n    Observacoes: ''\n  }\n];\n\n// Criar workbook e adicionar dados\nconst workbook = xlsx.utils.book_new();\nconst worksheet = xlsx.utils.json_to_sheet(contatos);\n\n// Adicionar a planilha ao workbook\nxlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\n\n// Salvar o arquivo\nxlsx.writeFile(workbook, ARQUIVO_EXEMPLO);\n\nconsole.log(`Arquivo de exemplo criado: ${ARQUIVO_EXEMPLO}`);\nconsole.log('Modelo de contatos:');\nconsole.table(contatos);"
    },
    {
      "path": "scripts\\testar_devocional.js",
      "name": "testar_devocional.js",
      "extension": ".js",
      "size": 3225,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// Script para testar o sistema de conversas individualizadas com IA\n\nrequire('dotenv').config({ path: '../.env' });\nconst moment = require('moment');\nmoment.locale('pt-br');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst readline = require('readline');\n\n// Configurar o ambiente para execu√ß√£o independente\nprocess.env.BASE_CONHECIMENTO_DIR = path.resolve(__dirname, '../Base_de_conhecimento');\nprocess.env.CONVERSAS_DIR = path.resolve(__dirname, '../Conversas');\n\n// Importar m√≥dulos\nconst conversasHandler = require('../src/conversasHandler');\nconst { formatarData, logger } = require('../src/utils');\n\n// Configurar interface de linha de comando\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// Telefone de teste\nconst TELEFONE_TESTE = '5511999999999';\n\n// Devocional de exemplo para contextualizar a conversa\nconst devocionalExemplo = `${formatarData(new Date())}\n\nVers√≠culo: \"N√£o andeis ansiosos por coisa alguma; antes em tudo sejam os vossos pedidos conhecidos diante de Deus pela ora√ß√£o e s√∫plica com a√ß√µes de gra√ßas. E a paz de Deus, que excede todo entendimento, guardar√° os vossos cora√ß√µes e as vossas mentes em Cristo Jesus.\" (Filipenses 4:6-7)\n\nReflex√£o: A ansiedade tem sido um desafio comum em nossos dias. Este vers√≠culo nos lembra que podemos trazer todas as nossas preocupa√ß√µes a Deus atrav√©s da ora√ß√£o. Quando escolhemos confiar nEle ao inv√©s de nos sobrecarregarmos com preocupa√ß√µes, experimentamos uma paz que vai al√©m da compreens√£o humana. √â uma promessa poderosa para nossos momentos de inquieta√ß√£o.\n\nPr√°tica: Hoje, quando sentir ansiedade surgindo, fa√ßa uma pausa para respirar e apresente a situa√ß√£o a Deus em ora√ß√£o, agradecendo antecipadamente por Sua interven√ß√£o.`;\n\n// Fun√ß√£o para inicializar a conversa\nasync function iniciarConversa() {\n  console.log('=== TESTE DO SISTEMA DE CONVERSAS ===\\n');\n  console.log('Simulando uma conversa individualizada com o bot\\n');\n  \n  // Registrar o devocional de exemplo\n  await conversasHandler.registrarDevocionalEnviado(TELEFONE_TESTE, devocionalExemplo);\n  \n  console.log('Devocional enviado hoje:');\n  console.log(devocionalExemplo);\n  console.log('\\n-------------------------------------------\\n');\n  console.log('Digite suas mensagens como se fosse um usu√°rio respondendo ao devocional.');\n  console.log('Digite \"sair\" para encerrar o teste.\\n');\n  \n  perguntarUsuario();\n}\n\n// Fun√ß√£o para processar a entrada do usu√°rio\nfunction perguntarUsuario() {\n  rl.question('Voc√™: ', async (mensagem) => {\n    if (mensagem.toLowerCase() === 'sair') {\n      console.log('\\nEncerrando teste...');\n      rl.close();\n      return;\n    }\n    \n    console.log('\\nProcessando mensagem...');\n    \n    try {\n      // Gerar resposta do bot\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(TELEFONE_TESTE, mensagem);\n      \n      console.log(`\\nBot: ${resposta}\\n`);\n    } catch (erro) {\n      console.error('Erro ao gerar resposta:', erro.message);\n    }\n    \n    // Continuar a conversa\n    perguntarUsuario();\n  });\n}\n\n// Iniciar o teste\niniciarConversa();"
    },
    {
      "path": "src\\adicionarContato.js",
      "name": "adicionarContato.js",
      "extension": ".js",
      "size": 8492,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// M√≥dulo para adicionar novos contatos √† planilha\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\nconst csvParser = require('csv-parser');\nconst { logger } = require('./utils');\n\n// Diret√≥rio de contatos\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\n\n// Obter a lista de arquivos de contatos dispon√≠veis\nfunction obterArquivosContatos() {\n  try {\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\n    return arquivos.filter(arquivo => {\n      const extensao = path.extname(arquivo).toLowerCase();\n      return extensao === '.xlsx' || extensao === '.csv';\n    });\n  } catch (erro) {\n    logger.error(`Erro ao ler diret√≥rio de contatos: ${erro.message}`);\n    return [];\n  }\n}\n\n// Adicionar novo contato √† planilha\nasync function adicionarNovoContatoNaPlanilha(telefone, nomeContato = \"Novo Contato\") {\n  try {\n    const arquivos = obterArquivosContatos();\n    \n    if (arquivos.length === 0) {\n      logger.warn('Nenhum arquivo de contatos encontrado. Criando novo arquivo.');\n      return criarNovoArquivoContatos(telefone, nomeContato);\n    }\n    \n    // Usar o primeiro arquivo encontrado (normalmente contatos_exemplo.xlsx)\n    const arquivoContatos = path.join(CONTATOS_DIR, arquivos[0]);\n    const extensao = path.extname(arquivoContatos).toLowerCase();\n    \n    // Verificar se √© Excel ou CSV\n    if (extensao === '.xlsx') {\n      return adicionarContatoExcel(arquivoContatos, telefone, nomeContato);\n    } else if (extensao === '.csv') {\n      return adicionarContatoCsv(arquivoContatos, telefone, nomeContato);\n    } else {\n      logger.error(`Formato de arquivo n√£o suportado: ${extensao}`);\n      return false;\n    }\n  } catch (erro) {\n    logger.error(`Erro ao adicionar novo contato ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Adicionar contato a um arquivo Excel\nasync function adicionarContatoExcel(caminhoArquivo, telefone, nomeContato) {\n  try {\n    logger.info(`Adicionando contato ${telefone} ao arquivo Excel: ${caminhoArquivo}`);\n    \n    // Formatar o telefone conforme o padr√£o\n    const telefoneFormatado = formatarTelefone(telefone);\n    \n    // Ler o arquivo Excel existente\n    const workbook = xlsx.readFile(caminhoArquivo, {\n      cellDates: true,\n      cellNF: true,\n      cellText: true\n    });\n    \n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\n      logger.error('Arquivo Excel sem planilhas');\n      return false;\n    }\n    \n    // Usar a primeira planilha\n    const sheetName = workbook.SheetNames[0];\n    const worksheet = workbook.Sheets[sheetName];\n    \n    // Converter para JSON para manipula√ß√£o\n    const dados = xlsx.utils.sheet_to_json(worksheet, {\n      defval: '',\n      raw: false\n    });\n    \n    // Verificar se o contato j√° existe\n    const contatoExistente = dados.find(contato => {\n      // Normalizar n√∫meros de telefone para compara√ß√£o\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\D/g, '');\n      const telefoneNovo = telefoneFormatado.replace(/\\D/g, '');\n      \n      return telefoneExistente === telefoneNovo || \n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \n             `55${telefoneExistente}` === telefoneNovo;\n    });\n    \n    if (contatoExistente) {\n      logger.info(`Contato ${telefone} j√° existe na planilha.`);\n      return false;\n    }\n    \n    // Adicionar o novo contato\n    const novoContato = {\n      Nome: nomeContato,\n      Telefone: telefoneFormatado,\n      Ativo: 'Sim',\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\n    };\n    \n    dados.push(novoContato);\n    \n    // Converter de volta para planilha\n    const novaWorksheet = xlsx.utils.json_to_sheet(dados);\n    workbook.Sheets[sheetName] = novaWorksheet;\n    \n    // Salvar o arquivo atualizado\n    xlsx.writeFile(workbook, caminhoArquivo);\n    \n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado √† planilha com sucesso.`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao adicionar contato no Excel: ${erro.message}`);\n    return false;\n  }\n}\n\n// Adicionar contato a um arquivo CSV\nasync function adicionarContatoCsv(caminhoArquivo, telefone, nomeContato) {\n  try {\n    logger.info(`Adicionando contato ${telefone} ao arquivo CSV: ${caminhoArquivo}`);\n    \n    // Formatar o telefone conforme o padr√£o\n    const telefoneFormatado = formatarTelefone(telefone);\n    \n    // Ler o arquivo CSV existente\n    const contatos = await new Promise((resolve, reject) => {\n      const linhas = [];\n      \n      fs.createReadStream(caminhoArquivo)\n        .pipe(csvParser())\n        .on('data', (row) => {\n          linhas.push(row);\n        })\n        .on('end', () => {\n          resolve(linhas);\n        })\n        .on('error', (erro) => {\n          reject(erro);\n        });\n    });\n    \n    // Verificar se o contato j√° existe\n    const contatoExistente = contatos.find(contato => {\n      // Normalizar n√∫meros de telefone para compara√ß√£o\n      const telefoneExistente = String(contato.Telefone || '').replace(/\\D/g, '');\n      const telefoneNovo = telefoneFormatado.replace(/\\D/g, '');\n      \n      return telefoneExistente === telefoneNovo || \n             telefoneExistente === telefoneNovo.replace(/^55/, '') || \n             `55${telefoneExistente}` === telefoneNovo;\n    });\n    \n    if (contatoExistente) {\n      logger.info(`Contato ${telefone} j√° existe no arquivo CSV.`);\n      return false;\n    }\n    \n    // Adicionar o novo contato\n    const novoContato = {\n      Nome: nomeContato,\n      Telefone: telefoneFormatado,\n      Ativo: 'Sim',\n      Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\n    };\n    \n    contatos.push(novoContato);\n    \n    // Obter os cabe√ßalhos\n    const cabecalhos = Object.keys(contatos[0]);\n    \n    // Criar o conte√∫do CSV\n    const csvContent = [\n      cabecalhos.join(','),\n      ...contatos.map(contato => \n        cabecalhos.map(cabecalho => \n          `\"${String(contato[cabecalho] || '').replace(/\"/g, '\"\"')}\"`\n        ).join(',')\n      )\n    ].join('\\n');\n    \n    // Salvar o arquivo atualizado\n    fs.writeFileSync(caminhoArquivo, csvContent, 'utf8');\n    \n    logger.info(`Novo contato ${telefoneFormatado} (${nomeContato}) adicionado ao CSV com sucesso.`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao adicionar contato no CSV: ${erro.message}`);\n    return false;\n  }\n}\n\n// Criar novo arquivo de contatos se n√£o existir nenhum\nfunction criarNovoArquivoContatos(telefone, nomeContato) {\n  try {\n    logger.info('Criando novo arquivo de contatos...');\n    \n    // Garantir que o diret√≥rio existe\n    if (!fs.existsSync(CONTATOS_DIR)) {\n      fs.mkdirSync(CONTATOS_DIR, { recursive: true });\n    }\n    \n    // Formatar o telefone conforme o padr√£o\n    const telefoneFormatado = formatarTelefone(telefone);\n    \n    // Criar dados iniciais\n    const contatos = [\n      {\n        Nome: nomeContato,\n        Telefone: telefoneFormatado,\n        Ativo: 'Sim',\n        Observacoes: `Adicionado automaticamente em ${new Date().toLocaleDateString()}`\n      }\n    ];\n    \n    // Criar arquivo Excel\n    const caminhoArquivo = path.join(CONTATOS_DIR, 'contatos.xlsx');\n    const workbook = xlsx.utils.book_new();\n    const worksheet = xlsx.utils.json_to_sheet(contatos);\n    \n    xlsx.utils.book_append_sheet(workbook, worksheet, 'Contatos');\n    xlsx.writeFile(workbook, caminhoArquivo);\n    \n    logger.info(`Novo arquivo de contatos criado com o contato ${telefoneFormatado}`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao criar novo arquivo de contatos: ${erro.message}`);\n    return false;\n  }\n}\n\n// Fun√ß√£o auxiliar para formatar n√∫mero de telefone\nfunction formatarTelefone(telefone) {\n  // Remover caracteres n√£o num√©ricos\n  let telefoneFormatado = String(telefone).replace(/\\D/g, '');\n  \n  // Adicionar c√≥digo do pa√≠s (55) se n√£o estiver presente e for um n√∫mero brasileiro\n  if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\n    telefoneFormatado = `55${telefoneFormatado}`;\n  }\n  \n  return telefoneFormatado;\n}\n\nmodule.exports = {\n  adicionarNovoContatoNaPlanilha\n};"
    },
    {
      "path": "src\\conversasHandler.js",
      "name": "conversasHandler.js",
      "extension": ".js",
      "size": 11390,
      "last_modified": "2025-04-03T13:54:43.506143",
      "content": "// M√≥dulo para gerenciar conversas individuais com os usu√°rios\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\nconst leitorDocumentos = require('./leitorDocumentos');\nconst historicoMensagens = require('./historicoMensagens');\nconst { logger, removerAcentos, limparString } = require('./utils');\n\n// Configura√ß√µes\nconst CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\nconst MAX_HISTORICO_CONVERSAS = parseInt(process.env.MAX_HISTORICO_CONVERSAS || '10', 10);\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\n\n// Inicializar cliente Gemini\nlet genAI;\nlet geminiModel;\n\n// Fun√ß√£o para inicializar a API do Gemini\nfunction inicializarGeminiAPI() {\n  try {\n    if (!GEMINI_API_KEY) {\n      logger.error('Chave da API do Gemini n√£o configurada no arquivo .env');\n      return false;\n    }\n    \n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\n    \n    // Tentar usar o modelo mais avan√ßado primeiro\n    try {\n      geminiModel = genAI.getGenerativeModel({ model: \"gemini-1.5-pro\" });\n      logger.info('API do Google Gemini (gemini-1.5-pro) inicializada com sucesso');\n    } catch (erro) {\n      logger.warn(`Erro ao inicializar modelo gemini-1.5-pro: ${erro.message}`);\n      // Fallback para outro modelo\n      geminiModel = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n      logger.info('API do Google Gemini (gemini-pro) inicializada com sucesso');\n    }\n    \n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\n    return false;\n  }\n}\n\n// Inicializar a API\ninicializarGeminiAPI();\n\n// Garantir que o diret√≥rio de conversas exista\nfunction garantirDiretorioConversas() {\n  if (!fs.existsSync(CONVERSAS_DIR)) {\n    fs.mkdirSync(CONVERSAS_DIR, { recursive: true });\n    logger.info(`Diret√≥rio de conversas criado: ${CONVERSAS_DIR}`);\n  }\n}\n\n// Obter o caminho do arquivo de hist√≥rico para um telefone espec√≠fico\nfunction obterCaminhoHistoricoConversa(telefone) {\n  garantirDiretorioConversas();\n  const nomeArquivo = `${telefone}.json`;\n  return path.join(CONVERSAS_DIR, nomeArquivo);\n}\n\n// Carregar hist√≥rico de conversa de um usu√°rio\nfunction carregarHistoricoConversa(telefone) {\n  try {\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\n    \n    if (fs.existsSync(caminhoArquivo)) {\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n      return JSON.parse(conteudo);\n    }\n    \n    // Retornar hist√≥rico vazio se n√£o existir\n    return {\n      telefone: telefone,\n      ultimaAtualizacao: new Date().toISOString(),\n      ultimoDevocional: null,\n      conversas: []\n    };\n  } catch (erro) {\n    logger.error(`Erro ao carregar hist√≥rico de conversa para ${telefone}: ${erro.message}`);\n    return {\n      telefone: telefone,\n      ultimaAtualizacao: new Date().toISOString(),\n      ultimoDevocional: null,\n      conversas: []\n    };\n  }\n}\n\n// Salvar hist√≥rico de conversa de um usu√°rio\nfunction salvarHistoricoConversa(historico) {\n  try {\n    garantirDiretorioConversas();\n    \n    // Atualizar a data da √∫ltima atualiza√ß√£o\n    historico.ultimaAtualizacao = new Date().toISOString();\n    \n    // Limitar o n√∫mero de mensagens no hist√≥rico\n    if (historico.conversas.length > MAX_HISTORICO_CONVERSAS) {\n      historico.conversas = historico.conversas.slice(-MAX_HISTORICO_CONVERSAS);\n    }\n    \n    const caminhoArquivo = obterCaminhoHistoricoConversa(historico.telefone);\n    fs.writeFileSync(caminhoArquivo, JSON.stringify(historico, null, 2));\n    \n    logger.info(`Hist√≥rico de conversa salvo para ${historico.telefone}`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao salvar hist√≥rico de conversa para ${historico.telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Registrar um devocional enviado para um usu√°rio\nfunction registrarDevocionalEnviado(telefone, devocional) {\n  try {\n    const historico = carregarHistoricoConversa(telefone);\n    \n    // Registrar o devocional atual\n    historico.ultimoDevocional = {\n      data: new Date().toISOString(),\n      conteudo: devocional\n    };\n    \n    return salvarHistoricoConversa(historico);\n  } catch (erro) {\n    logger.error(`Erro ao registrar devocional para ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Registrar uma mensagem na conversa\nfunction registrarMensagem(telefone, remetente, mensagem) {\n  try {\n    const historico = carregarHistoricoConversa(telefone);\n    \n    // Adicionar a mensagem ao hist√≥rico\n    historico.conversas.push({\n      timestamp: new Date().toISOString(),\n      remetente: remetente, // 'usuario' ou 'bot'\n      mensagem: mensagem\n    });\n    \n    return salvarHistoricoConversa(historico);\n  } catch (erro) {\n    logger.error(`Erro ao registrar mensagem para ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Verificar se uma mensagem parece ser uma pergunta\nfunction ePergunta(mensagem) {\n  // Remover acentos e converter para min√∫sculas\n  const textoNormalizado = removerAcentos(mensagem.toLowerCase());\n  \n  // Verificar se termina com ponto de interroga√ß√£o\n  if (textoNormalizado.includes('?')) {\n    return true;\n  }\n  \n  // Verificar palavras-chave de perguntas\n  const palavrasChavePergunta = [\n    'quem', 'como', 'por que', 'porque', 'quando', 'onde', 'qual', 'quais',\n    'o que', 'oq', 'pq', 'me explica', 'pode explicar', 'explique', 'significa',\n    'entendi', 'n√£o entendi', 'nao entendi', 'duvida', 'd√∫vida'\n  ];\n  \n  return palavrasChavePergunta.some(palavra => textoNormalizado.includes(palavra));\n}\n\n// Verificar se √© a primeira intera√ß√£o de um usu√°rio\nasync function isPrimeiraInteracao(telefone) {\n  try {\n    const caminhoArquivo = obterCaminhoHistoricoConversa(telefone);\n    \n    // Verificar se o arquivo de hist√≥rico existe\n    const existeHistorico = fs.existsSync(caminhoArquivo);\n    \n    // Se o arquivo n√£o existir, √© a primeira intera√ß√£o\n    if (!existeHistorico) {\n      logger.info(`Arquivo de hist√≥rico n√£o encontrado para ${telefone}, √© a primeira intera√ß√£o`);\n      return true;\n    }\n    \n    // Se o arquivo existir, verificar se tem conte√∫do v√°lido\n    try {\n      const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n      const historico = JSON.parse(conteudo);\n      \n      // Verificar se o hist√≥rico tem conversas\n      if (!historico.conversas || historico.conversas.length === 0) {\n        logger.info(`Hist√≥rico vazio para ${telefone}, considerando como primeira intera√ß√£o`);\n        return true;\n      }\n      \n      // Se chegou aqui, n√£o √© a primeira intera√ß√£o\n      logger.info(`Usu√°rio ${telefone} j√° tem hist√≥rico com ${historico.conversas.length} mensagens`);\n      return false;\n    } catch (erroLeitura) {\n      logger.error(`Erro ao ler hist√≥rico para ${telefone}: ${erroLeitura.message}`);\n      // Em caso de erro de leitura, considerar como primeira intera√ß√£o para garantir\n      return true;\n    }\n  } catch (erro) {\n    logger.error(`Erro ao verificar primeira intera√ß√£o para ${telefone}: ${erro.message}`);\n    return false;\n  }\n}\n\n// Preparar o prompt para a resposta da IA\nasync function prepararPromptResposta(telefone, mensagemUsuario) {\n  const historico = carregarHistoricoConversa(telefone);\n  const ultimoDevocional = historico.ultimoDevocional ? historico.ultimoDevocional.conteudo : '';\n  \n  // Obter √∫ltimas conversas para contexto (limitado √†s 5 √∫ltimas)\n  const conversasRecentes = historico.conversas.slice(-5);\n  const conversasFormatadas = conversasRecentes.map(c => \n    `${c.remetente === 'usuario' ? 'Pessoa' : 'Bot'}: ${c.mensagem}`\n  ).join('\\n');\n  \n  // Obter conte√∫do da base de conhecimento\n  const baseConhecimento = await leitorDocumentos.obterConteudoBase();\n  \n  const prompt = `\n  Voc√™ √© um assistente espiritual que est√° respondendo perguntas sobre um devocional di√°rio que voc√™ enviou para uma pessoa via WhatsApp.\n  \n  Seu √∫ltimo devocional enviado foi:\n  ${ultimoDevocional}\n  \n  O contexto da conversa recente √©:\n  ${conversasFormatadas}\n  \n  A pessoa acabou de enviar esta mensagem para voc√™:\n  \"${mensagemUsuario}\"\n  \n  Baseie-se no devocional enviado e na seguinte base de conhecimento religiosa para responder:\n  ${baseConhecimento.substring(0, 10000)}\n  \n  Responda √† pergunta ou coment√°rio da pessoa de forma amig√°vel, acolhedora e espiritual. \n  Mantenha a resposta concisa (at√© 5 frases), mas esclarecedora e relevante para a mensagem da pessoa.\n  Se for uma pergunta sobre o devocional, d√™ uma resposta espec√≠fica baseada no vers√≠culo e na reflex√£o.\n  Se n√£o for uma pergunta relacionada ao devocional, responda de forma generalista e gentil, evitando debates teol√≥gicos complexos.\n  \n  N√£o mencione que voc√™ √© uma IA ou um bot. Responda como um aconselhador espiritual amig√°vel.\n  `;\n  \n  return prompt.trim();\n}\n\n// Gerar resposta para uma mensagem do usu√°rio\nasync function gerarRespostaParaMensagem(telefone, mensagemUsuario) {\n  try {\n    // Verificar se a API Gemini est√° inicializada\n    if (!geminiModel) {\n      const inicializou = inicializarGeminiAPI();\n      if (!inicializou) {\n        return \"N√£o foi poss√≠vel responder no momento. Por favor, tente novamente mais tarde.\";\n      }\n    }\n    \n    // Registrar a mensagem do usu√°rio\n    registrarMensagem(telefone, 'usuario', mensagemUsuario);\n    \n    // Verificar se a mensagem √© uma pergunta ou coment√°rio que precisa de resposta\n    if (!ePergunta(mensagemUsuario) && mensagemUsuario.length < 10) {\n      const respostasSimples = [\n        \"Am√©m! Tenha um dia aben√ßoado.\",\n        \"Que Deus te aben√ßoe hoje e sempre.\",\n        \"Obrigado por compartilhar. Fique na paz de Cristo.\",\n        \"Louvado seja Deus! Tenha um excelente dia.\",\n        \"Que a gra√ßa de Deus esteja com voc√™ hoje.\"\n      ];\n      \n      const resposta = respostasSimples[Math.floor(Math.random() * respostasSimples.length)];\n      registrarMensagem(telefone, 'bot', resposta);\n      return resposta;\n    }\n    \n    // Preparar o prompt\n    const prompt = await prepararPromptResposta(telefone, mensagemUsuario);\n    \n    // Gerar resposta com a IA\n    const result = await geminiModel.generateContent({\n      contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n      generationConfig: {\n        temperature: 0.7,\n        topK: 40,\n        topP: 0.95,\n        maxOutputTokens: 1024,\n      },\n    });\n    \n    const resposta = result.response.text().trim();\n    \n    // Registrar a resposta do bot\n    registrarMensagem(telefone, 'bot', resposta);\n    \n    return resposta;\n  } catch (erro) {\n    logger.error(`Erro ao gerar resposta para ${telefone}: ${erro.message}`);\n    \n    // Resposta de fallback em caso de erro\n    const respostaFallback = \"Agrade√ßo sua mensagem. Estou refletindo sobre isso e logo poderei responder com mais clareza. Que Deus aben√ßoe seu dia.\";\n    registrarMensagem(telefone, 'bot', respostaFallback);\n    \n    return respostaFallback;\n  }\n}\n\nmodule.exports = {\n  registrarDevocionalEnviado,\n  gerarRespostaParaMensagem,\n  ePergunta,\n  isPrimeiraInteracao\n};"
    },
    {
      "path": "src\\geradorDevocional.js",
      "name": "geradorDevocional.js",
      "extension": ".js",
      "size": 10685,
      "last_modified": "2025-04-03T15:18:23.726040",
      "content": "// M√≥dulo gerador de devocionais com IA (Google Gemini)\n\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\nconst leitorDocumentos = require('./leitorDocumentos');\nconst historicoMensagens = require('./historicoMensagens');\nconst { logger } = require('./utils');\n\n// Configura√ß√£o da API do Gemini\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\n\n// Inicializar o cliente Gemini\nlet genAI;\nlet geminiModel;\n\n// Fun√ß√£o para inicializar a API do Gemini\nfunction inicializarGeminiAPI() {\n  try {\n    if (!GEMINI_API_KEY) {\n      logger.error('Chave da API do Gemini n√£o configurada no arquivo .env');\n      return false;\n    }\n    \n    genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\n    \n    // Corrigindo para usar o nome do modelo correto\n    // Verificar qual modelo est√° dispon√≠vel (gemini-pro ou gemini-1.5-pro)\n    geminiModel = genAI.getGenerativeModel({ model: \"gemini-2.0-flash\" });\n    \n    logger.info('API do Google Gemini inicializada com sucesso');\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao inicializar API do Gemini: ${erro.message}`);\n    return false;\n  }\n}\n\n// Tentar inicializar a API\ninicializarGeminiAPI();\n\n// Gerar um prompt para o Gemini\nasync function gerarPrompt(dataAtual) {\n  try {\n    // Obter conte√∫do da base de conhecimento\n    const baseConhecimento = await leitorDocumentos.obterConteudoBase();\n    \n    // Obter vers√≠culos recentes (para evitar repeti√ß√µes)\n    const versiculosRecentes = historicoMensagens.obterVersiculosRecentes(10); // Aumentei para 10 dias\n    const versiculosRecentesTexto = versiculosRecentes\n      .map(v => {\n        if (!v || !v.referencia || !v.texto) return '';\n        return `${v.referencia}: \"${v.texto}\"`;\n      })\n      .filter(v => v) // Remove entradas vazias\n      .join('\\n');\n    \n    // Adicionar log para debug\n    logger.info(`Vers√≠culos a serem evitados: ${versiculosRecentesTexto || \"Nenhum\"}`);\n    \n    // Construir o prompt\n    const prompt = `\n      Voc√™ √© um bot de WhatsApp com intelig√™ncia artificial projetado para enviar um devocional di√°rio todas as manh√£s.\n      \n      Seu objetivo √© criar uma mensagem devocional que contenha:\n      1. A data atual (${dataAtual})\n      2. Um vers√≠culo b√≠blico relevante\n      3. Um texto explicativo sobre o vers√≠culo (3-5 frases)\n      4. Uma sugest√£o pr√°tica para o dia (1-2 frases)\n      \n      MUITO IMPORTANTE: Voc√™ deve gerar um devocional com um vers√≠culo diferente a cada dia. Nunca repita vers√≠culos que j√° foram usados recentemente.\n      \n      Baseie-se no seguinte conte√∫do para selecionar o vers√≠culo e elaborar a reflex√£o:\n      \n      ${baseConhecimento.substring(0, 15000)} \n      \n      Evite usar ABSOLUTAMENTE os seguintes vers√≠culos que foram utilizados recentemente:\n      ${versiculosRecentesTexto || \"Nenhum vers√≠culo recente a evitar.\"}\n      \n      O tom deve ser amig√°vel, acolhedor e espiritual.\n      \n      Exemplo do formato esperado:\n      \n      \"üìÖ ${dataAtual}\n      \n      üìñ *Vers√≠culo:* \\\"Tudo o que fizerem, fa√ßam de todo o cora√ß√£o, como para o Senhor.\\\" (Colossenses 3:23)\n      \n      üí≠ *Reflex√£o:* Este vers√≠culo nos lembra que nossas a√ß√µes di√°rias, por menores que sejam, ganham significado quando as dedicamos a Deus. Trabalhar, ajudar algu√©m ou at√© descansar pode ser uma forma de honr√°-Lo se fizermos com amor e prop√≥sito. Que tal come√ßar o dia com essa inten√ß√£o no cora√ß√£o?\n      \n      üßóüèº *Pr√°tica:* Hoje, escolha uma tarefa simples e a realize com dedica√ß√£o, pensando em como ela pode refletir seu cuidado com os outros e com Deus.\\\"\n      \n      Gere o devocional seguindo exatamente esse formato. induza o usu√°rio a continuar a conversa.\n    `;\n    \n    return prompt.trim();\n  } catch (erro) {\n    logger.error(`Erro ao gerar prompt: ${erro.message}`);\n    throw erro;\n  }\n}\n\n// Modifique a fun√ß√£o gerarDevocional para incluir a valida√ß√£o\nasync function gerarDevocional(dataAtual) {\n  try {\n    // Verificar se a API foi inicializada corretamente\n    if (!geminiModel) {\n      logger.warn('API do Gemini n√£o inicializada. Tentando inicializar novamente...');\n      \n      // Tentar inicializar novamente\n      const inicializou = inicializarGeminiAPI();\n      \n      if (!inicializou || !geminiModel) {\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\n      }\n    }\n    \n    // Contador de tentativas para evitar loop infinito\n    let tentativas = 0;\n    const maxTentativas = 3;\n    let devocionalValido = false;\n    let devocional = '';\n    \n    while (!devocionalValido && tentativas < maxTentativas) {\n      tentativas++;\n      logger.info(`Gerando devocional - tentativa ${tentativas}/${maxTentativas}`);\n      \n      // Gerar o prompt com os vers√≠culos a serem evitados\n      const prompt = await gerarPrompt(dataAtual);\n      \n      try {\n        const result = await geminiModel.generateContent({\n          contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n          generationConfig: {\n            temperature: 0.7 + (tentativas * 0.1), // Aumentar a temperatura a cada tentativa\n            topK: 40,\n            topP: 0.95,\n            maxOutputTokens: 1024,\n          },\n        });\n        \n        const response = result.response;\n        devocional = response.text().trim();\n        \n        // Verificar se o devocional foi gerado corretamente\n        if (!devocional || devocional.length < 50) {\n          logger.warn('Devocional gerado muito curto ou vazio. Tentando novamente.');\n          continue;\n        }\n        \n        // Validar se o vers√≠culo n√£o foi usado recentemente\n        devocionalValido = await validarDevocionalGerado(devocional);\n        \n        if (devocionalValido) {\n          logger.info('Devocional v√°lido gerado com sucesso');\n          return devocional;\n        } else {\n          logger.warn('Devocional gerado usa vers√≠culo repetido. Tentando novamente.');\n        }\n      } catch (erroGemini) {\n        logger.warn(`Erro com o modelo na tentativa ${tentativas}: ${erroGemini.message}`);\n        \n        if (tentativas >= maxTentativas) {\n          logger.error('N√∫mero m√°ximo de tentativas atingido. Usando fallback.');\n          return gerarDevocionalFallback(dataAtual);\n        }\n      }\n    }\n    \n    // Se chegou aqui sem um devocional v√°lido, usar fallback\n    if (!devocionalValido) {\n      logger.warn('N√£o foi poss√≠vel gerar um devocional com vers√≠culo √∫nico. Usando fallback.');\n      return gerarDevocionalFallback(dataAtual);\n    }\n    \n    return devocional;\n  } catch (erro) {\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\n    return gerarDevocionalFallback(dataAtual);\n  }\n}\n\n// Gerar o devocional utilizando o Gemini\nasync function gerarDevocional(dataAtual) {\n  try {\n    // Verificar se a API foi inicializada corretamente\n    if (!geminiModel) {\n      logger.warn('API do Gemini n√£o inicializada. Tentando inicializar novamente...');\n      \n      // Tentar inicializar novamente\n      const inicializou = inicializarGeminiAPI();\n      \n      if (!inicializou || !geminiModel) {\n        throw new Error('Falha ao inicializar API do Gemini. Verifique a chave de API.');\n      }\n    }\n    \n    logger.info('Gerando prompt para o Gemini...');\n    const prompt = await gerarPrompt(dataAtual);\n    \n    logger.info('Solicitando gera√ß√£o de devocional ao Gemini...');\n    \n    try {\n      const result = await geminiModel.generateContent({\n        contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 1024,\n        },\n      });\n      \n      const response = result.response;\n      const devocional = response.text().trim();\n      \n      // Verificar se o devocional foi gerado corretamente\n      if (!devocional || devocional.length < 50) {\n        logger.warn('Devocional gerado muito curto ou vazio. Usando fallback.');\n        return gerarDevocionalFallback(dataAtual);\n      }\n      \n      logger.info('Devocional gerado com sucesso');\n      return devocional;\n    } catch (erroGemini) {\n      // Tentar usar outro modelo se o modelo atual falhar\n      logger.warn(`Erro com o modelo atual. Detalhe: ${erroGemini.message}`);\n      \n      try {\n        // Tentar com modelo alternativo\n        logger.info('Tentando modelo alternativo gemini-pro...');\n        const modeloAlternativo = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n        \n        const resultadoAlternativo = await modeloAlternativo.generateContent({\n          contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n          generationConfig: {\n            temperature: 0.7,\n            topK: 40,\n            topP: 0.95,\n            maxOutputTokens: 1024,\n          },\n        });\n        \n        const respostaAlternativa = resultadoAlternativo.response;\n        const devocionalAlternativo = respostaAlternativa.text().trim();\n        \n        logger.info('Devocional gerado com sucesso usando modelo alternativo');\n        return devocionalAlternativo;\n      } catch (erroModeloAlternativo) {\n        logger.error(`Erro tamb√©m no modelo alternativo: ${erroModeloAlternativo.message}`);\n        throw new Error(`Falha em todos os modelos Gemini dispon√≠veis`);\n      }\n    }\n  } catch (erro) {\n    logger.error(`Erro ao gerar devocional: ${erro.message}`);\n    \n    // Retornar um devocional de fallback em caso de erro\n    return gerarDevocionalFallback(dataAtual);\n  }\n}\n\n// Gerar um devocional de fallback em caso de erro na API\nfunction gerarDevocionalFallback(dataAtual) {\n  logger.info('Gerando devocional de fallback...');\n  \n  return `${dataAtual}\n\n*‚úùÔ∏è Vers√≠culo:* \"N√£o temas, porque eu sou contigo; n√£o te assombres, porque eu sou teu Deus; eu te fortale√ßo, e te ajudo, e te sustento com a destra da minha justi√ßa.\" (Isa√≠as 41:10)\n\n*üí≠ Reflex√£o:* Mesmo quando enfrentamos dificuldades ou desafios inesperados, Deus est√° ao nosso lado, pronto para nos dar for√ßa e sustento. Este vers√≠culo nos lembra que n√£o precisamos temer, pois temos a presen√ßa constante do Senhor em nossas vidas, guiando nossos passos e iluminando nosso caminho.\n\n*üßóüèª Pr√°tica:* Hoje, ao enfrentar qualquer situa√ß√£o desafiadora, fa√ßa uma pausa, respire e relembre esta promessa de sustento divino antes de prosseguir.`;\n}\n\nmodule.exports = {\n  gerarDevocional\n};"
    },
    {
      "path": "src\\historicoMensagens.js",
      "name": "historicoMensagens.js",
      "extension": ".js",
      "size": 11682,
      "last_modified": "2025-04-03T14:06:05.760106",
      "content": "// M√≥dulo para gerenciamento do hist√≥rico de mensagens enviadas\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst { logger } = require('./utils');\n\n// Configura√ß√µes do hist√≥rico\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Hist√≥rico';\nconst HISTORICO_FILE = process.env.HISTORICO_FILE || './Hist√≥rico/historico.json';\nconst MAX_HISTORICO_DIAS = parseInt(process.env.MAX_HISTORICO_DIAS || '90', 10);\n\n// Garantir que o diret√≥rio do hist√≥rico exista\nfunction garantirDiretorioHistorico() {\n  if (!fs.existsSync(HISTORICO_DIR)) {\n    fs.mkdirSync(HISTORICO_DIR, { recursive: true });\n    logger.info(`Diret√≥rio de hist√≥rico criado: ${HISTORICO_DIR}`);\n  }\n  \n  if (!fs.existsSync(HISTORICO_FILE)) {\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify({\n      ultimaAtualizacao: new Date().toISOString(),\n      mensagens: []\n    }, null, 2));\n    logger.info(`Arquivo de hist√≥rico criado: ${HISTORICO_FILE}`);\n  }\n}\n\n// Carregar o hist√≥rico de mensagens\nfunction carregarHistorico() {\n  try {\n    garantirDiretorioHistorico();\n    \n    // Verificar se o arquivo existe e tem conte√∫do v√°lido\n    if (fs.existsSync(HISTORICO_FILE)) {\n      const conteudo = fs.readFileSync(HISTORICO_FILE, 'utf8');\n      if (conteudo && conteudo.trim()) {\n        const historico = JSON.parse(conteudo);\n        // Garantir que o objeto tem a estrutura esperada\n        if (!historico.mensagens) {\n          historico.mensagens = [];\n        }\n        return historico;\n      }\n    }\n    \n    // Se o arquivo n√£o existir, estiver vazio ou n√£o tiver a estrutura esperada\n    const historicoVazio = {\n      ultimaAtualizacao: new Date().toISOString(),\n      mensagens: []\n    };\n    \n    // Salvar o hist√≥rico vazio para garantir consist√™ncia\n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\n    \n    return historicoVazio;\n  } catch (erro) {\n    logger.error(`Erro ao carregar hist√≥rico: ${erro.message}`);\n    // Retornar um hist√≥rico vazio em caso de erro\n    const historicoVazio = {\n      ultimaAtualizacao: new Date().toISOString(),\n      mensagens: []\n    };\n    \n    // Tentar salvar o hist√≥rico vazio\n    try {\n      fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historicoVazio, null, 2));\n    } catch (erroSalvar) {\n      logger.error(`Erro ao salvar hist√≥rico vazio: ${erroSalvar.message}`);\n    }\n    \n    return historicoVazio;\n  }\n}\n\n// Salvar o hist√≥rico de mensagens\nfunction salvarHistorico(historico) {\n  try {\n    garantirDiretorioHistorico();\n    \n    // Atualizar a data da √∫ltima atualiza√ß√£o\n    historico.ultimaAtualizacao = new Date().toISOString();\n    \n    fs.writeFileSync(HISTORICO_FILE, JSON.stringify(historico, null, 2));\n    logger.info('Hist√≥rico salvo com sucesso');\n  } catch (erro) {\n    logger.error(`Erro ao salvar hist√≥rico: ${erro.message}`);\n  }\n}\n\n// Limpar mensagens antigas do hist√≥rico\nfunction limparHistoricoAntigo(historico) {\n  try {\n    const dataLimite = new Date();\n    dataLimite.setDate(dataLimite.getDate() - MAX_HISTORICO_DIAS);\n    \n    const mensagensRecentes = historico.mensagens.filter(msg => {\n      const dataMensagem = new Date(msg.data);\n      return dataMensagem >= dataLimite;\n    });\n    \n    const mensagensRemovidas = historico.mensagens.length - mensagensRecentes.length;\n    \n    if (mensagensRemovidas > 0) {\n      logger.info(`Removidas ${mensagensRemovidas} mensagens antigas do hist√≥rico`);\n      historico.mensagens = mensagensRecentes;\n      salvarHistorico(historico);\n    }\n    \n    return historico;\n  } catch (erro) {\n    logger.error(`Erro ao limpar hist√≥rico antigo: ${erro.message}`);\n    return historico;\n  }\n}\n\n// Extrair vers√≠culos de uma mensagem devocional\nfunction extrairVersiculo(devocional) {\n  try {\n    // Procurar o padr√£o de vers√≠culo na mensagem\n    const regexVersiculo = /Vers√≠culo:\\s*[\"'](.+?)[\"']\\s*\\((.+?)\\)/i;\n    const match = devocional.match(regexVersiculo);\n    \n    if (match && match.length >= 3) {\n      return {\n        texto: match[1].trim(),\n        referencia: match[2].trim()\n      };\n    }\n    \n    return null;\n  } catch (erro) {\n    logger.error(`Erro ao extrair vers√≠culo: ${erro.message}`);\n    return null;\n  }\n}\n\n// Registrar um envio no hist√≥rico\nfunction registrarEnvio(dados) {\n  try {\n    const historico = carregarHistorico();\n    const versiculo = extrairVersiculo(dados.devocional);\n    \n    historico.mensagens.push({\n      data: dados.data,\n      devocional: dados.devocional,\n      versiculo: versiculo,\n      totalContatos: dados.totalContatos,\n      enviosComSucesso: dados.enviosComSucesso,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Limpar mensagens antigas antes de salvar\n    limparHistoricoAntigo(historico);\n    \n    logger.info('Envio registrado no hist√≥rico com sucesso');\n  } catch (erro) {\n    logger.error(`Erro ao registrar envio no hist√≥rico: ${erro.message}`);\n  }\n}\n\n// Obter vers√≠culos usados recentemente (para evitar repeti√ß√µes)\nfunction obterVersiculosRecentes(dias = 7) {\n  try {\n    const historico = carregarHistorico();\n    const dataLimite = new Date();\n    dataLimite.setDate(dataLimite.getDate() - dias);\n\n    // Adicionar log para debug\n    logger.info(`Verificando vers√≠culos usados nos √∫ltimos ${dias} dias`);\n    \n    const versiculosRecentes = historico.mensagens\n      .filter(msg => {\n        if (!msg.data || !msg.versiculo) return false;\n        const dataMensagem = new Date(msg.data);\n        return isRecente = dataMensagem >= dataLimite;\n\n        // Log para cada entrada\n        if (isRecente && msg.versiculo) {\n          logger.info(`Vers√≠culo recente encontrado: ${msg.versiculo.referencia} usado em ${dataMensagem.toISOString()}`);\n        }\n        return isRecente && msg.versiculo\n      })\n      .map(msg => msg.versiculo);\n    \n    logger.info(`Total de ${versiculosRecentes.length} vers√≠culos recentes encontrados`);\n    return versiculosRecentes;\n  } catch (erro) {\n    logger.error(`Erro ao obter vers√≠culos recentes: ${erro.message}`);\n    return [];\n  }\n}\n\n// Verificar se um vers√≠culo foi usado recentemente\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 7) { // Aumentei para 7 dias\n  try {\n    const versiculosRecentes = obterVersiculosRecentes(dias);\n    \n    // Normalizar a refer√™ncia para compara√ß√£o (remover espa√ßos e converter para min√∫sculas)\n    const referenciaFormatada = referencia.replace(/\\s+/g, '').toLowerCase();\n    \n    const encontrado = versiculosRecentes.some(versiculo => {\n      if (!versiculo || !versiculo.referencia) return false;\n      \n      const versiculoFormatado = versiculo.referencia.replace(/\\s+/g, '').toLowerCase();\n      const isMatch = versiculoFormatado === referenciaFormatada;\n      \n      if (isMatch) {\n        logger.info(`Vers√≠culo ${referencia} j√° foi usado recentemente`);\n      }\n      \n      return isMatch;\n    });\n    \n    return encontrado;\n  } catch (erro) {\n    logger.error(`Erro ao verificar vers√≠culo: ${erro.message}`);\n    return false;\n  }\n}\n\n// Obter o √∫ltimo devocional enviado\nasync function obterUltimoDevocionalEnviado() {\n  try {\n    // Tentar obter do hist√≥rico geral primeiro\n    const historico = carregarHistorico();\n    \n    if (historico && historico.mensagens && historico.mensagens.length > 0) {\n      // Ordenar mensagens por data (mais recente primeiro)\n      const mensagensOrdenadas = [...historico.mensagens].sort((a, b) => \n        new Date(b.data) - new Date(a.data)\n      );\n      \n      // Verificar se o √∫ltimo devocional foi enviado hoje\n      const hoje = new Date();\n      const dataHoje = `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, '0')}-${String(hoje.getDate()).padStart(2, '0')}`;\n      \n      // Encontrar o √∫ltimo devocional\n      for (const msg of mensagensOrdenadas) {\n        if (msg.devocional) {\n          // Extrair a data do timestamp\n          const dataMensagem = new Date(msg.timestamp || msg.data);\n          const dataMensagemStr = `${dataMensagem.getFullYear()}-${String(dataMensagem.getMonth() + 1).padStart(2, '0')}-${String(dataMensagem.getDate()).padStart(2, '0')}`;\n          \n          // Se o devocional for de hoje, retorn√°-lo\n          if (dataMensagemStr === dataHoje) {\n            logger.info(`Devocional de hoje encontrado no hist√≥rico geral (${dataMensagemStr})`);\n            return msg.devocional;\n          }\n        }\n      }\n      \n      // Se n√£o encontrar um devocional de hoje, retorna o mais recente\n      const ultimoDevocional = mensagensOrdenadas.find(msg => msg.devocional);\n      if (ultimoDevocional) {\n        logger.info('Retornando devocional mais recente dispon√≠vel do hist√≥rico geral');\n        return ultimoDevocional.devocional;\n      }\n    }\n    \n    // Se n√£o encontrou no hist√≥rico geral, buscar nas conversas individuais\n    logger.info('Buscando devocional nas conversas individuais...');\n    \n    const CONVERSAS_DIR = process.env.CONVERSAS_DIR || './Conversas';\n    if (!fs.existsSync(CONVERSAS_DIR)) {\n      logger.warn(`Diret√≥rio de conversas n√£o encontrado: ${CONVERSAS_DIR}`);\n      return null;\n    }\n    \n    // Ler arquivos de conversa\n    const arquivos = fs.readdirSync(CONVERSAS_DIR);\n    const arquivosJson = arquivos.filter(arquivo => arquivo.endsWith('.json'));\n    \n    let devocionalMaisRecente = null;\n    let dataMaisRecente = new Date(0); // Data antiga\n    \n    // Buscar em todas as conversas\n    for (const arquivo of arquivosJson) {\n      try {\n        const conteudo = fs.readFileSync(path.join(CONVERSAS_DIR, arquivo), 'utf8');\n        const conversa = JSON.parse(conteudo);\n        \n        if (conversa.ultimoDevocional) {\n          const dataDevocional = new Date(conversa.ultimoDevocional.data);\n          \n          // Verificar se √© mais recente que o √∫ltimo encontrado\n          if (dataDevocional > dataMaisRecente) {\n            devocionalMaisRecente = conversa.ultimoDevocional.conteudo;\n            dataMaisRecente = dataDevocional;\n          }\n        }\n      } catch (erroLeitura) {\n        logger.error(`Erro ao ler arquivo de conversa ${arquivo}: ${erroLeitura.message}`);\n      }\n    }\n    \n    if (devocionalMaisRecente) {\n      logger.info(`Devocional encontrado nas conversas individuais (data: ${dataMaisRecente.toISOString()})`);\n      return devocionalMaisRecente;\n    }\n    \n    logger.warn('Nenhum devocional encontrado no hist√≥rico ou nas conversas');\n    return null;\n  } catch (erro) {\n    logger.error(`Erro ao obter √∫ltimo devocional: ${erro.message}`);\n    return null;\n  }\n}\n\n// Verificar se um vers√≠culo foi usado recentemente\nfunction versiculoFoiUsadoRecentemente(referencia, dias = 30) {\n  try {\n    const versiculosRecentes = obterVersiculosRecentes(dias);\n    \n    // Normalizar a refer√™ncia para compara√ß√£o (remover espa√ßos e converter para min√∫sculas)\n    const referenciaFormatada = referencia.replace(/\\s+/g, '').toLowerCase();\n    \n    return versiculosRecentes.some(versiculo => {\n      const versiculoFormatado = versiculo.referencia.replace(/\\s+/g, '').toLowerCase();\n      return versiculoFormatado === referenciaFormatada;\n    });\n  } catch (erro) {\n    logger.error(`Erro ao verificar vers√≠culo: ${erro.message}`);\n    return false;\n  }\n}\n\nmodule.exports = {\n  registrarEnvio,\n  obterVersiculosRecentes,\n  versiculoFoiUsadoRecentemente,\n  obterUltimoDevocionalEnviado\n};"
    },
    {
      "path": "src\\index.js",
      "name": "index.js",
      "extension": ".js",
      "size": 5072,
      "last_modified": "2025-04-03T14:19:11.019018",
      "content": "// WhatsApp Devocional Di√°rio com IA\n// Ponto de entrada da aplica√ß√£o\n\nrequire('dotenv').config();\nconst fs = require('fs-extra');\nconst schedule = require('node-schedule');\nconst moment = require('moment');\nmoment.locale('pt-br');\n\n// Importa√ß√£o dos m√≥dulos\nconst whatsapp = require('./whatsapp');\nconst geradorDevocional = require('./geradorDevocional');\nconst leitorContatos = require('./leitorContatos');\nconst historicoMensagens = require('./historicoMensagens');\nconst conversasHandler = require('./conversasHandler');\nconst leitorDocumentos = require('./leitorDocumentos');\nconst { criarDiretorios, formatarData, logger } = require('./utils');\n\n// Garantir que os diret√≥rios necess√°rios existam\ncriarDiretorios();\n\n// Fun√ß√£o principal que executa o envio dos devocionais\nasync function enviarDevocionaisDiarios() {\n  try {\n    logger.info('Iniciando o processo de envio de devocionais di√°rios');\n    \n    // Obter a data atual formatada\n    const dataAtual = formatarData(new Date());\n    logger.info(`Data atual: ${dataAtual}`);\n    \n    // Gerar o devocional do dia\n    logger.info('Gerando devocional...');\n    const devocional = await geradorDevocional.gerarDevocional(dataAtual);\n    logger.info('Devocional gerado com sucesso');\n    \n    // Verificar se o cliente WhatsApp est√° pronto\n    if (!whatsapp.clientePronto()) {\n      logger.error('Cliente WhatsApp n√£o est√° pronto. Tentando novamente em 5 minutos.');\n      setTimeout(enviarDevocionaisDiarios, 5 * 60 * 1000);\n      return;\n    }\n    \n    // Obter a lista de contatos\n    logger.info('Obtendo lista de contatos...');\n    const contatos = await leitorContatos.obterContatos();\n    logger.info(`${contatos.length} contatos encontrados`);\n    \n    // Enviar o devocional para cada contato\n    let enviosComSucesso = 0;\n    \n    for (const contato of contatos) {\n      try {\n        logger.info(`Enviando devocional para ${contato.nome} (${contato.telefone})...`);\n        await whatsapp.enviarMensagem(contato.telefone, devocional);\n        \n        // Registrar o devocional enviado para refer√™ncia em conversas futuras\n        await conversasHandler.registrarDevocionalEnviado(contato.telefone, devocional);\n        \n        enviosComSucesso++;\n        logger.info(`Devocional enviado com sucesso para ${contato.nome}`);\n      } catch (erro) {\n        logger.error(`Erro ao enviar devocional para ${contato.nome}: ${erro.message}`);\n      }\n    }\n    \n    // Registrar no hist√≥rico\n    historicoMensagens.registrarEnvio({\n      data: dataAtual,\n      devocional: devocional,\n      totalContatos: contatos.length,\n      enviosComSucesso: enviosComSucesso\n    });\n    \n    logger.info(`Processo conclu√≠do. Enviado para ${enviosComSucesso}/${contatos.length} contatos.`);\n  } catch (erro) {\n    logger.error(`Erro ao executar o processo de envio: ${erro.message}`);\n    logger.error(erro.stack);\n  }\n}\n\n// Pr√©-processar a base de conhecimento\nasync function preprocessarBaseConhecimento() {\n  try {\n    logger.info('Iniciando pr√©-processamento da base de conhecimento...');\n    const conteudoBase = await leitorDocumentos.obterConteudoBase();\n    logger.info(`Base de conhecimento processada: ${conteudoBase.length} caracteres`);\n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao processar base de conhecimento: ${erro.message}`);\n    return false;\n  }\n}\n\n// Inicializa√ß√£o do sistema\nasync function iniciarSistema() {\n  try {\n    logger.info('Iniciando o sistema WhatsApp Devocional IA...');\n    \n    // Primeiro, processar a base de conhecimento\n    logger.info('Processando base de conhecimento...');\n    const baseProcessada = await preprocessarBaseConhecimento();\n    \n    if (!baseProcessada) {\n      logger.warn('Houve um problema no processamento da base de conhecimento, mas o sistema continuar√°.');\n    }\n    \n    // Depois, iniciar o cliente WhatsApp\n    logger.info('Inicializando conex√£o com WhatsApp...');\n    await whatsapp.iniciarCliente();\n    \n    // Agendar o envio di√°rio de devocionais no hor√°rio configurado\n    const horarioEnvio = process.env.SCHEDULE_TIME || '07:00';\n    const [hora, minuto] = horarioEnvio.split(':').map(Number);\n    \n    schedule.scheduleJob(`${minuto} ${hora} * * *`, async () => {\n      logger.info('Executando tarefa agendada de envio de devocionais');\n      await enviarDevocionaisDiarios();\n    });\n    \n    logger.info(`Sistema iniciado. Devocionais ser√£o enviados diariamente √†s ${horarioEnvio}`);\n    \n    // Para desenvolvimento/testes: Descomentar para enviar um devocional imediatamente\n     setTimeout(enviarDevocionaisDiarios, 10000);\n  } catch (erro) {\n    logger.error(`Erro ao iniciar o sistema: ${erro.message}`);\n    logger.error(erro.stack);\n  }\n}\n\n// Iniciar o sistema\niniciarSistema();\n\n// Tratamento de encerramento gracioso\nprocess.on('SIGINT', async () => {\n  logger.info('Encerrando o sistema...');\n  await whatsapp.encerrarCliente();\n  process.exit(0);\n});"
    },
    {
      "path": "src\\leitorContatos.js",
      "name": "leitorContatos.js",
      "extension": ".js",
      "size": 8837,
      "last_modified": "2025-04-03T13:54:43.522193",
      "content": "// M√≥dulo para leitura da lista de contatos de arquivos Excel ou CSV\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\nconst csvParser = require('csv-parser');\nconst { adicionarNovoContatoNaPlanilha } = require('./adicionarContato');\nconst { logger } = require('./utils');\n\n// Diret√≥rio de contatos\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\n\n// Obter a lista de arquivos de contatos dispon√≠veis\nfunction obterArquivosContatos() {\n  try {\n    const arquivos = fs.readdirSync(CONTATOS_DIR);\n    return arquivos.filter(arquivo => {\n      const extensao = path.extname(arquivo).toLowerCase();\n      return extensao === '.xlsx' || extensao === '.csv';\n    });\n  } catch (erro) {\n    logger.error(`Erro ao ler diret√≥rio de contatos: ${erro.message}`);\n    return [];\n  }\n}\n\n// Ler contatos de um arquivo Excel\nasync function lerContatosExcel(caminhoArquivo) {\n  try {\n    logger.info(`Lendo arquivo Excel: ${caminhoArquivo}`);\n    \n    // Op√ß√µes adicionais para melhorar a leitura\n    const workbook = xlsx.readFile(caminhoArquivo, {\n      cellDates: true,\n      cellNF: true,\n      cellText: true\n    });\n    \n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\n      logger.error('Arquivo Excel sem planilhas');\n      return [];\n    }\n    \n    // Verificar todas as planilhas para encontrar contatos\n    let todosContatos = [];\n    \n    for (const sheetName of workbook.SheetNames) {\n      logger.info(`Processando planilha: ${sheetName}`);\n      \n      const worksheet = workbook.Sheets[sheetName];\n      \n      // Verificar se a planilha tem dados\n      if (!worksheet['!ref']) {\n        logger.warn(`Planilha ${sheetName} vazia, pulando...`);\n        continue;\n      }\n      \n      // Tentar ler os dados da planilha\n      try {\n        const dados = xlsx.utils.sheet_to_json(worksheet, {\n          defval: '',  // Valor padr√£o para c√©lulas vazias\n          raw: false   // N√£o converter tipos automaticamente\n        });\n        \n        logger.info(`Encontrados ${dados.length} registros na planilha ${sheetName}`);\n        \n        if (dados.length > 0) {\n          const contatos = normalizarContatos(dados);\n          logger.info(`${contatos.length} contatos v√°lidos na planilha ${sheetName}`);\n          todosContatos = todosContatos.concat(contatos);\n        }\n      } catch (erroLeitura) {\n        logger.error(`Erro ao processar planilha ${sheetName}: ${erroLeitura.message}`);\n      }\n    }\n    \n    return todosContatos;\n  } catch (erro) {\n    logger.error(`Erro ao ler arquivo Excel: ${erro.message}`);\n    logger.error(erro.stack);\n    return [];\n  }\n}\n\n// Ler contatos de um arquivo CSV\nasync function lerContatosCsv(caminhoArquivo) {\n  return new Promise((resolve, reject) => {\n    const contatos = [];\n    \n    fs.createReadStream(caminhoArquivo)\n      .pipe(csvParser())\n      .on('data', (row) => {\n        contatos.push(row);\n      })\n      .on('end', () => {\n        resolve(normalizarContatos(contatos));\n      })\n      .on('error', (erro) => {\n        logger.error(`Erro ao ler arquivo CSV: ${erro.message}`);\n        reject(erro);\n      });\n  });\n}\n\n// Normalizar os dados dos contatos para um formato padr√£o\nfunction normalizarContatos(dados) {\n  if (!dados || !Array.isArray(dados) || dados.length === 0) {\n    logger.warn('Nenhum dado de contato v√°lido encontrado para normalizar');\n    return [];\n  }\n  \n  // Registrar os campos encontrados no primeiro registro para debug\n  if (dados.length > 0) {\n    logger.info(`Campos encontrados na planilha: ${Object.keys(dados[0]).join(', ')}`);\n  }\n  \n  return dados.map(contato => {\n    // Tentar encontrar os campos de nome e telefone, independente da capitaliza√ß√£o\n    const entradas = Object.entries(contato);\n    let nome = '';\n    let telefone = '';\n    let ativo = true;\n    \n    // Debug para cada contato\n    logger.info(`Processando contato: ${JSON.stringify(contato)}`);\n    \n    for (const [chave, valor] of entradas) {\n      if (!chave) continue;\n      \n      const chaveLower = String(chave).toLowerCase();\n      \n      if (chaveLower.includes('nome')) {\n        nome = valor;\n        logger.info(`Nome encontrado: ${nome}`);\n      } else if (\n        chaveLower.includes('telefone') || \n        chaveLower.includes('celular') || \n        chaveLower.includes('whatsapp') || \n        chaveLower.includes('fone') ||\n        chaveLower.includes('phone') ||\n        chaveLower.includes('numero')\n      ) {\n        telefone = valor;\n        logger.info(`Telefone encontrado (original): ${telefone}`);\n      } else if (\n        chaveLower.includes('ativo') || \n        chaveLower.includes('status') || \n        chaveLower.includes('habilitado')\n      ) {\n        // Considerar o contato ativo se o campo for 'sim', 'true', 1, etc.\n        if (typeof valor === 'string') {\n          const valorLower = String(valor).toLowerCase();\n          ativo = valorLower === 'sim' || valorLower === 'true' || valorLower === 's' || valorLower === 'y' || valorLower === 'yes';\n        } else {\n          ativo = Boolean(valor);\n        }\n      }\n    }\n    \n    // Se n√£o encontrar telefone, tentar encontrar algum campo que pare√ßa ser um n√∫mero de telefone\n    if (!telefone) {\n      for (const [chave, valor] of entradas) {\n        // Verificar se o valor se parece com um n√∫mero de telefone (apenas d√≠gitos e com pelo menos 8 caracteres)\n        if (valor && typeof valor === 'string' && valor.replace(/\\D/g, '').length >= 8) {\n          telefone = valor;\n          logger.info(`Poss√≠vel telefone encontrado no campo ${chave}: ${telefone}`);\n          break;\n        }\n      }\n    }\n    \n    // Garantir que telefone seja uma string antes de aplicar replace\n    let telefoneFormatado = '';\n    if (telefone !== undefined && telefone !== null) {\n      // Normalizar o telefone (remover caracteres n√£o num√©ricos)\n      telefoneFormatado = String(telefone).replace(/\\D/g, '');\n      \n      // Adicionar c√≥digo do pa√≠s (55) se n√£o estiver presente e for um n√∫mero brasileiro\n      if (telefoneFormatado.length >= 10 && telefoneFormatado.length <= 11 && !telefoneFormatado.startsWith('55')) {\n        telefoneFormatado = `55${telefoneFormatado}`;\n        logger.info(`Adicionado c√≥digo do pa√≠s: ${telefoneFormatado}`);\n      }\n    }\n    \n    logger.info(`Telefone formatado: ${telefoneFormatado}`);\n    \n    return {\n      nome: nome || 'Sem nome',\n      telefone: telefoneFormatado,\n      ativo: ativo\n    };\n  })\n  // Filtrar contatos sem telefone ou inativos\n  .filter(contato => {\n    // Verificar se o telefone √© v√°lido (pelo menos 10 d√≠gitos)\n    const telefoneValido = contato.telefone && contato.telefone.length >= 10;\n    \n    if (!telefoneValido) {\n      logger.warn(`Contato \"${contato.nome}\" ignorado: n√∫mero de telefone inv√°lido (${contato.telefone})`);\n    } else if (!contato.ativo) {\n      logger.info(`Contato \"${contato.nome}\" ignorado: est√° marcado como inativo`);\n    } else {\n      logger.info(`Contato v√°lido: ${contato.nome} (${contato.telefone})`);\n    }\n    \n    return telefoneValido && contato.ativo;\n  });\n}\n\n// Fun√ß√£o principal para obter todos os contatos de todos os arquivos\nasync function obterContatos() {\n  try {\n    const arquivos = obterArquivosContatos();\n    \n    if (arquivos.length === 0) {\n      logger.warn('Nenhum arquivo de contatos encontrado no diret√≥rio');\n      return [];\n    }\n    \n    let todosContatos = [];\n    \n    for (const arquivo of arquivos) {\n      const caminhoArquivo = path.join(CONTATOS_DIR, arquivo);\n      const extensao = path.extname(arquivo).toLowerCase();\n      \n      logger.info(`Lendo contatos do arquivo: ${arquivo}`);\n      \n      let contatos = [];\n      if (extensao === '.xlsx') {\n        contatos = await lerContatosExcel(caminhoArquivo);\n      } else if (extensao === '.csv') {\n        contatos = await lerContatosCsv(caminhoArquivo);\n      }\n      \n      logger.info(`${contatos.length} contatos v√°lidos encontrados em ${arquivo}`);\n      todosContatos = todosContatos.concat(contatos);\n    }\n    \n    // Remover duplicatas baseadas no n√∫mero de telefone\n    const contatosUnicos = {};\n    todosContatos.forEach(contato => {\n      contatosUnicos[contato.telefone] = contato;\n    });\n    \n    const resultado = Object.values(contatosUnicos);\n    logger.info(`Total de ${resultado.length} contatos √∫nicos encontrados`);\n    \n    return resultado;\n  } catch (erro) {\n    logger.error(`Erro ao obter contatos: ${erro.message}`);\n    return [];\n  }\n}\n\nmodule.exports = {\n  obterContatos,\n  adicionarNovoContatoNaPlanilha\n};"
    },
    {
      "path": "src\\leitorDocumentos.js",
      "name": "leitorDocumentos.js",
      "extension": ".js",
      "size": 6949,
      "last_modified": "2025-04-03T13:54:43.522193",
      "content": "// M√≥dulo para processamento dos documentos base\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst xlsx = require('xlsx');\nconst csvParser = require('csv-parser');\nconst pdfParse = require('pdf-parse');\nconst cheerio = require('cheerio');\nconst { logger } = require('./utils');\n\n// Diret√≥rio de documentos base\nconst BASE_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\n\n// Cache de documentos processados para evitar reprocessamento\nlet documentosCache = null;\nlet dataUltimaAtualizacao = null;\n\n// Verificar a necessidade de atualiza√ß√£o do cache\nfunction verificarCacheAtualizado() {\n  if (!documentosCache || !dataUltimaAtualizacao) {\n    return false;\n  }\n  \n  // Verificar se algum arquivo foi modificado desde a √∫ltima atualiza√ß√£o\n  try {\n    const arquivos = obterArquivosBase();\n    \n    for (const arquivo of arquivos) {\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\n      const stats = fs.statSync(caminhoArquivo);\n      \n      if (stats.mtime > dataUltimaAtualizacao) {\n        return false;\n      }\n    }\n    \n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao verificar cache: ${erro.message}`);\n    return false;\n  }\n}\n\n// Obter a lista de arquivos da base de conhecimento\nfunction obterArquivosBase() {\n  try {\n    const arquivos = fs.readdirSync(BASE_DIR);\n    return arquivos.filter(arquivo => {\n      const extensao = path.extname(arquivo).toLowerCase();\n      return ['.pdf', '.json', '.txt', '.csv', '.xlsx'].includes(extensao);\n    });\n  } catch (erro) {\n    logger.error(`Erro ao ler diret√≥rio da base de conhecimento: ${erro.message}`);\n    return [];\n  }\n}\n\n// Processar um arquivo PDF\nasync function processarPdf(caminhoArquivo) {\n  try {\n    const dataBuffer = fs.readFileSync(caminhoArquivo);\n    const data = await pdfParse(dataBuffer);\n    return data.text;\n  } catch (erro) {\n    logger.error(`Erro ao processar PDF ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Processar um arquivo JSON\nfunction processarJson(caminhoArquivo) {\n  try {\n    const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n    const data = JSON.parse(conteudo);\n    \n    // Extrair textos do JSON (considerando diferentes estruturas poss√≠veis)\n    return extrairTextosJson(data);\n  } catch (erro) {\n    logger.error(`Erro ao processar JSON ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Extrair textos recursivamente de um objeto JSON\nfunction extrairTextosJson(obj, textos = []) {\n  if (!obj) return textos;\n  \n  if (typeof obj === 'string') {\n    textos.push(obj);\n  } else if (Array.isArray(obj)) {\n    obj.forEach(item => extrairTextosJson(item, textos));\n  } else if (typeof obj === 'object') {\n    Object.values(obj).forEach(valor => extrairTextosJson(valor, textos));\n  }\n  \n  return textos.join('\\n');\n}\n\n// Processar um arquivo TXT\nfunction processarTxt(caminhoArquivo) {\n  try {\n    return fs.readFileSync(caminhoArquivo, 'utf8');\n  } catch (erro) {\n    logger.error(`Erro ao processar TXT ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Processar um arquivo CSV\nasync function processarCsv(caminhoArquivo) {\n  return new Promise((resolve, reject) => {\n    const linhas = [];\n    \n    fs.createReadStream(caminhoArquivo)\n      .pipe(csvParser())\n      .on('data', (row) => {\n        linhas.push(Object.values(row).join(' '));\n      })\n      .on('end', () => {\n        resolve(linhas.join('\\n'));\n      })\n      .on('error', (erro) => {\n        logger.error(`Erro ao processar CSV ${caminhoArquivo}: ${erro.message}`);\n        reject(erro);\n      });\n  });\n}\n\n// Processar um arquivo Excel\nfunction processarExcel(caminhoArquivo) {\n  try {\n    const workbook = xlsx.readFile(caminhoArquivo);\n    const resultado = [];\n    \n    workbook.SheetNames.forEach(sheetName => {\n      const worksheet = workbook.Sheets[sheetName];\n      const dados = xlsx.utils.sheet_to_json(worksheet);\n      \n      dados.forEach(linha => {\n        resultado.push(Object.values(linha).join(' '));\n      });\n    });\n    \n    return resultado.join('\\n');\n  } catch (erro) {\n    logger.error(`Erro ao processar Excel ${caminhoArquivo}: ${erro.message}`);\n    return '';\n  }\n}\n\n// Processar HTML (para arquivos que possam conter HTML)\nfunction processarHtml(conteudo) {\n  try {\n    const $ = cheerio.load(conteudo);\n    // Remover scripts e estilos\n    $('script').remove();\n    $('style').remove();\n    \n    // Obter o texto\n    return $('body').text().trim();\n  } catch (erro) {\n    logger.error(`Erro ao processar HTML: ${erro.message}`);\n    return conteudo;\n  }\n}\n\n// Obter todo o conte√∫do da base de conhecimento\nasync function obterConteudoBase() {\n  // Verificar se o cache est√° atualizado\n  if (verificarCacheAtualizado()) {\n    logger.info('Usando cache da base de conhecimento (sem altera√ß√µes desde a √∫ltima leitura)');\n    return documentosCache;\n  }\n  \n  try {\n    const arquivos = obterArquivosBase();\n    \n    if (arquivos.length === 0) {\n      logger.warn('Nenhum arquivo encontrado na base de conhecimento');\n      return '';\n    }\n    \n    logger.info(`Processando ${arquivos.length} arquivos da base de conhecimento...`);\n    \n    let conteudoCompleto = '';\n    \n    for (const arquivo of arquivos) {\n      const caminhoArquivo = path.join(BASE_DIR, arquivo);\n      const extensao = path.extname(arquivo).toLowerCase();\n      \n      logger.info(`Processando arquivo: ${arquivo}`);\n      \n      let conteudo = '';\n      \n      switch (extensao) {\n        case '.pdf':\n          conteudo = await processarPdf(caminhoArquivo);\n          break;\n        case '.json':\n          conteudo = processarJson(caminhoArquivo);\n          break;\n        case '.txt':\n          conteudo = processarTxt(caminhoArquivo);\n          break;\n        case '.csv':\n          conteudo = await processarCsv(caminhoArquivo);\n          break;\n        case '.xlsx':\n          conteudo = processarExcel(caminhoArquivo);\n          break;\n        default:\n          logger.warn(`Tipo de arquivo n√£o suportado: ${extensao}`);\n          continue;\n      }\n      \n      // Verificar se o conte√∫do pode conter HTML e process√°-lo se necess√°rio\n      if (conteudo.includes('<html') || conteudo.includes('<body') || conteudo.includes('<div')) {\n        conteudo = processarHtml(conteudo);\n      }\n      \n      conteudoCompleto += conteudo + '\\n\\n';\n    }\n    \n    // Atualizar o cache\n    documentosCache = conteudoCompleto;\n    dataUltimaAtualizacao = new Date();\n    \n    logger.info('Base de conhecimento processada com sucesso');\n    return conteudoCompleto;\n  } catch (erro) {\n    logger.error(`Erro ao obter conte√∫do da base: ${erro.message}`);\n    return '';\n  }\n}\n\nmodule.exports = {\n  obterConteudoBase\n};"
    },
    {
      "path": "src\\utils.js",
      "name": "utils.js",
      "extension": ".js",
      "size": 3074,
      "last_modified": "2025-04-03T13:54:43.522193",
      "content": "// M√≥dulo de fun√ß√µes utilit√°rias\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst moment = require('moment');\nmoment.locale('pt-br');\n\n// Configura√ß√µes dos diret√≥rios\nconst BASE_CONHECIMENTO_DIR = process.env.BASE_CONHECIMENTO_DIR || './Base_de_conhecimento';\nconst CONTATOS_DIR = process.env.CONTATOS_DIR || './Contatos';\nconst HISTORICO_DIR = process.env.HISTORICO_DIR || './Hist√≥rico';\n\n// Logger simples\nconst logger = {\n  info: (mensagem) => {\n    console.log(`[INFO] ${new Date().toISOString()} - ${mensagem}`);\n  },\n  warn: (mensagem) => {\n    console.warn(`[WARN] ${new Date().toISOString()} - ${mensagem}`);\n  },\n  error: (mensagem) => {\n    console.error(`[ERROR] ${new Date().toISOString()} - ${mensagem}`);\n  }\n};\n\n// Criar diret√≥rios necess√°rios\nfunction criarDiretorios() {\n  try {\n    [BASE_CONHECIMENTO_DIR, CONTATOS_DIR, HISTORICO_DIR].forEach(dir => {\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n        logger.info(`Diret√≥rio criado: ${dir}`);\n      }\n    });\n  } catch (erro) {\n    logger.error(`Erro ao criar diret√≥rios: ${erro.message}`);\n  }\n}\n\n// Verificar se um caminho existe\nfunction caminhoExiste(caminho) {\n  return fs.existsSync(caminho);\n}\n\n// Formatar data no estilo brasileiro (dia de m√™s de ano)\nfunction formatarData(data) {\n  return moment(data).format('D [de] MMMM [de] YYYY');\n}\n\n// Remover acentos de uma string\nfunction removerAcentos(texto) {\n  return texto.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n}\n\n// Limpar string (remover caracteres especiais, espa√ßos extras, etc.)\nfunction limparString(texto) {\n  if (!texto) return '';\n  \n  return texto\n    .replace(/\\s+/g, ' ')              // Substitui m√∫ltiplos espa√ßos por um √∫nico\n    .replace(/[^\\w\\s\\-\\.,;:!?'\"()]/g, '') // Remove caracteres especiais (exceto pontua√ß√£o b√°sica)\n    .trim();                           // Remove espa√ßos no in√≠cio e fim\n}\n\n// Escapar caracteres especiais para regex\nfunction escaparRegex(texto) {\n  return texto.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// Gerar um ID √∫nico\nfunction gerarIdUnico() {\n  return Date.now().toString(36) + Math.random().toString(36).substring(2);\n}\n\n// Fun√ß√£o para esperar um tempo determinado (√∫til para retry)\nfunction esperar(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Retry de uma fun√ß√£o ass√≠ncrona\nasync function retryAsync(funcao, tentativas = 3, intervalo = 1000) {\n  let ultimoErro;\n  \n  for (let i = 0; i < tentativas; i++) {\n    try {\n      return await funcao();\n    } catch (erro) {\n      ultimoErro = erro;\n      logger.warn(`Tentativa ${i + 1}/${tentativas} falhou: ${erro.message}`);\n      \n      if (i < tentativas - 1) {\n        await esperar(intervalo);\n      }\n    }\n  }\n  \n  throw ultimoErro;\n}\n\nmodule.exports = {\n  logger,\n  criarDiretorios,\n  caminhoExiste,\n  formatarData,\n  removerAcentos,\n  limparString,\n  escaparRegex,\n  gerarIdUnico,\n  esperar,\n  retryAsync\n};"
    },
    {
      "path": "src\\whatsapp.js",
      "name": "whatsapp.js",
      "extension": ".js",
      "size": 14929,
      "last_modified": "2025-04-03T13:54:43.525038",
      "content": "// M√≥dulo de conex√£o com WhatsApp usando Baileys (mais leve que Puppeteer)\n\nconst { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');\nconst qrcode = require('qrcode-terminal');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst { logger } = require('./utils');\nconst historicoMensagens = require('./historicoMensagens');\nconst { obterContatos, adicionarNovoContatoNaPlanilha } = require('./leitorContatos');\n\n// Cliente WhatsApp\nlet wa = null;\nlet clienteInicializado = false;\n\n// Importar o gerenciador de conversas\nconst conversasHandler = require('./conversasHandler');\n\n// Pasta para armazenar os dados de autentica√ß√£o\nconst AUTH_FOLDER = process.env.WHATSAPP_SESSION_PATH || './whatsapp-session';\n\n// Configura√ß√£o de presen√ßa\nconst TEMPO_ONLINE = 60000; // 1 minuto em milissegundos\nlet timerPresenca = null;\n\n// Fun√ß√£o para definir o status como offline\nasync function definirOffline() {\n  try {\n    if (wa && clienteInicializado) {\n      // Definir o status como 'unavailable' (que mostra o \"visto por √∫ltimo\")\n      await wa.sendPresenceUpdate('unavailable', null);\n      logger.info('Status definido como offline (visto por √∫ltimo)');\n    }\n  } catch (erro) {\n    logger.error(`Erro ao definir status offline: ${erro.message}`);\n  }\n}\n\n// Fun√ß√£o para gerenciar o status online\nasync function gerenciarPresenca() {\n  // Limpar o timer existente, se houver\n  if (timerPresenca) {\n    clearTimeout(timerPresenca);\n  }\n  \n  // Definir um novo timer para ficar offline ap√≥s o tempo configurado\n  timerPresenca = setTimeout(definirOffline, TEMPO_ONLINE);\n}\n\n// Inicializar o cliente WhatsApp\nasync function iniciarCliente() {\n  try {\n    logger.info('Inicializando cliente WhatsApp usando Baileys...');\n    \n    // Garantir que a pasta de autentica√ß√£o existe\n    if (!fs.existsSync(AUTH_FOLDER)) {\n      fs.mkdirSync(AUTH_FOLDER, { recursive: true });\n      logger.info(`Diret√≥rio de autentica√ß√£o criado: ${AUTH_FOLDER}`);\n    }\n    \n    // Carregar estado de autentica√ß√£o (se existir)\n    const { state, saveCreds } = await useMultiFileAuthState(AUTH_FOLDER);\n    \n    const nullLogger = {\n      child: () => nullLogger,\n      info: () => {},\n      warn: () => {},\n      error: () => {},\n      debug: () => {},\n      trace: () => {}\n    };\n\n    // Criar o socket WhatsApp\n    wa = makeWASocket({\n      auth: state,\n      printQRInTerminal: true,\n      defaultQueryTimeoutMs: 60000, // Timeout mais longo para Raspberry Pi\n      logger: nullLogger\n    });\n    \n    // Manipular eventos de conex√£o e mensagens\n    wa.ev.on('connection.update', async (update) => {\n      const { connection, lastDisconnect, qr } = update;\n      \n      if (qr) {\n        // Exibir QR code no terminal\n        logger.info('QR Code gerado. Escaneie-o com seu WhatsApp:');\n        qrcode.generate(qr, { small: true });\n      }\n      \n      if (connection === 'close') {\n        const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;\n        logger.warn(`Conex√£o fechada devido a ${lastDisconnect.error}. ${shouldReconnect ? 'Reconectando...' : 'N√£o ser√° reconectado.'}`);\n        \n        clienteInicializado = false;\n        \n        if (shouldReconnect) {\n          // Tentar reconectar ap√≥s um breve intervalo\n          setTimeout(iniciarCliente, 5000);\n        }\n      } else if (connection === 'open') {\n        logger.info('Cliente WhatsApp conectado com sucesso!');\n        clienteInicializado = true;\n        \n        // Definir como online inicialmente\n        await wa.sendPresenceUpdate('available', null);\n        // Iniciar o timer para ficar offline\n        gerenciarPresenca();\n      }\n    });\n    \n    // Salvar credenciais quando atualizadas\n    wa.ev.on('creds.update', saveCreds);\n    \n    // Manipular mensagens recebidas\n    wa.ev.on('messages.upsert', async (m) => {\n      if (m.type === 'notify') {\n        for (const msg of m.messages) {\n          // Processar apenas mensagens de outros (n√£o enviadas por n√≥s)\n          if (!msg.key.fromMe) {\n            await processarMensagemRecebida(msg);\n          }\n        }\n      }\n    });\n    \n    logger.info('Sistema de eventos do WhatsApp inicializado');\n    return wa;\n  } catch (erro) {\n    logger.error(`Erro ao inicializar cliente WhatsApp: ${erro.message}`);\n    logger.error(erro.stack);\n    throw erro;\n  }\n}\n\n// Processar mensagens recebidas\nasync function processarMensagemRecebida(msg) {\n  try {\n    \n    // Verificar se √© uma mensagem de grupo\n    if (msg.key.remoteJid.includes('@g.us')) {\n      return; // Ignorar mensagens de grupos\n    }\n    \n    // Obter informa√ß√µes do remetente\n    const remetente = msg.key.remoteJid;\n    const telefone = remetente.split('@')[0];\n    \n    // Verificar se n√£o √© uma mensagem muito antiga\n    const timestampMensagem = msg.messageTimestamp * 1000;\n    const agora = Date.now();\n    const diffMinutos = (agora - timestampMensagem) / (1000 * 60);\n    \n    if (diffMinutos > 10) {\n      logger.info(`Ignorando mensagem antiga (${Math.floor(diffMinutos)} minutos atr√°s)`);\n      return;\n    }\n\n    // Ao receber uma mensagem, definir como online\n    await wa.sendPresenceUpdate('available', remetente);\n    gerenciarPresenca(); // Iniciar o timer para ficar offline\n\n    // Carregar hist√≥rico de conversa\n    const caminhoArquivo = path.join(process.env.CONVERSAS_DIR || './Conversas', `${telefone}.json`);\n    let devocionalJaEnviado = false;\n    \n    if (fs.existsSync(caminhoArquivo)) {\n      try {\n        const conteudo = fs.readFileSync(caminhoArquivo, 'utf8');\n        const historico = JSON.parse(conteudo);\n        \n        // Verificar se j√° enviamos um devocional\n        devocionalJaEnviado = historico && historico.ultimoDevocional;\n        \n        logger.info(`Usu√°rio ${telefone}: ${devocionalJaEnviado ? 'j√° recebeu devocional' : 'ainda n√£o recebeu devocional'}`);\n      } catch (erroLeitura) {\n        logger.error(`Erro ao ler hist√≥rico para ${telefone}: ${erroLeitura.message}`);\n      }\n    } else {\n      logger.info(`Nenhum hist√≥rico encontrado para ${telefone}, enviando devocional de boas-vindas`);\n    }\n\n    if (!devocionalJaEnviado) {\n      logger.info(`Primeira intera√ß√£o detectada para o n√∫mero ${telefone}`);\n    \n      // Adicionar o novo contato √† Planilha\n      try {\n        // Tenta extrair o nome do contato\n        let nomeContato = \"Novo Contato\";\n        \n        // Tente pelo pushName que pode estar dispon√≠vel na pr√≥pria mensagem\n        if (msg.pushName) {\n          nomeContato = msg.pushName;\n        }\n        // Ou pelo objeto key da mensagem\n        else if (msg.key && msg.key.pushName) {\n          nomeContato = msg.key.pushName;\n        }\n        \n        // Adicionar √† Planilha\n        await adicionarNovoContatoNaPlanilha(telefone, nomeContato);\n        logger.info(`Contato ${telefone} (${nomeContato}) adicionado √† planilha de contatos`);\n      } catch (erroContato) {\n        logger.error(`Erro ao adicionar contato √† planilha: ${erroContato.message}`);\n      }\n      \n      // Buscar o √∫ltimo devocional enviado hoje\n      const devocionalHoje = await historicoMensagens.obterUltimoDevocionalEnviado();\n      if (devocionalHoje) {\n        \n        // Enviar mensagem de boas-vindas\n        await wa.sendMessage(remetente, { \n          text: \"Ol√° üòÄ! Seja bem-vindo(a) ao Whatsapp Devocional-IA. Aqui est√° o devocional de hoje:\" \n        });\n        \n        // Pequena pausa\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        \n        // Enviar o devocional\n        await wa.sendMessage(remetente, { text: devocionalHoje });\n        \n        // Registrar o devocional enviado para este contato\n        await conversasHandler.registrarDevocionalEnviado(telefone, devocionalHoje);\n        logger.info(`Devocional do dia enviado para novo contato: ${telefone}`);\n        return;\n      } else {\n        logger.warn(`N√£o foi poss√≠vel encontrar um devocional para enviar ao novo contato ${telefone}`);\n      }\n    }\n    \n    // Verificar o tipo de mensagem\n    const messageType = Object.keys(msg.message || {})[0];\n    \n    // Processar √°udio\n    if (['audioMessage', 'pttMessage'].includes(messageType)) {\n      logger.info(`√Åudio recebido de ${telefone}, respondendo com mensagem padr√£o`);\n      \n      // Mensagens gentis e educadas para responder a √°udios\n      const mensagensAudio = [\n        \"Ol√°! Recebi seu √°udio, mas ainda n√£o consigo process√°-lo. Voc√™ poderia, por gentileza, enviar sua pergunta ou coment√°rio como mensagem de texto? Assim poderei lhe ajudar melhor. üôè\",\n        \"Agrade√ßo pelo seu √°udio! No momento, n√£o disponho da capacidade de ouvi-lo. Poderia, por favor, compartilhar seu pensamento ou pergunta em forma de texto? Ficarei feliz em responder!\",\n        \"Recebi sua mensagem de voz! Infelizmente, ainda n√£o consigo compreender √°udios. Se puder enviar o mesmo conte√∫do em texto, ser√° um prazer conversar sobre o devocional de hoje ou qualquer outro assunto espiritual.\"\n      ];\n      \n      // Escolher uma mensagem aleatoriamente\n      const respostaAudio = mensagensAudio[Math.floor(Math.random() * mensagensAudio.length)];\n      \n      // Indicar que est√° digitando (simulando digita√ß√£o)\n      await wa.sendPresenceUpdate('composing', remetente);\n      \n      // Pequena pausa para simular digita√ß√£o (entre 1-3 segundos)\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n      \n      // Enviar a resposta\n      await wa.sendMessage(remetente, { text: respostaAudio });\n      logger.info(`Resposta para √°udio enviada para ${telefone}`);\n      \n      // Reiniciar o timer de presen√ßa\n      gerenciarPresenca();\n      return;\n    }\n    \n    // Extrair o conte√∫do da mensagem de texto\n    let conteudo = '';\n    \n    if (messageType === 'conversation') {\n      conteudo = msg.message.conversation;\n    } else if (messageType === 'extendedTextMessage') {\n      conteudo = msg.message.extendedTextMessage.text;\n    } else {\n      // Outros tipos de mensagem (imagem, v√≠deo, etc.)\n      conteudo = \"M√≠dia recebida\";\n    }\n    \n    logger.info(`Mensagem recebida de ${telefone}: ${conteudo.substring(0, 50)}${conteudo.length > 50 ? '...' : ''}`);\n    \n    // Verificar se a mensagem precisa de resposta\n    if (conversasHandler.ePergunta(conteudo) || conteudo.length >= 10) {\n      logger.info(`Gerando resposta para mensagem de ${telefone}...`);\n      \n      // Indicar que est√° digitando (simulando digita√ß√£o)\n      await wa.sendPresenceUpdate('composing', remetente);\n      \n      // Gerar a resposta\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\n      \n      // Calcular tempo de digita√ß√£o baseado no tamanho da resposta\n      // M√©dia de digita√ß√£o: cerca de 5 caracteres por segundo (ajuste conforme necess√°rio)\n      const tempoDigitacao = Math.min(Math.max(resposta.length / 5 * 1000, 2000), 8000);\n      \n      // Simular tempo de digita√ß√£o\n      await new Promise(resolve => setTimeout(resolve, tempoDigitacao));\n      \n      // Parar de \"digitar\"\n      await wa.sendPresenceUpdate('paused', remetente);\n      \n      // Pequena pausa antes de enviar (como se estivesse revisando)\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Enviar a resposta\n      await wa.sendMessage(remetente, { text: resposta });\n      \n      logger.info(`Resposta enviada para ${telefone}`);\n    } else {\n      logger.info(`Mensagem curta, enviando resposta simples`);\n      \n      // Indicar que est√° digitando\n      await wa.sendPresenceUpdate('composing', remetente);\n      \n      // Para mensagens curtas ou agradecimentos, enviar uma resposta simples\n      const resposta = await conversasHandler.gerarRespostaParaMensagem(telefone, conteudo);\n      \n      // Simular digita√ß√£o r√°pida (1-3 segundos)\n      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n      \n      // Enviar resposta\n      await wa.sendMessage(remetente, { text: resposta });\n    }\n    \n    // Reiniciar o timer de presen√ßa ap√≥s enviar mensagem\n    gerenciarPresenca();\n  } catch (erro) {\n    logger.error(`Erro ao processar mensagem recebida: ${erro.message}`);\n    try {\n      // Tentar enviar uma mensagem de erro para o usu√°rio\n      await wa.sendMessage(msg.key.remoteJid, { \n        text: \"Desculpe, ocorreu um erro ao processar sua mensagem. Por favor, tente novamente mais tarde.\" \n      });\n    } catch (erroEnvio) {\n      logger.error(`Erro ao enviar mensagem de erro: ${erroEnvio.message}`);\n    }\n  }\n}\n\n// Verificar se o cliente est√° pronto\nfunction clientePronto() {\n  return wa !== null && clienteInicializado;\n}\n\n// Enviar mensagem para um contato\nasync function enviarMensagem(telefone, mensagem) {\n  try {\n    if (!clientePronto()) {\n      throw new Error('Cliente WhatsApp n√£o est√° pronto');\n    }\n    \n    // Formatar o n√∫mero de telefone (remover caracteres n√£o num√©ricos)\n    const numeroFormatado = telefone.toString().replace(/\\D/g, '');\n    \n    // Garantir que o n√∫mero tenha o formato correto para o WhatsApp\n    const chatId = `${numeroFormatado}@s.whatsapp.net`;\n    \n    // Definir como online ao enviar mensagem\n    await wa.sendPresenceUpdate('available', chatId);\n    \n    // Enviar a mensagem\n    await wa.sendMessage(chatId, { text: mensagem });\n    \n    // Iniciar o timer para ficar offline\n    gerenciarPresenca();\n    \n    return true;\n  } catch (erro) {\n    logger.error(`Erro ao enviar mensagem: ${erro.message}`);\n    throw erro;\n  }\n}\n\n// Encerrar o cliente\nasync function encerrarCliente() {\n  try {\n    if (wa) {\n      // Definir como offline antes de desconectar\n      try {\n        await definirOffline();\n      } catch (erroPresenca) {\n        logger.warn(`Erro ao definir offline antes de encerrar: ${erroPresenca.message}`);\n      }\n      \n      // Limpar o timer de presen√ßa\n      if (timerPresenca) {\n        clearTimeout(timerPresenca);\n        timerPresenca = null;\n      }\n      \n      // N√£o h√° um m√©todo espec√≠fico para \"destruir\" no Baileys,\n      // mas podemos remover os listeners e limpar refer√™ncias\n      wa.ev.removeAllListeners();\n      wa = null;\n      clienteInicializado = false;\n      logger.info('Cliente WhatsApp encerrado');\n    }\n  } catch (erro) {\n    logger.error(`Erro ao encerrar cliente WhatsApp: ${erro.message}`);\n  }\n}\n\nmodule.exports = {\n  iniciarCliente,\n  clientePronto,\n  enviarMensagem,\n  encerrarCliente,\n};"
    },
    {
      "path": "Tutoriais\\Deploy.md",
      "name": "Deploy.md",
      "extension": ".md",
      "size": 5617,
      "last_modified": "2025-04-03T13:54:43.498753",
      "content": "# README - Comandos Linux para Deploy e Manuten√ß√£o do WhatsApp Devocional\n\nEste documento detalha todos os comandos Linux necess√°rios para configurar, implantar e manter o sistema WhatsApp Devocional em um servidor Raspberry Pi/DietPi.\n\n## √çndice\n1. [Instala√ß√£o de Pr√©-requisitos](#1-instala√ß√£o-de-pr√©-requisitos)\n2. [Configura√ß√£o do Projeto](#2-configura√ß√£o-do-projeto)\n3. [Configura√ß√£o do Servi√ßo Systemd](#3-configura√ß√£o-do-servi√ßo-systemd)\n4. [Gerenciamento de Permiss√µes](#4-gerenciamento-de-permiss√µes)\n5. [Gerenciamento do Servi√ßo](#5-gerenciamento-do-servi√ßo)\n6. [Visualiza√ß√£o de Logs](#6-visualiza√ß√£o-de-logs)\n7. [Manuten√ß√£o do Sistema](#7-manuten√ß√£o-do-sistema)\n8. [Solu√ß√£o de Problemas](#8-solu√ß√£o-de-problemas)\n\n## 1. Instala√ß√£o de Pr√©-requisitos\n\n### Atualizar o sistema\n```bash\nsudo apt update\nsudo apt upgrade -y\n```\n\n### Instalar o Node.js\n```bash\n# Instalar o Node.js (recomendado vers√£o LTS)\ncurl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -\nsudo apt install -y nodejs\n```\n\n### Instalar as depend√™ncias essenciais\n```bash\nsudo apt install -y git\n```\n\n## 2. Configura√ß√£o do Projeto\n\n### Clonar/Preparar o Projeto\n```bash\n# Criar diret√≥rio para o projeto\nmkdir -p /home/dietpi/Node.js\ncd /home/dietpi/Node.js\n\n# Instalar depend√™ncias do projeto\nnpm install\n```\n\n### Criar diret√≥rios necess√°rios e ajustar permiss√µes iniciais\n```bash\n# Criar diret√≥rios de sistema\nmkdir -p Conversas\nmkdir -p Hist√≥rico\nmkdir -p whatsapp-session\nmkdir -p Base_de_conhecimento\nmkdir -p Contatos\n\n# Ajustar permiss√µes iniciais\nchmod -R 755 /home/dietpi/Node.js/\n```\n\n## 3. Configura√ß√£o do Servi√ßo Systemd\n\n### Criar o arquivo de servi√ßo\n```bash\nsudo nano /etc/systemd/system/whatsapp-devocional.service\n```\n\n### Conte√∫do do arquivo de servi√ßo\n```ini\n[Unit]\nDescription=WhatsApp Devocional Service\nAfter=network.target\n\n[Service]\nType=simple\nUser=dietpi\nGroup=dietpi\nWorkingDirectory=/home/dietpi/Node.js\nExecStart=/usr/local/bin/npm start\nRestart=on-failure\nRestartSec=10\nStandardOutput=syslog\nStandardError=syslog\nSyslogIdentifier=whatsapp-devocional\nEnvironment=NODE_ENV=production\n\n[Install]\nWantedBy=multi-user.target\n```\n\n### Recarregar o daemon do systemd\n```bash\nsudo systemctl daemon-reload\n```\n\n### Habilitar o servi√ßo para iniciar na inicializa√ß√£o\n```bash\nsudo systemctl enable whatsapp-devocional.service\n```\n\n## 4. Gerenciamento de Permiss√µes\n\n### Configurar permiss√µes corretas para todos os diret√≥rios do projeto\n```bash\n# Tornar o usu√°rio dietpi propriet√°rio de todos os arquivos\nsudo chown -R dietpi:dietpi /home/dietpi/Node.js/\n\n# Definir permiss√µes para diret√≥rios que precisam de escrita\nsudo chmod -R 777 /home/dietpi/Node.js/Conversas/\nsudo chmod -R 777 /home/dietpi/Node.js/whatsapp-session/\nsudo chmod -R 777 /home/dietpi/Node.js/Hist√≥rico/\nsudo chmod -R 777 /home/dietpi/Node.js/temp_audio/\n```\n\n## 5. Gerenciamento do Servi√ßo\n\n### Iniciar o servi√ßo\n```bash\nsudo systemctl start whatsapp-devocional.service\n```\n\n### Verificar status do servi√ßo\n```bash\nsudo systemctl status whatsapp-devocional.service\n```\n\n### Parar o servi√ßo\n```bash\nsudo systemctl stop whatsapp-devocional.service\n```\n\n### Reiniciar o servi√ßo\n```bash\nsudo systemctl restart whatsapp-devocional.service\n```\n\n### Recarregar configura√ß√£o sem reiniciar\n```bash\nsudo systemctl reload whatsapp-devocional.service\n```\n\n## 6. Visualiza√ß√£o de Logs\n\n### Ver logs do servi√ßo em tempo real\n```bash\nsudo journalctl -u whatsapp-devocional.service -f\n```\n\n### Ver logs do servi√ßo com timestamps\n```bash\nsudo journalctl -u whatsapp-devocional.service --no-pager\n```\n\n### Ver logs das √∫ltimas 100 linhas\n```bash\nsudo journalctl -u whatsapp-devocional.service -n 100\n```\n\n### Ver logs desde a √∫ltima inicializa√ß√£o\n```bash\nsudo journalctl -u whatsapp-devocional.service -b\n```\n\n### Ver logs de um per√≠odo espec√≠fico\n```bash\nsudo journalctl -u whatsapp-devocional.service --since \"2025-04-02 12:00:00\" --until \"2025-04-02 14:00:00\"\n```\n\n## 7. Manuten√ß√£o do Sistema\n\n### Verificar espa√ßo em disco\n```bash\ndf -h\n```\n\n### Verificar uso de mem√≥ria\n```bash\nfree -h\n```\n\n### Verificar processos em execu√ß√£o\n```bash\nhtop  # Instale com: sudo apt install htop\n```\n\n### Verificar conex√µes de rede\n```bash\nnetstat -tuln\n```\n\n### Configurar reinicializa√ß√£o autom√°tica semanal (bom para limpeza de mem√≥ria)\n```bash\nsudo crontab -e\n```\nAdicione esta linha para reiniciar todo domingo √†s 4h da manh√£:\n```\n0 4 * * 0 /sbin/reboot\n```\n\n## 8. Solu√ß√£o de Problemas\n\n### Se o servi√ßo n√£o iniciar\nVerifique primeiro os logs:\n```bash\nsudo journalctl -u whatsapp-devocional.service -n 50\n```\n\n### Verificar se o Node.js est√° funcionando corretamente\n```bash\nnode -v\nnpm -v\n```\n\n### Verificar permiss√µes dos arquivos cr√≠ticos\n```bash\nls -la /home/dietpi/Node.js/whatsapp-session/\nls -la /home/dietpi/Node.js/Conversas/\n```\n\n### Corrigir permiss√µes novamente se necess√°rio\n```bash\nsudo chown -R dietpi:dietpi /home/dietpi/Node.js/\nsudo chmod -R 777 /home/dietpi/Node.js/Conversas/\nsudo chmod -R 777 /home/dietpi/Node.js/whatsapp-session/\n```\n\n### Reiniciar o sistema em √∫ltimo caso\n```bash\nsudo reboot\n```\n\n---\n\nEste documento cobre os comandos essenciais para o gerenciamento do WhatsApp Devocional em um servidor Linux. Consulte este guia sempre que precisar realizar manuten√ß√£o ou solucionar problemas no sistema."
    }
  ]
}